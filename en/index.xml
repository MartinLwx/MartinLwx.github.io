<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>MartinLwx&#39;s blog</title>
        <link>https://martinlwx.github.io/en/</link>
        <description>Welcome to my blog :)</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>martinlwx@163.com (MartinLwx)</managingEditor>
            <webMaster>martinlwx@163.com (MartinLwx)</webMaster><lastBuildDate>Sat, 01 Jul 2023 17:12:40 &#43;0800</lastBuildDate>
            <atom:link href="https://martinlwx.github.io/en/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>How to memorize the Red-black tree</title>
    <link>https://martinlwx.github.io/en/how-to-memorize-insertion-and-deletion-in-rb-tree/</link>
    <pubDate>Sat, 01 Jul 2023 17:12:40 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/how-to-memorize-insertion-and-deletion-in-rb-tree/</guid>
    <description><![CDATA[Intro If you are attracted by the title of this blog, I believe you may agree with me: The process of memorizing the insertion and deletion operations of the Red-black tree can be incredibly arduous. It entails keeping track of complex tree rotations and the necessity to recolor nodes as required. I once read the renowned Introducing to Algorithms written by the CLRS. However, there are so many cases to remember and I quickly get overwhelmed.]]></description>
</item>
<item>
    <title>Git bundle guide</title>
    <link>https://martinlwx.github.io/en/git-bundle-tutorial/</link>
    <pubDate>Fri, 16 Jun 2023 23:48:28 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/git-bundle-tutorial/</guid>
    <description><![CDATA[What is the git bundle command git bundle is a relatively less commonly used git command. Its purpose is to package a git repo into a single file, which can then be used by others to recreate the original git repo. Additionally, git bundle supports incremental update. Before I learned about the git bundle command, I would usually directly use tar czf some_git_repo to create a package for a git repo.]]></description>
</item>
<item>
    <title>Understanding GAT throught MPNN</title>
    <link>https://martinlwx.github.io/en/understanding-graph-attention-network-through-mpnn/</link>
    <pubDate>Sun, 21 May 2023 15:20:50 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/understanding-graph-attention-network-through-mpnn/</guid>
    <description><![CDATA[What&rsquo;s MPNN Justin Gilmer proposed the MPNN (Message Passing Neural Network) framework 1 for describing graph neural network models used in supervised learning on graphs. I found this to be a useful framework that provides a clear understanding of how different GNN models work and facilitates a quick grasp of the differences between them. Considering a node $v$ on the graph $G$, the update procedure for its vector representation $h_v$ is as follows:]]></description>
</item>
<item>
    <title>SICP Exercise 2.27</title>
    <link>https://martinlwx.github.io/en/sicp-exercise-2-27/</link>
    <pubDate>Tue, 16 May 2023 12:41:20 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/sicp-exercise-2-27/</guid>
    <description><![CDATA[Question Modify your reverse procedure of exercise 2.18 to produce a deep-reverse procedure that takes a list as an argument and returns as its value the list with its elements reversed and with all sublists deep-reversed as well.
1 2 3 4 (define x (list (list 1 2) (list 3 4))) ;; x - ((1 2) (3 4)) (deep-reverse x) ;; the output should be ((4 3) (2 1)) Answer In the previous Exercise 2.]]></description>
</item>
<item>
    <title>SICP Exercise 1.46</title>
    <link>https://martinlwx.github.io/en/sicp-exercise-1-46/</link>
    <pubDate>Wed, 10 May 2023 13:40:48 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/sicp-exercise-1-46/</guid>
    <description><![CDATA[Question Several of the numerical methods described in this chapter are instances of an extremely general computational strategy known as iterative improvement. Iterative improvement says that, to compute something, we start with an initial guess for the answer, test if the guess is good enough, and otherwise improve the guess and continue the process using the improved guess as the new guess. Write a procedure iterative-improve that takes two procedures as arguments: a method for telling whether a guess is good enough and a method for improving a guess.]]></description>
</item>
<item>
    <title>SICP Exercise 1.34</title>
    <link>https://martinlwx.github.io/en/sicp-exercise-1-34/</link>
    <pubDate>Tue, 09 May 2023 14:06:18 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/sicp-exercise-1-34/</guid>
    <description><![CDATA[Question Suppose we define the procedure f. What happens if we (perversely) ask the interpreter to evaluate the combination (f f)?
1 2 3 4 5 (define (square x) (* x x)) (define (f g) (g 2)) Then we have
1 2 3 (f square) ;; 4 (f (lambda (z) (* z (+ z 1)))) ;; 6 = 2 * 3 Answer Recall what the applicative-order evaluation says: We need to evaluate all arguments and then we apply procedure on these arguments.]]></description>
</item>
<item>
    <title>Solution of Proj4. Scheme Interpreter of CS61A (2021-Fall)</title>
    <link>https://martinlwx.github.io/en/proj4-scheme-interpreter-of-cs61a-of-ucb-fa21/</link>
    <pubDate>Fri, 21 Apr 2023 10:18:16 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/proj4-scheme-interpreter-of-cs61a-of-ucb-fa21/</guid>
    <description><![CDATA[Intro Recently, I am reading a book called Crafting interpreters written by Robert Nystrom. In the original book, a Tree-walker interpreter jlox was implemented in Java. And I am trying to rewrite in Python - pylox. I highly recommend it👍. At this moment, I suddenly remembered that there were a few small issues with the Scheme interpreter for CS61A that I had not resolved after finishing it a year ago, which kept it in an unfinished state.]]></description>
</item>
<item>
    <title>Solving DP problems by SRTBOT Framework</title>
    <link>https://martinlwx.github.io/en/solving-dynamic-programming-problems-using-srtbot/</link>
    <pubDate>Sun, 09 Apr 2023 12:30:31 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/solving-dynamic-programming-problems-using-srtbot/</guid>
    <description><![CDATA[Changelog:
Update dependency graphs @2023.04.13 Intro When solving algorithm problems, what often gives me a headache are dynamic programming problems(DP problems). They are the type of problems that I can&rsquo;t figure out on my own after thinking for a long time, but after seeing the answer, it suddenly becomes clear and reasonable. However, the next time I encounter a similar problem, I may forget how to solve it. I have also read many people&rsquo;s solutions and tried to digest and apply their ideas, but I have been unable to find a particularly good framework that works for all dynamic programming problems.]]></description>
</item>
<item>
    <title>How to understand the backpropagation algorithm</title>
    <link>https://martinlwx.github.io/en/backpropagation-tutorial/</link>
    <pubDate>Tue, 04 Apr 2023 13:45:48 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/backpropagation-tutorial/</guid>
    <description><![CDATA[Intro In the field of deep learning, optimizing the network involves a crucial process of continuously updating the weights and bias items. This is achieved by implementing the gradient descent method, which progressively minimizes the loss function. At the heart of this process lies the backpropagation algorithm, which facilitates efficient computation of gradients across the network
To better understand this concept, let us recall the formula for gradient descent. In this formula, we utilize the symbol $\theta$ to represent all the learnable parameters of the model, $J$ to represent the cost or loss function, and $\alpha$ to denote the learning rate.]]></description>
</item>
<item>
    <title>Linear Regression Model Guide - theory part</title>
    <link>https://martinlwx.github.io/en/linear-regression-model-guide-theory/</link>
    <pubDate>Wed, 15 Mar 2023 12:37:52 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/linear-regression-model-guide-theory/</guid>
    <description><![CDATA[Introduction Recently, I review the machine learning course of Andrew ng in Coursera. Surprisingly, I can still learn a lot, so I decided to write some posts👍.
To talk about linear regression, we must first have a basic understanding of what is machine learning. What is machine learning? abstractly speaking, machine learning is learning a function: $$ f(input) = output $$ where $f$ refers to the specific machine learning model. Machine learning is a methodology for automatically mining the relationship between input and output.]]></description>
</item>
</channel>
</rss>

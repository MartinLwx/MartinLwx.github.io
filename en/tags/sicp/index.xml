<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>SICP - Tag - MartinLwx&#39;s blog</title>
        <link>https://martinlwx.github.io/en/tags/sicp/</link>
        <description>SICP - Tag - MartinLwx&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>martinlwx@163.com (MartinLwx)</managingEditor>
            <webMaster>martinlwx@163.com (MartinLwx)</webMaster><lastBuildDate>Tue, 09 May 2023 14:06:18 &#43;0800</lastBuildDate><atom:link href="https://martinlwx.github.io/en/tags/sicp/" rel="self" type="application/rss+xml" /><item>
    <title>SICP Exercise 1.34</title>
    <link>https://martinlwx.github.io/en/sicp-exercise-1-34/</link>
    <pubDate>Tue, 09 May 2023 14:06:18 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/sicp-exercise-1-34/</guid>
    <description><![CDATA[Question Suppose we define the procedure f. What happens if we (perversely) ask the interpreter to evaluate the combination (f f)?
1 2 3 4 5 (define (square x) (* x x)) (define (f g) (g 2)) Then we have
1 2 3 (f square) ;; 4 (f (lambda (z) (* z (+ z 1)))) ;; 6 = 2 * 3 Answer Recall what the applicative-order evaluation says: We need to evaluate all arguments and then we apply procedure on these arguments.]]></description>
</item>
</channel>
</rss>

<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Racket - Tag - MartinLwx&#39;s blog</title>
        <link>https://martinlwx.github.io/en/tags/racket/</link>
        <description>Racket - Tag - MartinLwx&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>martinlwx@163.com (MartinLwx)</managingEditor>
            <webMaster>martinlwx@163.com (MartinLwx)</webMaster><lastBuildDate>Tue, 16 May 2023 12:41:20 &#43;0800</lastBuildDate><atom:link href="https://martinlwx.github.io/en/tags/racket/" rel="self" type="application/rss+xml" /><item>
    <title>SICP Exercise 2.27</title>
    <link>https://martinlwx.github.io/en/sicp-exercise-2-27/</link>
    <pubDate>Tue, 16 May 2023 12:41:20 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/sicp-exercise-2-27/</guid>
    <description><![CDATA[Question Modify your reverse procedure of exercise 2.18 to produce a deep-reverse procedure that takes a list as an argument and returns as its value the list with its elements reversed and with all sublists deep-reversed as well.
1 2 3 4 (define x (list (list 1 2) (list 3 4))) ;; x - ((1 2) (3 4)) (deep-reverse x) ;; the output should be ((4 3) (2 1)) Answer In the previous Exercise 2.]]></description>
</item>
<item>
    <title>SICP Exercise 1.46</title>
    <link>https://martinlwx.github.io/en/sicp-exercise-1-46/</link>
    <pubDate>Wed, 10 May 2023 13:40:48 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/sicp-exercise-1-46/</guid>
    <description><![CDATA[Question Several of the numerical methods described in this chapter are instances of an extremely general computational strategy known as iterative improvement. Iterative improvement says that, to compute something, we start with an initial guess for the answer, test if the guess is good enough, and otherwise improve the guess and continue the process using the improved guess as the new guess. Write a procedure iterative-improve that takes two procedures as arguments: a method for telling whether a guess is good enough and a method for improving a guess.]]></description>
</item>
<item>
    <title>SICP Exercise 1.34</title>
    <link>https://martinlwx.github.io/en/sicp-exercise-1-34/</link>
    <pubDate>Tue, 09 May 2023 14:06:18 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/sicp-exercise-1-34/</guid>
    <description><![CDATA[Question Suppose we define the procedure f. What happens if we (perversely) ask the interpreter to evaluate the combination (f f)?
1 2 3 4 5 (define (square x) (* x x)) (define (f g) (g 2)) Then we have
1 2 3 (f square) ;; 4 (f (lambda (z) (* z (+ z 1)))) ;; 6 = 2 * 3 Answer Recall what the applicative-order evaluation says: We need to evaluate all arguments and then we apply procedure on these arguments.]]></description>
</item>
</channel>
</rss>

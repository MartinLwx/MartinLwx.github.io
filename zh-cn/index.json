[{"categories":["System-Programming"],"content":"引言 如果你一直都是是用动态语言，比如 Python、Javascript 这种，你很可能并不会注意到栈和堆的区别。因为这些语言有垃圾收集器（Garbage collector，GC）存在，会自动帮你做好内存管理，你只要集中注意力编程即可。坏消息是 GC 并不是没有成本的事情，实际上设计再好的 GC 算法，也会降低代码的性能。如果你接触编程的时间足够久，那么想必你可能会听到过什么“递归层数太深栈爆炸了”这种话，此时你可能会点开搜索引擎稍微了解一下栈和堆的区别，有可能你就刚好点进了这一篇文章 :) 📒 虽然 GC 会降低代码性能，但是免去了开发人员手动管理内存的心智负担，可以大大加速软件开发的速度，这是牺牲性能换取开发速度。但到了软件后期出现性能瓶颈的时候，就不得不研究如何重构甚至重写关键部分的代码提高性能了。 这里的栈和堆并不是数据结构里面的堆和栈，而是指内存管理的两种机制。了解栈和堆的细节差异有助于我们理解一些比较接近底层的编程语言，这里说的编程语言比如 Rust、C 和 C++ 等。在 Rust 中，最为重要的概念就是所有权的问题，Rust 的很多设计都是围绕它展开，掌握了所有权就能在学习 Rust 的时候如鱼得水😄。 ","date":"2022-09-19","objectID":"/zh-cn/what-is-the-heap-and-stack/:1:0","tags":["System-programming"],"title":"什么是堆和栈","uri":"/zh-cn/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"程序在内存上的布局 我们知道，要运行一个程序必须将程序加载到内存里面，在程序运行的过程中，数据也是需要读取到内存上的，那么你有没有想过这一切在内存上是如何分布的呢？下面我会给出一个比较简单的示意图1：如下所示： 在上图中，不同部分存放的东西分别是： text：存放代码 data：存放初始化过的静态变量（Initialized static variables），比如全局变量、静态变量 bss：存放未经初始化的静态变量（Uninitialized static data），比如 C 语言的 static int i heap stack 关于栈和堆会在后面进行单独说明 📒 这里要记住的就是：栈和堆是在向彼此靠近的，栈是从高地址 -\u003e 低地址增长，而堆是低地址 -\u003e 高地址增长。这样你在看汇编代码的时候看到入栈时 sp 指针是做减法你就能理解了。 📒 虽然看起来，随着我们申请内存越来越多，栈和堆可能会冲突（因为他们在彼此靠近），但是实际上并不需要担心这个问题，因为：1）这个布局是发生在虚拟内存上的，现在的处理器一般是 64 位的，容量非常大。2）在它们冲突之前，很有可能你的物理内存早就耗尽了，还是先担心这个 ","date":"2022-09-19","objectID":"/zh-cn/what-is-the-heap-and-stack/:2:0","tags":["System-programming"],"title":"什么是堆和栈","uri":"/zh-cn/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"栈 ","date":"2022-09-19","objectID":"/zh-cn/what-is-the-heap-and-stack/:3:0","tags":["System-programming"],"title":"什么是堆和栈","uri":"/zh-cn/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"术语 Stack pointer(SP)：实际上是一个寄存器，里面存放栈顶的地址 Stack frame：当发生函数调用的时候就会创建 Stack frame。可以理解为它包含了函数调用的相关数据。比如函数的参数、函数的返回地址、函数的局部变量（除了分配在堆上的）等。一连串的 Stack frame 就构成了调用栈（Call stack） 入栈：在栈上申请空间 出栈：在栈上释放空间 ","date":"2022-09-19","objectID":"/zh-cn/what-is-the-heap-and-stack/:3:1","tags":["System-programming"],"title":"什么是堆和栈","uri":"/zh-cn/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"栈上的内存管理是如何进行的 栈最大的特点就是先进后出（Last in first out, LIFO），这是我们在栈上申请空间和释放空间的时候的遵循的模式，这也是它叫做栈的原因。在内存上申请空间其实并不神秘，就是要标记哪些范围的地址是这个程序要用的。对栈来说，只要修改 stack pointer 的值即可，自然的，从栈底（下图中的 A）到栈顶（sp 指向的位置）就是我们栈上申请了的空间 下面的图1就展现了这个简单的逻辑： 这里仍要再次强调，栈是从高地址 -\u003e 低地址增长，所以上图从左到右是高地址 -\u003e 低地址，所以在栈上申请空间（入栈）的时候实际上 sp 是做减法. 函数调用也是用栈完成的: 调用函数的时候：修改 sp 指针 -\u003e 构造被调用的函数的 stack frame，其中包括函数参数和其他一些必要的数据，将其入栈 -\u003e 进入 Callee 函数退出的时候：上面的过程反过来就行 📒 在栈上申请内存空间的时候需要担心的问题是：不要申请太多导致栈爆了（也就是大名鼎鼎的 Stack Overflow）。这一点在写递归函数的时候要特别注意。你可以选择改成迭代的算法，也可以考虑增加栈的大小限制。比如在 Python 里面可以用 sys.getrecursionlimit() 来修改栈的大小限制。有的编程语言还会对尾递归进行优化，此时也可以选择将普通的递归函数改写为尾递归的形式。 ","date":"2022-09-19","objectID":"/zh-cn/what-is-the-heap-and-stack/:3:2","tags":["System-programming"],"title":"什么是堆和栈","uri":"/zh-cn/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"以斐波那契数列的递归函数看栈的变化 CS 课程中讲解递归的时候一般都会讲到斐波那契数列，现在我们用 F(n) 表示斐波那契数列的第 n 个值，那么有： F(0) = 0 F(1) = 1 F(n) = F(n - 1) + F(n - 2) 以 F(4) 为例，递归计算的方式如下： F(4) = F(3) + F(2) = F(2) + F(1) + F(1) + F(0) = F(1) + F(0) + F(1) + F(1) + F(0) = 3 * F(1) + 2 * F(0) 如果我们忽略一些细节，感受函数调用的过程中栈的变化情况，那么大概如下所示： 注： 下面的 F(n) 表示每个函数自己的 stack frame stack: F(4) stack: F(4) | F(3) # F(4): enter F(3) stack: F(4) | F(3) | F(2) # F(3): enter F(2) stack: F(4) | F(3) | F(2) | F(1) # F(2): enter F(1), F(1) is the base case, ready to exit function call stack: F(4) | F(3) | F(2) # Function return, return to the body of F(2) stack: F(4) | F(3) | F(2) | F(0) # F(2): enter F(0), F(0) is the base case, ready to exit function call stack: F(4) | F(3) | F(2) # Function return, return to the body of F(2) stack: F(4) | F(3) | F(1) # F(3): enter F(1), F(1) is the base case, ready to exit function call stack: F(4) | F(3) # Function return, return to the body of F(3) stack: F(4) # Function return, return to the body of F(4) stack: F(4) | F(2) # F(4): enter F(2) stack: F(4) | F(2) | F(1) # F(2): enter F(1), F(1) is the base case, ready to exit function call stack: F(4) | F(2) # Function return, return to the body of F(2) stack: F(4) | F(2) | F(0) # F(2): enter F(0), F(0) is the base case, ready to exit function call stack: F(4) | F(2) # Function return, return to the body of F(2) stack: F(4) # Function return, return to the body of F(4) ","date":"2022-09-19","objectID":"/zh-cn/what-is-the-heap-and-stack/:3:3","tags":["System-programming"],"title":"什么是堆和栈","uri":"/zh-cn/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"栈上存放的是什么数据 栈上的内存空间管理是通过修改 sp 指针的值实现的，很容易知道下面几点： 栈上的内存申请和释放都十分高效，为 O(1)，只要修改 sp 的值即可 栈的这种 LIFO 的逻辑比较简单，编译器其实就能帮我们处理好，作为开发者我们不需要干预这个过程 修改 sp 指针决定要申请多大的空间，意味着我们必须知道要申请的数据有多大（编译时要能确定），所以栈适合存放的数据是固定已知大小的。而大小不固定的数据是用堆来解决的 ","date":"2022-09-19","objectID":"/zh-cn/what-is-the-heap-and-stack/:3:4","tags":["System-programming"],"title":"什么是堆和栈","uri":"/zh-cn/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"堆 栈的不足之处是：无法处理大小可变的数据，我们无法知道此时 sp 的值要修改为多少。 如何在大小可变的数据和栈之间搭建起桥梁呢？这就需要用到指针了。虽然实际存储的数据大小未知，但是指针的大小是固定已知的（只要保证寻址范围能覆盖到整个内存就行，一般跟机器字长相等），所以我们可以在栈上存储一个固定大小的指针，让这个它指向堆上存储的真正数据。 ","date":"2022-09-19","objectID":"/zh-cn/what-is-the-heap-and-stack/:4:0","tags":["System-programming"],"title":"什么是堆和栈","uri":"/zh-cn/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"堆上的内存管理是如何进行的 正如前面提到的，在堆上申请内存其实就是在堆上找到一个足够大的空间，并返回这个位置的指针，而后指针入栈。 后面我们想要访问这个数据的时候，就对指针解引用即可。C 语言或者 Rust 里面的 * 操作符就是用来干这个的。不知道看到这里，以前难懂的指针是不是稍微能理解一点了 :) 不同于栈里面简单修改 sp 指针即可，堆上的内存管理复杂得多。包括下面几点： 堆上可以分配的内存的位置是任意的、大小也是任意的（不超过物理内存大小即可），而栈只要遵循先进后出就行。为了管理堆上已分配和待分配堆空间，我们需要设计相应的算法和数据结构，这就给堆上的内存管理带来很大的困难 在堆上申请空间的效率也比较低。最基本的，我们起码要找到一个足够大小的空间，这个找的过程肯定是比直接修改 sp 的值耗时的。 还要处理好「碎片化」的问题。因为堆上申请空间是这边分配一块那边分配一块，在重复的申请空间和释放空间的过程中，会在内存里面留下很多碎片。极端的情况是：碎片加起来的可分配大小满足你的要求，但是因为他们散落在内存各个地方无法利用从而导致了内存不足 📒 堆上可以分配的内存比较大，但是需要更良好的管理机制来处理这种比较复杂的情况。对开发人员来说，也造成了一定的负担，我们无法依赖编译器自动帮我们处理，而是要自己手动管理内存，比如在 C 语言中你进行了 malloc() 函数申请空间之后要是忘记用 free() 释放，那么你的程序就会存在内存泄露的问题。更别谈还有其他的诸如悬垂指针等问题。 ","date":"2022-09-19","objectID":"/zh-cn/what-is-the-heap-and-stack/:4:1","tags":["System-programming"],"title":"什么是堆和栈","uri":"/zh-cn/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"堆上存放的是什么数据 对堆上内存空间的分配有一定了解之后，我们不难得出下面的几个结论： 堆上存放的是容量可变的数据。更灵活的同时，代价是牺牲了一点性能 有时候也可以是固定大小的数据，但是你不想放在栈上。为什么会有这种情况？比如，在 Rust 里面，栈上的数据是默认生成拷贝，有时候出于性能的考量，你可能想要把很大的数据放在堆上，避免多次拷贝带来的开销。不知道看到这里你们有没有想到我们常常说函数参数传递引用比传递值效率更高这个优化呢？ ","date":"2022-09-19","objectID":"/zh-cn/what-is-the-heap-and-stack/:4:2","tags":["System-programming"],"title":"什么是堆和栈","uri":"/zh-cn/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"总结 栈和堆都是内存管理里面的概念，他们跟数据结构里的栈和堆的概念不一样。栈之所以叫做栈是因为我们在进行内存申请和分配的时候都遵循 LIFO 模式，而堆这个名字则是体现了堆上面的数据毫无组织。 通常来说，在栈上申请和释放内存空间是比较高效的。为此，Rust 里面默认都是在栈上操作 栈上一般放「固定大小」的数据，堆上一般放「大小可变」的数据。但是有时候出于性能的考量，也会在堆上存放固定大小的数据 在 CS 这门学科里面，经常可以看到分层的设计，比如计算机网络的 OSI 模型。包括编程语言本身也可以分为高级语言和低级语言。6.172 性能工程的老师说的一句话分享给你们—— “很多时候你要学好这一层的东西是必须了解下面一层的东西，你不一定要会用下一层的东西，但是知道下一层的细节会帮助你学这一层”。至少对我来说，知道了栈和堆的区别之后，下面的几个问题在我看来有了很合理的解释： C/C++ 语言的指针是用来干什么的？他们为什么存在？ 为什么尾递归优化会存在？为什么在写递归函数的时候都要考虑递归层数太深的问题？ 为什么 Rust 默认数据放在栈上？ 为什么以前会看到 C/C++ 传递函数参数的时候要用引用这种说法，说这样会比较快？ 📒 在 CS 里面，我认为最重要的概念就是封装。逐层封装，对上一层隐藏细节的这种设计实在很不错。 选择带有 GC 好上手但效率较低的语言还是选择自己手动管理内存让代码效率更高呢？这点其实取决于你手头的工作。如果要开发速度当然是前者了，如果注重性能那就是后者。当然，夹在中间的是没有 GC + 基本不用自己手动管理内存 + 效率高的 Rust 语言🚀，要不学点 Rust😉 ⚠️ 本文在组织的时候可以忽略了一些细节，我只讲了我认为比较重要的几点。如果想要了解更多，值得一看的材料包括1和2。 ","date":"2022-09-19","objectID":"/zh-cn/what-is-the-heap-and-stack/:5:0","tags":["System-programming"],"title":"什么是堆和栈","uri":"/zh-cn/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"参考资料 6.172. Performance engineering of software systems - Lecture 11 \u0026\u0026 Lecture 12 ↩︎ ↩︎ ↩︎ CS110L. System programming - Memory Safety ↩︎ ","date":"2022-09-19","objectID":"/zh-cn/what-is-the-heap-and-stack/:6:0","tags":["System-programming"],"title":"什么是堆和栈","uri":"/zh-cn/what-is-the-heap-and-stack/"},{"categories":[],"content":"How to use vim's macro system","date":"2022-07-02","objectID":"/zh-cn/vim-macro-101/","tags":["vim"],"title":"Vim Macro 101","uri":"/zh-cn/vim-macro-101/"},{"categories":[],"content":"引言 在我学习 vim 的过程中，最具有启发意义的一句话是： vim 其实是一门编程语言 很早之前我就接触过 vim，但是当时 vim 的按键组合和按键的逻辑对我来说很难记忆，再加上 vim 的界面实在太过于复古，于是我就转向了比较现代的文本编辑器。但当我学完 Missing semester 的时候，我对 vim的看法完全改观：它远远不止是一个文本编辑器 这似乎和这篇博客要讨论的主题没有关系。但其实不是这样的，认识到 vim 是一门编程语言是一件重要的事情。程序员经常经常通过编程来完成很多枯燥重复的工作，不同人对编程语言的偏好各不相同。vim 也可以完成这样的任务，今天要讨论的宏就是。我希望看完这一篇之后 vim 也会被你们用来解决一些问题🚀 ","date":"2022-07-02","objectID":"/zh-cn/vim-macro-101/:1:0","tags":["vim"],"title":"Vim Macro 101","uri":"/zh-cn/vim-macro-101/"},{"categories":[],"content":"什么是 vim 里面的宏 下面假定你对 vim 有一定的了解 : ) 在 vim 里面，我们可以用 . 重复上一次的“更改”，这里的“更改”一般指的是比较简单的操作，比如删除一个单词等。 但其实，vim 也提供了宏让我们可以重复执行一些比较复杂的操作，它会把我们的操作记录下来，存放到指定的寄存器里面。那么我们可以只录制宏一次而执行它很多次 ","date":"2022-07-02","objectID":"/zh-cn/vim-macro-101/:2:0","tags":["vim"],"title":"Vim Macro 101","uri":"/zh-cn/vim-macro-101/"},{"categories":[],"content":"基本指南 ","date":"2022-07-02","objectID":"/zh-cn/vim-macro-101/:3:0","tags":["vim"],"title":"Vim Macro 101","uri":"/zh-cn/vim-macro-101/"},{"categories":[],"content":"### 怎么录制一个宏 步骤： 在 Normal 模式下，按q\u003cregister\u003e. 这里的意思是说先按q 然后选择一个寄存器 register 来存放待会录制的宏 可以选用的寄存器 regitser 包括: 0-9, a-z, 和 \"。关于这里为什么没有大写字母我会在后面解释 开始录制宏，如果上一步正确执行的话，此时你应该会看到左下角显示 recording @\u003cregister\u003e。从此刻起，你所有的操作都会被录制下来 再次按下 q 退出录制 📒 要让自己录制的宏鲁棒性强一点，关键在于你在录制的时候要想想：不同的 文件可能会有哪些情况要处理，要保证自己的每一步都可以在各种不同的情况里面复现出来 ","date":"2022-07-02","objectID":"/zh-cn/vim-macro-101/:4:0","tags":["vim"],"title":"Vim Macro 101","uri":"/zh-cn/vim-macro-101/"},{"categories":[],"content":"怎么查看宏的内容 前面提到，vim 会把我们录制的宏存放在指定的寄存器里面，所以查看宏的内容很简单，用一个简单的 :reg 命令就行，比如 :reg \u003cregister\u003e 里面你会看到一些奇怪的字符，比如： ^[ 是 \u003cESC\u003e 键 \u003c80\u003ekb 是 BAKESPACE 键 ","date":"2022-07-02","objectID":"/zh-cn/vim-macro-101/:4:1","tags":["vim"],"title":"Vim Macro 101","uri":"/zh-cn/vim-macro-101/"},{"categories":[],"content":"怎么执行宏 在一个文件里面执行 @\u003cregister\u003e: 执行存放在 \u003cregister\u003e 这个寄存器里面的宏 @@: 执行我们上一次调用过的宏 如果想要多次执行的话，在命令的前面先输入 [COUNT] 表示要执行多少次。 e.g. 100@@ 的意思是：执行上一次调用的宏 100 次 有时候我们想要在这个文件里面重复执行直到整个文件都修改完，但是我们没有必要自己手动计算这个次数 [COUNT] 应该是多少，可以设置一个很大的值，超过的部分会被 vim 忽略 在多个文件里面执行 当然，如果只能在一个文件里面重复执行宏的话，能用它来解决的问题还比较局限。我们总不可能每次都要打开一个文件然后手动输入 @@ 执行宏。好在 vim 提供了方法让我们可以批量处理多文件 比如说现在我们想要编辑当前目录下的所有 txt 文件，只要在命令行输入 vim *.txt 就可以打开所有文件（每个文件对应一个 buffer，整体可以看成是一个列表）。在这个模式下我们可以一次编辑一个文件，编辑完毕之后按 :wn 保存当前文件的更改并跳转到下一个文件。但我们也能一次性对这个文件列表里的所有文件进行更改 此时我们位于文件列表的第一个文件，第一件要做的事情是以第一个文件文样本录制宏 注意录制完毕之后，需要使用 :edit! 命令撤销在录制宏对过程中对第一个文件的更改。因为我们之后会对文件列表中所有对文件应用我们对宏，如果没有这个撤销操作的话，第一个文件就会被更改两次 虽然界面看起来像是在编辑一个文件，但如果你要直接按 :x 保存退出的话就会弹出警告 输入命令： :bufdo execute \"normal @\u003cregister\u003e | update. 关于 bufdo 的说明可以在 vim 里面输入 :h bufdo 查看。可以理解为对所有的 buffer 执行操作 这里的 normal @\u003cregister\u003e 的意思就是在 Normal 模式下执行 @\u003cregister\u003e 里面的宏 更多的细节可以看这里 ","date":"2022-07-02","objectID":"/zh-cn/vim-macro-101/:4:2","tags":["vim"],"title":"Vim Macro 101","uri":"/zh-cn/vim-macro-101/"},{"categories":[],"content":"怎么修改已经录制好的宏 简单情况 这里说的简单情况是，你只是想要在你本来录制好的宏后面追加一些操作。还记得之前我刻意跳过了把 A-Z 当作寄存器的这个情况吗？事实上，当你用大写字母的寄存器的时候，你录制的东西会追加在对应的小写寄存器的内容后面 复杂情况 此时你要编辑宏，但是要编辑的位置是在宏的中间，这也是可以实现的吗？当然，我们没有必要从头录制，宏其实本质上只是存储在寄存器里面的字符序列，vim 可以解读这些内容重复执行。我们要做的事情只是修改寄存器里面的内容而已。 具体步骤如下： 按下 G 跳转到当前文件的最后一行（其实别的行也可以，只是跳转到最后一行我们编辑宏的时候比较不会受到干扰），然后输入 :put \u003cregister\u003e 命令，对应寄存器里面的内容就会被粘贴在下一行 然后我们开始编辑就行 编辑完成之后（确保还在这一行），按下 :d \u003cregister\u003e 就可以把当前行的内容存回去 下面是我录制的一个简单的例子，我们来录制了一个宏放在寄存器 y 里面，功能是在当前行的末尾追加 world，现在我想要修改在当前行追加 hello world ","date":"2022-07-02","objectID":"/zh-cn/vim-macro-101/:4:3","tags":["vim"],"title":"Vim Macro 101","uri":"/zh-cn/vim-macro-101/"},{"categories":[],"content":"和其他工具协同工作 在 Linux 中，我们可以将一些命令行工具和 vim 结合使用。一个使用场景比如：我们想要批量编辑一些文件，但是这个文件散落在不同的地方。那我们就可以使用 find 命令和 vim 做到这件事情。可以参考这个. 使用 find \u003cpattern\u003e -exec vim {} + 打开所有对应的文件 使用之前提到过的 bufdo 命令批量操作 ","date":"2022-07-02","objectID":"/zh-cn/vim-macro-101/:5:0","tags":["vim"],"title":"Vim Macro 101","uri":"/zh-cn/vim-macro-101/"},{"categories":[],"content":"总结 这只是一个简单的关于 vim 里面宏的应用，这只是 vim 强大功能的冰山一角，当你掌握其他 vim 相关的功能的时候（比如搜索与替换，快速定位到某个位置），才能发挥出 vim 的最大效力。如果这篇博客可以让你对 vim 产生兴趣那就再好不过。别忘了一句著名的话：一开始我们挑选了我们喜欢的工具，后来工具会反过来塑造我们，它甚至影响着我们的思维😉 ","date":"2022-07-02","objectID":"/zh-cn/vim-macro-101/:6:0","tags":["vim"],"title":"Vim Macro 101","uri":"/zh-cn/vim-macro-101/"},{"categories":["Compiler"],"content":"use the semantic actions to generate the symbol tables in ANTLR4","date":"2022-05-28","objectID":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"什么是 semantic actions 当 Parser 处理输入的代码的时候不仅要判断是否语法和句法都正确，还可以执行一些有用的操作，这些操作就叫做 Semantic actions。其实也就是一段代码，一般嵌入在在语法文件的规则里面。那么当 parser 应用这个规则的时候就会执行你设置的这段代码。换个角度理解，semantic actions 其实就是“触发器”，触发条件就是 parser 应用了对应的规则。 今天这篇文章要探讨的就是一个关于 semantic actions 的应用——实现一个简单的 symbol table，用到的工具是 ANTLR4。 ","date":"2022-05-28","objectID":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/:1:0","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"什么是 symbol table 编译器在处理我们的代码的时候会在内部维护一个 symbol table，用来存储程序里面所有关于变量的信息：变量名、数据类型、变量所属的作用域等。symbol table 可以是下面这种形式： Symbol name Type Scope bar function, double extern x double function parameter foo function, double global count int function parameter sum double block local i int for-loop statement ","date":"2022-05-28","objectID":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/:2:0","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"如何在 ANTLR 的语法文件里面注入动作 ANTLR4 是一个强大的 parse generator，我们只要编写好语法文件，就能让它帮我们自动生成 Parser，生成的 Parser 可以支持多种目标语言，比如我自己用的是 Python，那么最后生成的 Parser 就是 Python 文件。 ANTLR4 也提供了方法让我们可以在语法文件里面插入动作，这些动作最后都会被 ANTLR4 注入到生成的 Parser 文件里面。因此，动作用什么语言写取决于你输出 Parser 的目标语言是什么 ⚠️这里假定你对如何编写 ANTLR4 的语法文件（*.g4）有基本了解，不会进行赘述，本文只集中介绍如何在语法文件里面插入动作 ","date":"2022-05-28","objectID":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/:3:0","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"动作注入的位置和方法 下面是简化的生成的 Parser 文件的代码模板。总体上来看，我们能注入的位置如下所示： \u003cheader\u003e class xxxParser(Parser): ... \u003cmember\u003e def rule(self): ... \u003caction\u003e 下面我对每个位置的不同语法进行说明： \u003cheader\u003e ANTLR4 本来就是用 Java 写的，所以如果你用的目标语言也是 Java 的话，这个会比较用得到。一般就是用来放 import 语句的。如果是 python 的话哪里都能 import 就比较没差。要往这个位置注入代码的格式如下（放在 *.g4 文件里面，下同） @header{ everything here will go to \u003cheader\u003e } \u003cmember\u003e 这个放的就是类的成员，可以是字段也可以是方法。ANTLR4 支持往 Lexer 和 Parser 分别或者同时注入代码。要往这个位置注入代码的格式如下： @members { everything here will go to \u003cmember\u003e in xxxLexer \u0026\u0026 xxxParser } @Lexer::members { everything here will go to \u003cmember\u003e in xxxLexer } @Parser::members { everything here will go to \u003cmember\u003e in xxxParser } ⚠️在我使用的 antlr4-python3-runtime 中（4.10），还无法在插入类的字段进行注释 \u003caction\u003e 在 ANTLR4 中，动作是用花括号 {\u003cspecific-language-here\u003e} 括起来的代码。正如前面提到的，看你最后输出的 Parser 想要是什么语言，你就用什么语言写动作。 动作一般会放在一条规则的某个 symbol 之后，意思是说在 parser 应用这条规则的时候执行到这里就执行相应的动作。这里的 symbol 可以是 terminal 也可以是 nonterminal。 我们可以用 $symbol.attr 的方式访问到对应的属性，有下面这几个： $terminal.text # origin text $terminal.type # an integer stands for type $terminal.attributes $terminal.line # the line number $terminal.pos # the position of the first char in the line，0-based $terminal.index $terminal.channel # the channel of this terminal, won't discuss in this post $terminal.int # return an interger if this terminal is an integer $nonterminal.text # origin text $nonterminal.start # 1st Token $nonterminal.stop # last Token $nonterminal.ctx # return context object ","date":"2022-05-28","objectID":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/:3:1","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"举个例子 ⚠️下面都只会给出部分代码，完整的代码在我的 Github 项目 ⚠️因为这个项目要求把 warning 输出在其他输出前面，所以我用 warning_list 和 output_list 来存储，最后再一起输出 下面以普渡大学 2015 年的开设的编译器课程的项目作业为例，整个项目要实现一个 Micro 语言的编译器，关于 Micro 语言的语法，可以在这里看到。下面我会对步骤三的作业要求进行一个简单的介绍。 在这个作业中我们要构建一个 symbol table，并在相应的时刻输出相关的信息： 每当我们进入一个新的作用域之前（可以是函数，也可以是代码块），要进行相关的输出 如果遇到变量声明，就输出变量名和变量类型，有值的话也要输出。 如果声明的变量在外部作用域已经声明过的话要输出：SHADOW WARNING \u003cvar_name\u003e，适用于有嵌套的作用域出现的情况 如果在当前作用域已经有同名的变量，就要输出：DECLARATION ERROR \u003cvar_name\u003e。如果出现了这种情况，那么最后程序只输出这个信息 Symbol table \u003cscope_name\u003e name \u003cvar_name\u003e type \u003ctype_name\u003e name \u003cvar_name\u003e type \u003ctype_name\u003e value \u003cstring_value\u003e ","date":"2022-05-28","objectID":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/:4:0","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"数据结构的选取及对应的方法 🤔先要解决的问题是，要用什么数据结构表示 symbol table？一个 symbol table 应该要满足下面的特点： 要能够支持高效率地查询 要能够支持高效率地插入，因为程序中可能包含大量的变量声明 要能够记录变量的作用域 不难想出，支持高效率查询和插入的数据结构就是「哈希表」。为了维护变量的作用域，可以把同个作用域下的变量放在同个哈希表里面，用一个列表来记住所有的变量作用域，也就是说是 [{scope1}, {scope2},...] 这样。同时维护一个 self.current_scope 来记住当前处于哪一个变量作用域里面。每当有一个新的作用域出现的时候，保存当前的作用域，往列表里插入一个新的作用域，再更新 self.current_scope。 📒 这里的 list 其实就是用来模拟栈 🤔我们要实现什么样的方法？起码要有下面这几个： lookup(identifier, value)：插入变量到当前的 symbol table 里面。根据这个项目作业的要求，还应该查询是否变量已经被声明过 enter_new_scope()：保存当前的 symbol table，进入下一个变量作用域并初始化为空 exit_scope()：清空当前的 symbol table，找到上一个 symbol table 所以对应 @parser:members 里面的代码如下 @parser::members { def init(self): self.current_scope = None self.block_count = 0 self.warning_list = [] # just for printing self.output_list = [] # just for printing self.declaration_error = '' def enter_new_scope(self): if not hasattr(self, '_scopes'): setattr(self, '_scopes', []) # save the current_scope import copy if len(self._scopes) \u003e 0: self._scopes.append(copy.deepcopy(self.current_scope)) self._scopes.append({}) self.current_scope = self._scopes[-1] def exit_scope(self): del self._scopes[-1] if len(self._scopes) \u003e 0: self.current_scope = self._scopes[-1] def lookup(self, identifier, value): # check all scopes found = False for scope in self._scopes[:-1][::-1]: #print(f\"the scope: {scope}\") if identifier in scope: found = True if found: self.warning_list.append(f\"SHADOW WARNING {identifier}\") # only record the 1st declaration error if identifier in self.current_scope and self.declaration_error == '': self.declaration_error = f\"DECLARATION ERROR {identifier}\" self.current_scope[identifier] = value } ","date":"2022-05-28","objectID":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/:4:1","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"注入动作到变量声明中 🧐接下来就是要在对应的语法规则里面注入动作。我们想要在定义变量的时候输出相关的信息，所以我们先要观察在 Micro 语言中变量声明的规则是怎么样的，如下所示： ... var_decl : var_type id_list ';' ; var_type : 'FLOAT' | 'INT' ; any_type : var_type | 'VOID' ; id_list : id id_tail ; id_tail : ',' id id_tail | ; ... 可以看到，声明变量对应的是 var_decl 规则，一次可以声明一至多个变量，每一个变量之间用 , 隔开的，所以我们可以在这条规则的末尾最后注入如下的动作代码。 ⚠️要注意如果你也是使用 python 的话，这里所以缩进会有点怪，因为每一行都要从最左边开始，但最后生成的代码是没有问题的 ... var_decl : var_type id_list ';' { # NOTE: the indentation is correct, ANLTR4 will handle this for us :) # for all variable declarations, we should output the name \u0026\u0026 type # in the same variable declaration, it means all of the variables have the same type for variable in $id_list.text.split(','): self.lookup(variable, None) self.output_list.append(f\"name {variable} type {$var_type.text}\") } ; ... 我们用 $id_list.text 来获取本来的变量声明对应的文本，用 $var_type.text 来获取对应的变量类型 ","date":"2022-05-28","objectID":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/:4:2","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"关于变量作用域的处理 下面以 program 规则为例（函数和代码块的类似），progarm 规则是 Micro 语法的起始规则，规定了 Micro 程序应该要有的大框架，规则如下所示： program : 'PROGRAM' id 'BEGIN' pgm_body 'END' ; 我们处理完 PROGRAM 这个 token 之后就可以初始化第一个作用域（全局作用域），最后要处理完程序再退出这个全局作用域，所以我们可以很快想到应该把动作注入在哪里 program : 'PROGRAM' id 'BEGIN' pgm_body 'END' ; ^ ^ | 2 最后插入相关的动作 program : 'PROGRAM' { self.init() self.output_list.append(\"Symbol table GLOBAL\") self.enter_new_scope() } id 'BEGIN' pgm_body 'END' { self.exit_scope() # output everything after we parsing this program if self.declaration_error != '': print(self.declaration_error) else: if len(self.warning_list) \u003e 0: print('\\n'.join(self.warning_list)) print('\\n'.join(self.output_list)) } ; ","date":"2022-05-28","objectID":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/:4:3","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"扩展阅读 前面只涉及到简单的动作注入，ANTLR4 其实支持的功能还更多： 比如我们可以让 nonterminal 返回值 在同一条规则如果出现多个同名的 nonterminal 的话可以起名字 下面是来自书中的一个例子，就很好地展示了上面两个用法 e returns [int v] : a=e op=('*'|'/') b=e {$v = self.eval($a.v, $op, $b.v)} | a=e op=('+'|'-') b=e {$v = self.eval($a.v, $op, $b.v)} | INT {$v = $INT.int} | ID ","date":"2022-05-28","objectID":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/:5:0","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"总结 从这个例子中我们可以学习到要如何在 ANTLR4 里面使用动作，生成 symbol table 只是其中一个运用。在代码里面注入动作是很符合直觉的做法，可以快速实现自己想要的功能。不过缺点也很明显，它是 language-dependent 的，也就是说你一旦换了 ANTLR 输出的目标语言，你注入的动作全部要改成新的目标语言。另外就是会让本来干净的语法文件一团糟。 ","date":"2022-05-28","objectID":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/:6:0","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"参考 Symbol table - wiki 《ANTLR4 权威指南》 ","date":"2022-05-28","objectID":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/:7:0","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/zh-cn/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":[],"content":"A simple explanation of the boyer-moore majority voting algorithm","date":"2022-03-24","objectID":"/zh-cn/boyer-moore-majority-voting-algorithm-explained/","tags":["algorithm"],"title":"Boyer-Moore Majority Voting Algorithm Explained","uri":"/zh-cn/boyer-moore-majority-voting-algorithm-explained/"},{"categories":[],"content":"引言 今天又做到了 Leetcode 169. 多数元素 这一道题. 我依稀记得最优的解法叫做什么摩尔投票法. 但是我对它的印象竟然只有这个名字本身了 Orz. 对于这个算法本身倒是忘得一干二净. 于是我打算系统性地学习一下这个算法的原理, 并将它总结出来写成这篇博客. 不知道在哪里看到的一句话 : 当你开始教别人的时候, 你就真的掌握它了 所以, 我今天在这里打算跟大家分享这个算法, 并试图以浅显的语言让你也学会这个方法, 那么让我们开始吧 :) ","date":"2022-03-24","objectID":"/zh-cn/boyer-moore-majority-voting-algorithm-explained/:1:0","tags":["algorithm"],"title":"Boyer-Moore Majority Voting Algorithm Explained","uri":"/zh-cn/boyer-moore-majority-voting-algorithm-explained/"},{"categories":[],"content":"先从简单的方法开始聊起 如果从来没有听说过摩尔投票法, 我们会如何尝试解决这个问题, 起码要有下面的思路: 用空间换时间, 也就是用一个哈希表把每个元素出现的次数记下来, 然后我们再检查一遍我们的哈希表并找到其中出现次数大于 $\\lfloor n/2\\rfloor$ 的就可以.这样时间复杂度和空间复杂度都是 $O(n)$ 尝试对数组进行排序, 因为我们要找的元素超过了数组一半的长度, 这意味着它一定会出现在数组的中间位置. 这个也不难想到, 但是用排序的话虽然空间复杂度是 $O(1)$, 但是时间复杂度还是大于 $O(n)$ 的, *比如如果你采用的是快速排序的话, 时间复杂度就是 $O(nlogn)$ 那么有没有一种方法可以做到时间复杂度是 $O(n)$, 空间复杂度是 $O(1)$ 呢? 也就是结合了上面两个方法的优点. 有的, 答案就是摩尔投票法 ! ","date":"2022-03-24","objectID":"/zh-cn/boyer-moore-majority-voting-algorithm-explained/:2:0","tags":["algorithm"],"title":"Boyer-Moore Majority Voting Algorithm Explained","uri":"/zh-cn/boyer-moore-majority-voting-algorithm-explained/"},{"categories":[],"content":"摩尔投票法 问题描述: 假设我们的数组有 $n$ 个元素, 我们要找到其中出现次数超过一半的元素 算法流程: 从这 $n$ 个元素中选一个作为 candidate，记录它的票数为 votes = 1. 此时我们的数组中还有 $n-1$ 个元素, 我们每次都取出一个元素(记为 current), 并重复执行以下的步骤(一共 n-1 次) 将它和我们当前的 candidate 做比较, 如果它们的值一样, 那么 votes++, 也就是投赞同票 如果它们的值不一样, votes--, 也就是投反对票. 如果此时 votes = 0 的话, 那么 candidate \u003c- current, 也就是说我们让 current 成为了新的 candidate, 并记 votes = 1 最后 candidate 的值就可能是我们想要的出现次数超过一半的元素, 此时我们得再遍历一遍数组进行计数看它到底是不是 在看完上面的算法流程之后, 你可能跟我一样感到很困惑. 为什么这样最后我们就能找到出现次数超过一半的元素. 其实只要想明白一个原理就很简单 💡 出现次数超过 $\\lfloor n/2\\rfloor$ 次的元素如果存在, 此时数组中的其他元素一定是出现次数小于 $\\lfloor n/2\\rfloor$ 的 这句话有什么用呢 ? 因为摩尔投票法的做法其实就是投票 可以是投赞同票, 此时相当于我们在统计这个元素出现的次数 可以是投反对票. 相当于我们撤销了一个同意票, 就是抵消抵消抵消!!! 但是因为出现次数超过一半的元素加起来的票数(赞同票) \u003e 剩下所有不是的(反对票)这件事是一定成立的, 所以无论怎样最后赢的永远是出现次数超过一半的元素. 于是我们就找到了 :) 如果还是不懂可以看看下面的这个 GIF 图理解一下~ ","date":"2022-03-24","objectID":"/zh-cn/boyer-moore-majority-voting-algorithm-explained/:3:0","tags":["algorithm"],"title":"Boyer-Moore Majority Voting Algorithm Explained","uri":"/zh-cn/boyer-moore-majority-voting-algorithm-explained/"},{"categories":[],"content":"代码 class Solution { public int majorityElement(int[] nums) { if (nums.length \u003c 2) { return nums[0]; } int candidates = nums[0]; int votes = 1; // step 1. start to vote for (int i = 0; i \u003c nums.length; i++) { if (nums[i] != candidates) { votes -= 1; if (votes == 0) { candidates = nums[i]; votes = 1; } } else { votes += 1; } } // step2. check int occurs = 0; for (var val: nums) { if (candidates == val) { occurs += 1; } } if (occurs \u003e= nums.length / 2) { return candidates; } else { return -1; } } } ","date":"2022-03-24","objectID":"/zh-cn/boyer-moore-majority-voting-algorithm-explained/:4:0","tags":["algorithm"],"title":"Boyer-Moore Majority Voting Algorithm Explained","uri":"/zh-cn/boyer-moore-majority-voting-algorithm-explained/"},{"categories":[],"content":"FAQ Q: 为什么还需要第二轮检查呢? 能不能直接看 votes 呢? A: 不能, 首先这个「出现次数超过一半」的元素不一定存在. 比如 [1,2,3]. 另外就算它存在, 遍历完数组之后, 此时 votes 也不一定是它的真实票数. 比如 [1, 2, 2, 2, 3] 最后 3 会投反对票导致 votes - 1 ","date":"2022-03-24","objectID":"/zh-cn/boyer-moore-majority-voting-algorithm-explained/:5:0","tags":["algorithm"],"title":"Boyer-Moore Majority Voting Algorithm Explained","uri":"/zh-cn/boyer-moore-majority-voting-algorithm-explained/"},{"categories":[],"content":"The simple solution of proj3.Ants vs. SomeBees of CS61B","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":[],"content":"Intro 前两个项目还算简单, 比较不复杂. 但是今天这个第三个项目难度确实是上升了(看游戏规则就知道这个有多复杂了). 感觉像是植物大战僵尸 所以我打算为他写一篇博客来整理一下写代码时候的思路. 话不多说, 让我们进入正题吧 ! ","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/:1:0","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":[],"content":"Phase 1: Basic gameplay ","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/:2:0","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":[],"content":"Problem 1 (1 pt) Part A: Currently, there is no cost for placing any type of Ant, and so there is no challenge to the game. The base class Ant has a food_cost of zero. Override this class attribute for HarvesterAnt and ThrowerAnt according to the “Food Cost” column in the table below. Part B: Now that placing an Ant costs food, we need to be able to gather more food! To fix this issue, implement the HarvesterAnt class. A HarvesterAnt is a type of Ant that adds one food to the gamestate.food total as its action. 根据题目的要求设置 HarversterAnt 和 ThrowerAnt 的属性, 同时实现 HarvesterAnt 的 action 方法, 让它可以在每次行动的时候给 food + 1 class HarvesterAnt(Ant): \"\"\"HarvesterAnt produces 1 additional food per turn for the colony.\"\"\" name = 'Harvester' implemented = True food_cost = 2 def action(self, gamestate): \"\"\"Produce 1 additional food for the colony. gamestate -- The GameState, used to access game state information. \"\"\" gamestate.food += 1 class ThrowerAnt(Ant): \"\"\"ThrowerAnt throws a leaf each turn at the nearest Bee in its range.\"\"\" name = 'Thrower' implemented = True damage = 1 food_cost = 3 ","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/:2:1","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":[],"content":"Problem 2 (1 pt) In this problem, you’ll complete Place.__init__ by adding code that tracks entrances. Right now, a Place keeps track only of its exit. We would like a Place to keep track of its entrance as well. A Place needs to track only one entrance. Tracking entrances will be useful when an Ant needs to see what Bees are in front of it in the tunnel. However, simply passing an entrance to a Place constructor will be problematic; we would need to have both the exit and the entrance before creating a Place! (It’s a chicken or the egg problem.) To get around this problem, we will keep track of entrances in the following way instead. Place.__init__ should use this logic: A newly created Place always starts with its entrance as None. If the Place has an exit, then the exit’s entrance is set to that Place. 其实这个赛道有点像数据结构中的双向链表的结构, 往左边用 .exit, 往右边用 .entrance 方法. 要求已经在上面给出, 没什么难度 class Place: \"\"\"A Place holds insects and has an exit to another Place.\"\"\" is_hive = False def __init__(self, name, exit=None): \"\"\"Create a Place with the given NAME and EXIT. name -- A string; the name of this Place. exit -- The Place reached by exiting this Place (may be None). \"\"\" self.name = name self.exit = exit self.bees = [] # A list of Bees self.ant = None # An Ant self.entrance = None # A Place # Phase 1: Add an entrance to the exit if exit is not None: self.exit.entrance = self ","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/:2:2","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":[],"content":"Problem 3 (1 pt) In order for a ThrowerAnt to throw a leaf, it must know which bee to hit. The provided implementation of the nearest_bee method in the ThrowerAnt class only allows them to hit bees in the same Place. Your job is to fix it so that a ThrowerAnt will throw_at the nearest bee in front of it that is not still in the Hive. This includes bees that are in the same Place as a ThrowerAnt Hint: All Places have an is_hive attribute which is True when that place is the Hive. Change nearest_bee so that it returns a random Bee from the nearest place that contains bees. Your implementation should follow this logic: Start from the current Place of the ThrowerAnt. For each place, return a random bee if there is any, and if not, inspect the place in front of it (stored as the current place’s entrance). If there is no bee to attack, return None. 现在我们要给 ThrowerAnt 加上功能, 这样才能让它攻击距离它最近的蜜蜂🐝. 注意如果蜜蜂和他在同一个格子里, 也是可以攻击的. 我们的工作要求是遍历每个格子(就跟你遍历链表一样)找到第一个有蜜蜂的格子, 随机返回一个蜜蜂 def nearest_bee(self): \"\"\"Return the nearest Bee in a Place that is not the HIVE, connected to the ThrowerAnt's Place by following entrances. This method returns None if there is no such Bee (or none in range). \"\"\" pos = self.place while pos.entrance is not None: if not pos.is_hive: if len(pos.bees) \u003e 0: return random_bee(pos.bees) pos = pos.entrance return None ","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/:2:3","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":[],"content":"Phase 2: Ants! ","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/:3:0","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":[],"content":"Problem 4 (2 pt) A ThrowerAnt is a powerful threat to the bees, but it has a high food cost. In this problem, you’ll implement two subclasses of ThrowerAnt that are less costly but have constraints on the distance they can throw: The LongThrower can only throw_at a Bee that is found after following at least 5 entrance transitions. It cannot hit Bees that are in the same Place as it or the first 4 Places in front of it. If there are two Bees, one too close to the LongThrower and the other within its range, the LongThrower should only throw at the farther Bee, which is within its range, instead of trying to hit the closer Bee. The ShortThrower can only throw_at a Bee that is found after following at most 3 entrance transitions. It cannot throw at any bees further than 3 Places in front of it. Neither of these specialized throwers can throw_at a Bee that is exactly 4 Places away. 现在我们要实现两个类, LongThrower 和 ShortThrower. 两个都是 ThrowererAnt 的子类, 其实从他们的名字可以看出来他们的区别在于攻击范围的不同. 思路: 我们如何表示攻击范围这个概念呢 ? 其实很简单, 在 problem 3 中我们找到最近的蜜蜂的时候就是一个格子一个格子前进的, 我们可以同时计算步数, 那么我们就这道这个距离, 再配合 min_range 和 max_range 这两个参数(类变量, 表示这个类对应的蚂蚁的攻击范围, 只有落在这个区间的才行) 同时要注意我们不能影响 problem 3 中的结果, 这也容易想到, 我们让 min_range=-1, max_range=float('inf'), 这样就相当于没有限制了 ~! 而且因为面向对象程序设计的优势, 我们省去了不少代码量. # In problem 3 class ThrowerAnt(Ant): \"\"\"ThrowerAnt throws a leaf each turn at the nearest Bee in its range.\"\"\" name = 'Thrower' implemented = True damage = 1 food_cost = 3 min_range = -1 max_range = float('inf') def nearest_bee(self): \"\"\"Return the nearest Bee in a Place that is not the HIVE, connected to the ThrowerAnt's Place by following entrances. This method returns None if there is no such Bee (or none in range). \"\"\" steps_cnt = 0 pos = self.place while pos.entrance is not None: if steps_cnt \u003e self.max_range: return None if not pos.is_hive: if len(pos.bees) \u003e 0 and steps_cnt \u003e= self.min_range: return random_bee(pos.bees) pos = pos.entrance steps_cnt += 1 return None class ShortThrower(ThrowerAnt): \"\"\"A ThrowerAnt that only throws leaves at Bees at most 3 places away.\"\"\" name = 'Short' food_cost = 2 # OVERRIDE CLASS ATTRIBUTES HERE implemented = True # Change to True to view in the GUI max_range = 3 class LongThrower(ThrowerAnt): \"\"\"A ThrowerAnt that only throws leaves at Bees at least 5 places away.\"\"\" name = 'Long' food_cost = 2 # OVERRIDE CLASS ATTRIBUTES HERE implemented = True # Change to True to view in the GUI min_range = 5 ","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/:3:1","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":[],"content":"Problem 5 (3 pt) Implement the FireAnt, which does damage when it receives damage. Specifically, if it is damaged by amount health units, it does a damage of amount to all bees in its place (this is called reflected damage). If it dies, it does an additional amount of damage, as specified by its damage attribute, which has a default value of 3 as defined in the FireAnt class. To implement this, override FireAnt’s reduce_health method. Your overriden method should call the reduce_health method inherited from the superclass (Ant) to reduce the current FireAnt instance’s health. Calling the inherited reduce_health method on a FireAnt instance reduces the insect’s health by the given amount and removes the insect from its place if its health reaches zero or lower. 这个 FireAnt 有点意思的, 当他收到伤害的时候会反弹自己受到的伤害到当前格子所有的蜜蜂上, 同时如果它因此死了还能对这些蜜蜂再一次造成伤害(这一次取决于自己的攻击力) 这个比较 tricky 的地方是: 当前格子的所有蜜蜂是一个 list, 也就是我们可能要在迭代访问 list 的时候这个这个 list, ==这个我们遍历它的拷贝即可== 我们不能做直接调用这个 FireAnt 的 reduce_health 方法, 不然万一它死了这个对象就不存在了, 我们还如何得知它的攻击力 ? 最后代码如下: class FireAnt(Ant): \"\"\"FireAnt cooks any Bee in its Place when it expires.\"\"\" name = 'Fire' damage = 3 food_cost = 5 implemented = True # Change to True to view in the GUI def __init__(self, health=3): \"\"\"Create an Ant with a HEALTH quantity.\"\"\" super().__init__(health) def reduce_health(self, amount): \"\"\"Reduce health by AMOUNT, and remove the FireAnt from its place if it has no health remaining. Make sure to reduce the health of each bee in the current place, and apply the additional damage if the fire ant dies. \"\"\" # FireAnt attack bees for bee in self.place.bees[:]: bee.reduce_health(amount) # FireAnt will be dead if self.health \u003c= amount: for bee in self.place.bees[:]: bee.reduce_health(self.damage) super().reduce_health(amount) else: super().reduce_health(amount) ","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/:3:2","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":[],"content":"Phase 3: More Ants! ","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/:4:0","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":[],"content":"Problem 6 (1 pt) We are going to add some protection to our glorious home base by implementing the WallAnt, an ant that does nothing each turn. A WallAnt is useful because it has a large health value. Unlike with previous ants, we have not provided you with a class header. Implement the WallAnt class from scratch. Give it a class attribute name with the value 'Wall' (so that the graphics work) and a class attributeimplemented with the value True (so that you can use it in a game). 从零实现一个 WallAnt, 这种蚂蚁生命值高, 其他倒是没什么 class WallAnt(Ant): \"\"\"WallAnt has a large health value\"\"\" name = 'Wall' damage = 0 food_cost = 4 implemented = True def __init__(self, health=4): super().__init__(health) ","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/:4:1","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":[],"content":"Problem 7 (3 pt) Implement the HungryAnt, which will select a random Bee from its place and eat it whole. After eating a Bee, a HungryAnt must spend 3 turns chewing before eating again. If there is no bee available to eat, HungryAnt will do nothing. Give HungryAnt a chew_duration class attribute that stores the number of turns that it will take a HungryAnt to chew (set to 3). Also, give each HungryAnt an instance attribute chew_countdown that counts the number of turns it has left to chew (initialized to 0, since it hasn’t eaten anything at the beginning. You can also think of chew_countdown as the number of turns until a HungryAnt can eat another Bee). Implement the action method of the HungryAnt: First, check if it is chewing; if so, decrement its chew_countdown. Otherwise, eat a random Bee in its place by reducing the Bee’s health to 0. Make sure to set the chew_countdownwhen a Bee is eaten! 从零实现一个 HungryAnt, 可以随机吞下一整只蜜蜂!!!!但是它要花费 chew_duration 来咀嚼才能进行下一次攻击. 这个不就是植物大战僵尸里面的食人花嘛!!! 我们只要判断当前它是否处于咀嚼状态即可. 这里题目是有挖坑的, 测试样例里面可能在运行的时候会修改 chew_duration 的值, 注意别被坑了! class HungryAnt(Ant): \"\"\"HungryAnt will select a random bee from its place and eat it whole\"\"\" name = 'Hungry' damage = 0 food_cost = 4 implemented = True chew_duration = 3 def __init__(self, health=1): super().__init__(health) self.chew_countdown = 0 def action(self, gamestate): # it is chewing if self.chew_countdown != 0: self.chew_countdown -= 1 # it is not chewing else: if len(self.place.bees) \u003e 0: # WARNING: the test cases may change the chew_duration variable in runtime self.chew_countdown = self.chew_duration bee = random_bee(self.place.bees) bee.reduce_health(bee.health) ","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/:4:2","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":[],"content":"Problem 8 (3 pt) A BodyguardAnt differs from a normal ant because it is a ContainerAnt; it can contain another ant and protect it, all in one Place. When a Bee stings the ant in a Place where one ant contains another, only the container is damaged. The ant inside the container can still perform its original action. If the container perishes, the contained ant still remains in the place (and can then be damaged). Each ContainerAnt has an instance attribute ant_contained that stores the ant it contains. This ant, ant_contained, initially starts off as None to indicate that there is no ant being stored yet. Implement the store_ant method so that it sets the ContainerAnt’s ant_contained instance attribute to the passed in antargument. Also implement the ContainerAnt’s action method to perform its ant_contained’s action if it is currently containing an ant. 这里要实现的蚂蚁也很有意思, 它可以把其他蚂蚁保护起来. 甚至可以和被保护的蚂蚁一起呆在同一个格子里面. 这里注意几个细节: BodyguardAnt 不能保护 BodyguardAnt !(🈲️止套娃) 当 BodyguardAnt 和被保护的蚂蚁在同一个格子的时候, 要让 place.ant 始终指向 BodyguardAnt 这里其实还涉及到挺多要改的地方的(可能会漏放某些代码, 完整的建议看我的仓库) class Ant(Insect): \"\"\"An Ant occupies a place and does work for the colony.\"\"\" implemented = False # Only implemented Ant classes should be instantiated food_cost = 0 is_container = False ... def add_to(self, place): if place.ant is None: place.ant = self else: assert ( (place.ant is None) or self.can_contain(place.ant) or place.ant.can_contain(self) ), 'Two ants in {0}'.format(place) if place.ant.is_container and place.ant.can_contain(self): place.ant.store_ant(self) elif self.is_container and self.can_contain(place.ant): self.store_ant(place.ant) # the place.ant should refer to the container ant place.ant = self Insect.add_to(self, place) class ContainerAnt(Ant): \"\"\" ContainerAnt can share a space with other ants by containing them. \"\"\" is_container = True def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.ant_contained = None def can_contain(self, other): # we can't have two BodyguardAnt in the same place if self.ant_contained is None and not other.is_container: return True def store_ant(self, ant): self.ant_contained = ant def remove_ant(self, ant): if self.ant_contained is not ant: assert False, \"{} does not contain {}\".format(self, ant) self.ant_contained = None def remove_from(self, place): # Special handling for container ants (this is optional) if place.ant is self: # Container was removed. Contained ant should remain in the game place.ant = place.ant.ant_contained Insect.remove_from(self, place) else: # default to normal behavior Ant.remove_from(self, place) def action(self, gamestate): if self.ant_contained is not None: return self.ant_contained.action(gamestate) class BodyguardAnt(ContainerAnt): \"\"\"BodyguardAnt provides protection to other Ants.\"\"\" name = 'Bodyguard' food_cost = 4 implemented = True # Change to True to view in the GUI def __init__(self, health=2): super().__init__(health) ","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/:4:3","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":[],"content":"Problem 9 (1 pt) The BodyguardAnt provides great defense, but they say the best defense is a good offense. The TankAnt is a container that protects an ant in its place and also deals 1 damage to all bees in its place each turn. We have not provided you with a class header. Implement the TankAnt class from scratch. Give it a class attribute name with the value 'Tank' (so that the graphics work) and a class attribute implemented with the value True (so that you can use it in a game). You should not need to modify any code outside of the TankAnt class. If you find yourself needing to make changes elsewhere, look for a way to write your code for the previous question such that it applies not just to BodyguardAnt and TankAnt objects, but to container ants in general. 根据题目的描述可以知道 TankAnt 是一种特殊的 ContainerAnt, 我们要从零实现它的功能, 它的攻击方式比较特殊, 是自己保护的蚂蚁的攻击方式 + 对当前格子的蜜蜂造成自己攻击力的伤害 class TankAnt(ContainerAnt): name = 'Tank' damage = 1 food_cost = 6 implemented = True def __init__(self, health=2): super().__init__(health) def action(self, gamestate): if self.ant_contained is not None: self.ant_contained.action(gamestate) # 1 damage for all the bees for bee in self.place.bees[:]: bee.reduce_health(self.damage) ","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/:4:4","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":[],"content":"Phase 4: Water and Might ","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/:5:0","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":[],"content":"Problem 10 (1 pt) Let’s add water to the colony! Currently there are only two types of places, the Hive and a basic Place. To make things more interesting, we’re going to create a new type of Place called Water. Only an insect that is waterproof can be placed in Water. In order to determine whether an Insect is waterproof, add a new class attribute to the Insect class named is_waterproof that is set to False. Since bees can fly, set their is_waterproof attribute to True, overriding the inherited value. Now, implement the add_insect method for Water. First, add the insect to the place regardless of whether it is waterproof. Then, if the insect is not waterproof, reduce the insect’s health to 0. Do not repeat code from elsewhere in the program. Instead, use methods that have already been defined. 为了让地形更有趣, 我们要增加一种地形 - Water, 只有能在水里的活动的生物才能被放在这种地形中(蜜蜂会飞当然都可以, 蚂蚁目前还没有) 记得还要修改很多类, 增加类属性 is_waterproof, 下面我就放 Water 类的代码 class Water(Place): \"\"\"Water is a place that can only hold waterproof insects.\"\"\" def add_insect(self, insect): \"\"\"Add an Insect to this place. If the insect is not waterproof, reduce its health to 0.\"\"\" super().add_insect(insect) if not insect.is_waterproof: insect.reduce_health(insect.health) ","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/:5:1","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":[],"content":"Problem 11 (1 pt) Currently there are no ants that can be placed on Water. Implement the ScubaThrower, which is a subclass of ThrowerAnt that is more costly and waterproof, but otherwise identical to its base class. A ScubaThrower should not lose its health when placed in Water. We have not provided you with a class header. Implement the ScubaThrower class from scratch. Give it a class attribute name with the value 'Scuba' (so that the graphics work) and remember to set the class attributeimplemented with the value True (so that you can use it in a game). 从零实现一个 ScubaThrower, 听名字可以看出来应该是一种特殊的 ThrowerAnt. 特殊在: 能放在 Water 里 class ScubaThrower(ThrowerAnt): name = 'Scuba' food_cost = 6 is_waterproof = True implemented = True def __init__(self, health=1): super().__init__(health) ","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/:5:2","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":[],"content":"Problem 12 (3 pt) Finally, implement the QueenAnt. The queen is a waterproof ScubaThrower that inspires her fellow ants through her bravery. In addition to the standard ScubaThrower action, the QueenAnt doubles the damage of all the ants behind her each time she performs an action. Once an ant’s damage has been doubled, it is not doubled again for subsequent turns. However, with great power comes great responsibility. The QueenAnt is governed by three special rules: If the queen ever has its health reduced to 0, the ants lose. You will need to override Ant.reduce_health in QueenAnt and call ants_lose() in that case in order to signal to the simulator that the game is over. (The ants also still lose if any bee reaches the end of a tunnel.) There can be only one queen. A second queen cannot be constructed. To check if an Ant can be constructed, we use the Ant.construct() class method to either construct an Ant if possible, or return None if not. You will need to override Ant.construct as a class method of QueenAnt in order to add this check. To keep track of whether a queen has already been created, you can use an instance variable added to the current GameState. The queen cannot be removed. Attempts to remove the queen should have no effect (but should not cause an error). You will need to override Ant.remove_from in QueenAnt to enforce this condition. 终于来到了最后一题(除了额外的题目以外), 我们要实现一个女王蚁🐜. 它有以下几个特性: 可以在水中行走 思路: 题目也说了它是一种 ScrubaThrower, 根据这个描述其实就抽象概括出了它是 ScrubaThrower 的子类. 它在行动后会把在它后面的蚂蚁们的攻击力都翻倍, 但是不可以多次翻倍 思路: 如何表示 “在后面” 这个关系 ? 根据前面的题目我们可以知道. 右边为正方向, 所以 “在后面” 实际上就是在左边, 我们可以通过访问 Place 的 .exit 方法不断获取到它左边(后面的)的 思路: 如何表示不能多次翻倍 ? 很容易想到, 我们需要通过设置一个标记来表示当前的蚂蚁是否已经攻击力翻倍过, 所以我们直接在 Ant 类里加一个实例变量即可 思路: 这里还要注意如何处理 GuardAnt, 因为实际上它守护的蚂蚁是可能被替换为新的蚂蚁, 此时我们就要让这个新的被守护的蚂蚁的攻击力翻倍. ==注意细细体会这里代码是怎么写的== 只能有一个女王蚁🐜 思路: 如何做到即使我们多次调用女王蚁🐜的构造函数也不会有多的女王蚁🐜 ? 这个依赖于一个游戏变量叫做 gamestate, 我们仍然是通过加标记的方式, 只不过这次我们是在 GameState 这个类里加一个 has_queen 表示当前是否已经有女王蚁🐜 女王蚁🐜不能被移除 思路: 这个简单, 我们什么都不做就行了 最后代码大概如下(结合上面的解释细细体会~~) class QueenAnt(ScubaThrower): \"\"\"The Queen of the colony. The game is over if a bee enters her place.\"\"\" name = 'Queen' food_cost = 7 implemented = True # Change to True to view in the GUI @classmethod def construct(cls, gamestate): \"\"\" Returns a new instance of the Ant class if it is possible to construct, or returns None otherwise. Remember to call the construct() method of the superclass! \"\"\" if cls.food_cost \u003e gamestate.food: print('Not enough food remains to place ' + cls.__name__) return # I add a class variable to indict if we have created a QueenAnt() if not gamestate.has_queen: gamestate.has_queen = True return super().construct(gamestate) else: return None def action(self, gamestate): \"\"\"A queen ant throws a leaf, but also doubles the damage of ants in her tunnel. \"\"\" super().action(gamestate) pos = self.place.exit while pos: if pos.ant is not None: if not pos.ant.is_doubled: pos.ant.is_doubled = True pos.ant.buff() if pos.ant.is_container and pos.ant.ant_contained is not None: # the pos.ant.ant_contained may change if not pos.ant.ant_contained.is_doubled: pos.ant.ant_contained.buff() pos.ant.ant_contained.is_doubled = True pos = pos.exit def reduce_health(self, amount): \"\"\"Reduce health by AMOUNT, and if the QueenAnt has no health remaining, signal the end of the game. \"\"\" if self.health \u003c= amount: ants_lose() def remove_from(self, place): return None ","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/:5:3","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":[],"content":"Extra Credit (2 pt) Implement two final thrower ants that do zero damage, but instead apply a temporary “status” on the actionmethod of a Bee instance that they throw_at. This “status” lasts for a certain number of turns, after which it ceases to take effect. We will be implementing two new ants that inherit from ThrowerAnt. SlowThrower throws sticky syrup at a bee, slowing it for 3 turns. When a bee is slowed, it can only move on turns when gamestate.time is even, and can do nothing otherwise. If a bee is hit by syrup while it is already slowed, it is slowed for an additional 3 turns. ScaryThrower intimidates a nearby bee, causing it to back away instead of advancing. (If the bee is already right next to the Hive and cannot go back further, it should not move. To check if a bee is next to the Hive, you might find the is_hive instance attribute of Places useful). Bees remain scared until they have tried to back away twice. Bees cannot try to back away if they are slowed and gamestate.time is odd. Once a bee has been scared once, it can’t be scared ever again. 实现两种特殊的蚂蚁类, 本身没有伤害, 但是能给蜜蜂加上 debuff. SlowThrower 可以让蜜蜂减速, 让他们只能在当前时间为偶数的时候前进否则什么事情也干不了. 这个效果可以维持三个回合, 但是这个 debuff 可以无限叠加 ScaryThrower 会让蜜蜂后退, 注意如果不能再后退的话, 就要保持不动. 该效果维持两回合. 但是如果被减速就会继续保持不动, 这个 debuff 只能上一次 这一题, 真的, 难度完全是上来了. 我调了挺久的 bug 才成功. 下面我来讲一下设计思路: SlowThrower 设置 is_slow 变量表示当前的蜜蜂是否被减速, 同时设置 slow_turns 来记住剩余几回合可以解除这个状态 每个回合, 如果当前的蜜蜂被减速了, 它只能看当前的游戏时间是否为偶数, 如果是的话就可以前进, 否则在原地不动, **但不论你动不动, slow_turns -= 1 永远都成立 ScaryThrower 类似 is_slow 和 slow_turns 设置了 is_scared 和 scared_turns 我们暂时先不考虑当前蜜蜂是否被减速了(这样思考问题会比较简单). 显然, 我们每回合要做的事情是让 scared_turns -= 1, 然后是否为 scared 其实决定着蜜蜂的前进方向. 有了这个基础之后我们再来思考被减速带情况下又该如何, 显然我们前面这样是有问题的, 题目说了如果被减速会原地保持不动, 但是我们却让 scared_turns -= 1, 所以我们需要多加一个判断, 也就是被减速 + 被 scared 的情况下如果我们没有成功移动, 那么我们需要撤销我们对 scared_turns 的更改 知道了上面的设计思路, 理解下面的代码就不难了(这里删去了无关的代码): class Bee(Insect): \"\"\"A Bee moves from place to place, following exits and stinging ants.\"\"\" name = 'Bee' damage = 1 is_waterproof = True # 2 flags is_slow = False is_scared = False # turns remained slow_turns = 0 scared_turns = 0 # we can't scare a bee twice has_been_scared = False def action(self, gamestate): \"\"\"A Bee's action stings the Ant that blocks its exit if it is blocked, or moves to the exit of its current place otherwise. gamestate -- The GameState, used to access game state information. \"\"\" if self.is_scared: destination = self.place.entrance self.scared_turns -= 1 else: destination = self.place.exit if self.is_slow: self.slow_turns -= 1 if self.slow_turns == 0: self.is_slow = False if gamestate.time % 2 == 0 and self.health \u003e 0 and destination is not None: self.move_to(destination) else: # is_slow + is_scared, we need to cancel `self.scared_turns -= 1` \\ # if we didn't move self.scared_turns += 1 else: if self.blocked(): self.sting(self.place.ant) elif self.health \u003e 0 and destination is not None: self.move_to(destination) # we can't put this in side `if self.is_scared`, why? # because only when we run if self.is_slow we can know # should we cancel it or not if self.scared_turns == 0: self.is_scared = False # Extra credit: Special handling for bee direction def slow(self, length): \"\"\"Slow the bee for a further LENGTH turns.\"\"\" self.is_slow = True self.slow_turns += length def scare(self, length): \"\"\" If this Bee has not been scared before, cause it to attempt to go backwards LENGTH times. \"\"\" # a bee can't be scared twice if self.has_been_scared: return else: self.is_scared = True self.scared_turns += length self.has_been_scared = True ","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/:5:4","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":[],"content":"Optional Problems ","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/:6:0","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":[],"content":"Optional Problem 1 Implement the NinjaAnt, which damages all Bees that pass by, but can never be stung. A NinjaAnt does not block the path of a Bee that flies by. To implement this behavior, first modify the Ant class to include a new class attribute blocks_path that is set to True, then override the value of blocks_path to Falsein the NinjaAnt class. Second, modify the Bee’s method blocked to return False if either there is no Ant in the Bee’s place or if there is an Ant, but its blocks_path attribute is False. Now Bees will just fly past NinjaAnts. Finally, we want to make the NinjaAnt damage all Bees that fly past. Implement the action method in NinjaAntto reduce the health of all Bees in the same place as the NinjaAnt by its damage attribute. Similar to the FireAnt, you must iterate over a potentially changing list of bees. 忍者蚁🥷🐜哈哈哈哈, 注意几个细节: 无法被蜜蜂攻击 不会堵住蜜蜂的路, 但是会对经过的蜜蜂造成伤害 这个问题比较简单, 解法也几乎都写在了问题描述里面 class Bee(Insect): \"\"\"A Bee moves from place to place, following exits and stinging ants.\"\"\" def blocked(self): \"\"\"Return True if this Bee cannot advance to the next Place.\"\"\" if self.place.ant is None: return False if not self.place.ant.blocks_path: return False return True class NinjaAnt(Ant): \"\"\"NinjaAnt does not block the path and damages all bees in its place. This class is optional. \"\"\" name = 'Ninja' damage = 1 food_cost = 5 blocks_path = False implemented = True # Change to True to view in the GUI def action(self, gamestate): for bee in self.place.bees[:]: bee.reduce_health(self.damage) ","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/:6:1","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":[],"content":"Optional Problem 2 The LaserAnt shoots out a powerful laser, damaging all that dare to stand in its path. Both Bees and Ants, of all types, are at risk of being damaged by LaserAnt. When a LaserAnt takes its action, it will damage all Insects in its place (excluding itself, but including its container if it has one) and the Places in front of it, excluding the Hive. If that were it, LaserAnt would be too powerful for us to contain. The LaserAnt has a base damage of 2. But, LaserAnt’s laser comes with some quirks. The laser is weakened by 0.25 each place it travels away fromLaserAnt’s place. Additionally, LaserAnt has limited battery. Each time LaserAnt actually damages an Insect its laser’s total damage goes down by 0.0625 (1/16). If LaserAnt’s damage becomes negative due to these restrictions, it simply does 0 damage instead. 激光🐜, 注意几个特性: 伤害自己格子所在的所有生物, 甚至包括整条路径上的所有生物 但是每次对其他生物造成伤害的时候伤害会衰减, 每次减去 0.0625 激光的威力跟它离激光蚁🐜的距离也有关系, 距离每多一个格子, 就会减去 0.25 只要处理好两个函数即可 calculate_damage : 这个要注意的地方是, 如果算出来的伤害 \u003c 0, 那么你就需要返回 0 insects_in_front : 这个要返回一个 dict 表示每个生物距离激光🐜的距离. 我这了是分成当前格子和剩下的格子这样来处理, 一边遍历所有格子一边计算距离和把生物加到我们的 dict里. class LaserAnt(ThrowerAnt): name = 'Laser' food_cost = 10 implemented = True # Change to True to view in the GUI damage = 2 def __init__(self, health=1): super().__init__(health) self.insects_shot = 0 self.current_damage = LaserAnt.damage def insects_in_front(self): \"\"\"Return a dict contains every Insect\"\"\" dis = {} for bee in self.place.bees: dis[bee] = 0 # take care of the ContainerAnt if self.place.ant is not self: dis[self.place.ant] = 0 pos = self.place.entrance distance = 1 while pos.entrance is not None: if not pos.is_hive: for bee in pos.bees: dis[bee] = distance if pos.ant is not None: dis[pos.ant] = distance # take care of the ContainerAnt if pos.ant.is_container and pos.ant.ant_contained is not None: dis[pos.ant.ant_contained] = distance distance += 1 pos = pos.entrance return dis def calculate_damage(self, distance): damage_result = self.damage - 0.0625 * self.insects_shot - 0.25 * distance return damage_result if damage_result \u003e 0 else 0 def action(self, gamestate): insects_and_distances = self.insects_in_front() for insect, distance in insects_and_distances.items(): damage = self.calculate_damage(distance) insect.reduce_health(damage) if damage: self.insects_shot += 1 ","date":"2022-03-10","objectID":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/:6:2","tags":["Course"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/zh-cn/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Tool"],"content":"Explain how to use hammerspoon to manage windows","date":"2022-01-21","objectID":"/zh-cn/how-to-manage-windows-using-hammerspoon/","tags":["Tool"],"title":"How to Manage Windows Using Hammerspoon","uri":"/zh-cn/how-to-manage-windows-using-hammerspoon/"},{"categories":["Tool"],"content":"引言 虽然 macOS 自带窗口管理这个功能, 但是实际上是用下来发现还是很难受的. 功能不足以满足自己的需求. 所以我常常发现自己在用鼠标拖动窗口和重新调整窗口大小. 长此以往, 我觉得这样效率实在太低, 恰好前阵子在看 MIT-Missing-Semester 的课, 里面提到了 hammerspoon 这个工具. 我去稍微了解了一下发现这工具真的不错. ","date":"2022-01-21","objectID":"/zh-cn/how-to-manage-windows-using-hammerspoon/:1:0","tags":["Tool"],"title":"How to Manage Windows Using Hammerspoon","uri":"/zh-cn/how-to-manage-windows-using-hammerspoon/"},{"categories":["Tool"],"content":"什么是 hammerspoon ? 根据官方文档介绍, hammerspoon 是 macOS 上一个用于自动化的工具, 充当了 Lua 语言和操作系统的系统调用之间的桥梁. 也就是说我们可以使用 Lua 语言和 hammerspoon 提供的 API 来来完成很多自动化操作. 目前我还只看了窗口管理相关的. 因为要用到 Lua 语言, 但是我又根本没有接触过这个语言, 所以我大概跟着 Learn Lua in Y minutes 稍微学习了一下. ","date":"2022-01-21","objectID":"/zh-cn/how-to-manage-windows-using-hammerspoon/:2:0","tags":["Tool"],"title":"How to Manage Windows Using Hammerspoon","uri":"/zh-cn/how-to-manage-windows-using-hammerspoon/"},{"categories":["Tool"],"content":"怎么管理窗口? 我主要想要有下面的几个功能 可以把窗口移动到屏幕的左边或者是右边(1 / 2 屏幕) 可以把窗口弄成全屏的 可以把窗口移动到左上角/右上角/左下角/右下角(1 / 4 屏幕) 把当前的窗口移动到屏幕中央 我的方案主要是写了三个 *.lua file(我放在了我的 github 仓库 dotfiles 里) 👉config.lua MACBOOK_MONITOR = 'Built-in Retina Display' -- disable animations, default value = 0.2 hs.window.animationDuration = 0 👉init.lua require('config') require('window') 👉window.lua 这个是主要的代码 -- half of screen -- {frame.x, frame.y, window.w, window.h} -- First two elements: we decide the position of frame -- Last two elements: we decide the size of frame hs.hotkey.bind({'alt', 'cmd'}, 'left', function() hs.window.focusedWindow():moveToUnit({0, 0, 0.5, 1}) end) hs.hotkey.bind({'alt', 'cmd'}, 'right', function() hs.window.focusedWindow():moveToUnit({0.5, 0, 0.5, 1}) end) hs.hotkey.bind({'alt', 'cmd'}, 'up', function() hs.window.focusedWindow():moveToUnit({0, 0, 1, 0.5}) end) hs.hotkey.bind({'alt', 'cmd'}, 'down', function() hs.window.focusedWindow():moveToUnit({0, 0.5, 1, 0.5}) end) -- quarter of screen --[[ u i j k --]] hs.hotkey.bind({'ctrl', 'alt', 'cmd'}, 'u', function() hs.window.focusedWindow():moveToUnit({0, 0, 0.5, 0.5}) end) hs.hotkey.bind({'ctrl', 'alt', 'cmd'}, 'k', function() hs.window.focusedWindow():moveToUnit({0.5, 0.5, 0.5, 0.5}) end) hs.hotkey.bind({'ctrl', 'alt', 'cmd'}, 'i', function() hs.window.focusedWindow():moveToUnit({0.5, 0, 0.5, 0.5}) end) hs.hotkey.bind({'ctrl', 'alt', 'cmd'}, 'j', function() hs.window.focusedWindow():moveToUnit({0, 0.5, 0.5, 0.5}) end) -- full screen hs.hotkey.bind({'alt', 'cmd'}, 'f', function() hs.window.focusedWindow():moveToUnit({0, 0, 1, 1}) end) -- center screen hs.hotkey.bind({'alt', 'cmd'}, 'c', function() hs.window.focusedWindow():centerOnScreen() end) 你应该把上面三个文件放在 ~/.hammerspoon/ 这个路径下然后在 hammerspoon 里面点击 Reload config 就可以正常使用了🤗 ","date":"2022-01-21","objectID":"/zh-cn/how-to-manage-windows-using-hammerspoon/:3:0","tags":["Tool"],"title":"How to Manage Windows Using Hammerspoon","uri":"/zh-cn/how-to-manage-windows-using-hammerspoon/"},{"categories":["Tool"],"content":"代码解释 hs.hotkey.bind(mods, key, pressedfn) 这个主要是把按键 mods 和 key 绑定到 pressedfn 这个函数上. 在使用的时候先按下 mods 对应的按键组合并保持, 然后再按下 key 对应的按键. 比如我们要让窗口全屏, 我们首先按下并保持 alt(option) 和 cmd, 再按下 f. 就可以让窗口全屏了 pressedfn 这个就是用 Lua 语言写的一个函数 函数的关键在于 hs.window.focusedWindow():moveToUnit({...}) 这个方法. 他的主要功能是获得当前被激活的窗口然后做一些位置和大小上的修改. 参数是 Lua 语言里的 table, 我已经把参数的具体含义写在了注释里, 可以结合下面我画的图来进行理解. ","date":"2022-01-21","objectID":"/zh-cn/how-to-manage-windows-using-hammerspoon/:4:0","tags":["Tool"],"title":"How to Manage Windows Using Hammerspoon","uri":"/zh-cn/how-to-manage-windows-using-hammerspoon/"},{"categories":["Tool"],"content":"参考 Anish’s Hammerspoon config ","date":"2022-01-21","objectID":"/zh-cn/how-to-manage-windows-using-hammerspoon/:5:0","tags":["Tool"],"title":"How to Manage Windows Using Hammerspoon","uri":"/zh-cn/how-to-manage-windows-using-hammerspoon/"},{"categories":["Mac"],"content":"简单介绍怎么用 homebrew 安装本地安装包","date":"2022-01-04","objectID":"/zh-cn/how-to-use-local-file-in-homebrew/","tags":["Mac","Homebrew"],"title":"怎么在 homebrew 里面安装本地安装包","uri":"/zh-cn/how-to-use-local-file-in-homebrew/"},{"categories":["Mac"],"content":"引言 最近想要在 homebrew 上面下载 qbittorent, 发现我即使用的是中科大的源也下载不下来, 终端显示如下内容⬇️ ==\u003e Downloading https://downloads.sourceforge.net/qbittorrent/qbittorrent-mac/qbittorrent-4.3.9/qbittorrent-4.3.9.dmg curl: (35) error:06FFF089:digital envelope routines:CRYPTO_internal:bad key length=# # # Error: Download failed on Cask 'qbittorrent' with message: Download failed: https://downloads.sourceforge.net/qbittorrent/qbittorrent-mac/qbittorrent-4.3.9/qbittorrent-4.3.9.dmg 此时我就想到要不干脆把这个文件下载下来, 然后用 homebrew 本地安装(应该是有这个功能的), 做了一番检索之后, 终于知道要怎么弄了, 下面我将以 qbittorrent-4.3.9.dmg 为例 ","date":"2022-01-04","objectID":"/zh-cn/how-to-use-local-file-in-homebrew/:1:0","tags":["Mac","Homebrew"],"title":"怎么在 homebrew 里面安装本地安装包","uri":"/zh-cn/how-to-use-local-file-in-homebrew/"},{"categories":["Mac"],"content":"Step 1. 获取路径文件名 可以先运行 brew --cache 查看 homebrew 的缓存路径, 一般来说应该是在 ~/Library/Caches/Homebrew 下. homebrew 会把安装包下载到里面的 downloads 文件夹里面, 也就是在 ~/Library/Caches/Homebrew/downloads 下, 进入这个文件夹可以发现里面的文件名的格式都是 \u003curl-hash\u003e--\u003cformula\u003e-\u003cversion\u003e, 显然, 我们也要把我们的安装包弄成这种格式放在里面. 📒 使用 brew --cache -s \u003cformula\u003e 来获取对应的路径文件名 对应我们这篇文章的例子就是 brew --cache -s qbittorrent, 可以看到输出内容是 /Users/\u003c对应你的用户名\u003e/Library/Caches/Homebrew/downloads/7ee479ba2a19cf904e4c415805a6adaead76e7c191d595c016c86b72044c22fa--qbittorrent-4.3.9.dmg ","date":"2022-01-04","objectID":"/zh-cn/how-to-use-local-file-in-homebrew/:2:0","tags":["Mac","Homebrew"],"title":"怎么在 homebrew 里面安装本地安装包","uri":"/zh-cn/how-to-use-local-file-in-homebrew/"},{"categories":["Mac"],"content":"Step 2. 移动本地安装包到对应的目录下 在 Step 1. 中我们已经可以知道该把文件放到什么地方, 接下来要做的无非就是移动文件可以, 如果打开文件浏览器移动那就慢了, 直接在命令行输入对应命令即可 📒 使用 mv \u003clocal-file\u003e \"$(brew --cache -s \u003cformula\u003e)\" 移动本地安装包到对应目录下 对应我们的例子就是 mv qbittorrent-4.3.9.dmg \"$(brew --cache -s qbittorrent)\" ","date":"2022-01-04","objectID":"/zh-cn/how-to-use-local-file-in-homebrew/:3:0","tags":["Mac","Homebrew"],"title":"怎么在 homebrew 里面安装本地安装包","uri":"/zh-cn/how-to-use-local-file-in-homebrew/"},{"categories":["Mac"],"content":"Step 3. 再次运行 brew install 此时再次运行 brew install qbittorrent 即可, 可以看到命令行找到了缓存文件🤗, 而且安装成功了 📒 再次运行 brew install \u003cformula\u003e ==\u003e Downloading https://downloads.sourceforge.net/qbittorrent/qbittorrent-mac/qbittorrent-4.3.9/qbittorrent-4.3.9.dmg Already downloaded: /Users/\u003c对应你的用户名\u003e/Library/Caches/Homebrew/downloads/7ee479ba2a19cf904e4c415805a6adaead76e7c191d595c016c86b72044c22fa--qbittorrent-4.3.9.dmg ==\u003e Installing Cask qbittorrent ==\u003e Moving App 'qbittorrent.app' to '/Applications/qBittorrent.app' 🍺 qbittorrent was successfully installed! ","date":"2022-01-04","objectID":"/zh-cn/how-to-use-local-file-in-homebrew/:4:0","tags":["Mac","Homebrew"],"title":"怎么在 homebrew 里面安装本地安装包","uri":"/zh-cn/how-to-use-local-file-in-homebrew/"},{"categories":["Mac"],"content":"参考 homebrew 文档 ","date":"2022-01-04","objectID":"/zh-cn/how-to-use-local-file-in-homebrew/:5:0","tags":["Mac","Homebrew"],"title":"怎么在 homebrew 里面安装本地安装包","uri":"/zh-cn/how-to-use-local-file-in-homebrew/"},{"categories":["Python"],"content":"简单介绍了用 ipdb 对 Python 文件进行 debug","date":"2021-12-28","objectID":"/zh-cn/how-to-debug-in-python/","tags":["Debug","Python"],"title":"怎么 debug 一个 Python 文件","uri":"/zh-cn/how-to-debug-in-python/"},{"categories":["Python"],"content":"引言 很长一段时间内我写代码都是用最简单的 debug 方法, 手动在程序里面插入 print 代码来看具体的变量的值, 然后自己推断程序到底是在哪里出问题. 根据 print 的结果可能还要到别的地方重复这个步骤. debug 完之后还得去把这些 print 语句注释掉. 这个就是我以前的日常 debug 流程. 最近在看 MIT.Missing semester 的课讲到 debug, 顿时感到应该系统学习一下在 Python 里面如何 debug, 虽然用 print 也凑合, 学完之后只恨自己没有早点了解😢 ","date":"2021-12-28","objectID":"/zh-cn/how-to-debug-in-python/:1:0","tags":["Debug","Python"],"title":"怎么 debug 一个 Python 文件","uri":"/zh-cn/how-to-debug-in-python/"},{"categories":["Python"],"content":"快速上手 安装 虽然 Python 有自带的 pdb, 但是 ipdb 的跟它大差不差, 还带颜色输出, 当然用这个了(其实就跟你在命令行要用 python 还是 ipython 一样, 我肯定是选择 UI 比较好看的 ipython) \u003e pip install ipdb 开始 debug 直接在命令行输入以下内容即可, 其中 \u003cfilename\u003e 表示你要 debug 的文件 \u003e python -m ipdb \u003cfilename\u003e ","date":"2021-12-28","objectID":"/zh-cn/how-to-debug-in-python/:2:0","tags":["Debug","Python"],"title":"怎么 debug 一个 Python 文件","uri":"/zh-cn/how-to-debug-in-python/"},{"categories":["Python"],"content":"ipdb 中的命令 [ ] 表示是可选参数, 如果没有 [ ] 表示一定要给这个参数 ( ) 表示里面的可以不写, 简写命令 ","date":"2021-12-28","objectID":"/zh-cn/how-to-debug-in-python/:3:0","tags":["Debug","Python"],"title":"怎么 debug 一个 Python 文件","uri":"/zh-cn/how-to-debug-in-python/"},{"categories":["Python"],"content":"控制程序运行 l(ist) - 展示当前行附近的行, 具体来说是附近的 11 行, 但是记这个具体的数字好像也没啥意义 也可以使用 ll 命令, 会展示当前所在函数或者是堆栈帧的源代码 可以传入参数, 比如要看 1 到 12 行的内容可以用 l 1,12 s(tep) - 单步执行下一步, 如果是函数调用语句, 会进到函数里一步步执行 n(ext) - 单步执行下一步, 如果是函数调用语句, 不会进去函数里一步步执行, 它会一直运行到函返回结果 c(ontinue) - 继续执行, 直到程序发生错误或者正常退出 如果程序是正常退出的, 那么就会输出 The program finished and will be restarted q(uit) - 退出程序执行 r(eturn) - 继续运行到当前函数返回结果为止 w(here) - 打印 stack trace, 看调用轨迹, 从上到下分别是从最内层到最外层的调用入口 然后你可以根据这个调用栈, 用 d(own) [count] 和 u(up) [count] 来在不同的层次间移动 ","date":"2021-12-28","objectID":"/zh-cn/how-to-debug-in-python/:3:1","tags":["Debug","Python"],"title":"怎么 debug 一个 Python 文件","uri":"/zh-cn/how-to-debug-in-python/"},{"categories":["Python"],"content":"程序断点专题 每次设置程序断点的时候都会输出你当前这个程序断点的序号, 默认从 1 开始, 也就是后面提到的 breakpoint count] b(reak) [line_number] - 在 line_number 设置 breakpoint 不提供参数的话就是查看我们设置的所有程序断点 ⭐ 高级用法, 你还可以指定文件! 比如你想停在 util.py 文件的第 10 行, 你可以用 b util:10 ⭐ 高级用法, 你在指定文件的同时, 可以指定函数, 还是刚才那个例子, 比如 util.py 文件里面有个 get_result 函数, 你可以用 b util.get_result ⭐ 高级用法: 你还可以指定满足某些条件才会设置程序断点, 用法如下: b ..., condition tbreak [line_number] - 暂时的程序断点, 第一次命中之后就会自己取消 disable [breakpoint count] - 暂时不用这个程序断点, 和 clear 不同, 你后面可以通过 enable 重新激活这个程序断点 enable [breakpoint count] - 激活程序断点 cl(ear) [breakpoint count | line_number] - 通过程序断点的序号或者是对应的行来清除程序断点 unt(il) [line_number] - 运行大于等于 line_number 的地方 当然你也可以不提供参数, 此时 unt(il) 命令会继续运行程序到行数比当前行大的那一行(有点绕口, 但意思其实就是下一行🧐), 此时它的功能类似于 n(ext) 📒 unt(il) 命令默认会停在当前函数(或者是堆栈帧) return 的地方, 而 c(ontinue) 会一直运行到下去 restart [args...] - 可以给定不同的参数再次重新运行来 debug ","date":"2021-12-28","objectID":"/zh-cn/how-to-debug-in-python/:3:2","tags":["Debug","Python"],"title":"怎么 debug 一个 Python 文件","uri":"/zh-cn/how-to-debug-in-python/"},{"categories":["Python"],"content":"查看各种信息 h(elp) [command] - 不知道命令可以查询一下 p expression - 相当于 print expression, 也可以使用 pp(对应 pprint) 一个比较特殊的 expression 是 locals(), 可以查看当前所在位置的 context 📒 要深刻理解这里是 expression 的好处, 如果本来的 expression 不对, 其实你可以直接在这里想要怎么改, 然后直接进行测试😮 a(rgs) - 打印当前所有的变量的值 whatis expression - 相当于 type(expression) source expression - 查看 expression 的源码. 常用的 expression 是函数名 ","date":"2021-12-28","objectID":"/zh-cn/how-to-debug-in-python/:3:3","tags":["Debug","Python"],"title":"怎么 debug 一个 Python 文件","uri":"/zh-cn/how-to-debug-in-python/"},{"categories":["Python"],"content":"常见问题 Q: 我的变量名跟命令重复了怎么办, 比如变量名是 p ? A: 这个其实不影响, 你还是可以通过 p p 来获取变量名的值. 如果你直接输入 p 显示 p 对应的值的话, 你可以使用 !p, 用 ! 来告诉 ipdb 在它后面的是 python 语句 Q: 每次单步执行之后都要用 p expression 的方式来看变量的值, 有没有更为简便的方法? A: 可以用 display expression, 那么在 expression 的值发生变动的时候, 它就会输出对应的值. 如果要取消就用 undisplay expression Q: 觉得命令有点少不满足自己的需要 ? A: 可以在 ipdb 里面直接写 python 的代码 🤗 Q: 不想使用 python -m ipdb \u003cfilename\u003e 想直接在代码里插入程序断点 ? A: 这也是可以的, 你可以在要插入的行之前设置, 像这样: ...... import ipdb; ipdb.set_trace(); ...... 如果你是用是 \u003e= Python 3.7 的版本, 可以插入 breakpoint() 而不是 import ipdb; ipdb.set_trace();, 这样设置的好处是你可以一次性取消所有的程序断点😮, 你就可以区分开正常运行的模式和调试程序的模式. 这种方式默认采用的是 pdb Q: -\u003e 指向的行运行了吗 ? A: 没有 Q: 如果我一直在调用 step 命令, 难道我每一次都要输入 s 吗, 有没有更快捷的方法 ? A: 可以直接使用回车键(ENTER), 会自动重复上一次的命令 ","date":"2021-12-28","objectID":"/zh-cn/how-to-debug-in-python/:4:0","tags":["Debug","Python"],"title":"怎么 debug 一个 Python 文件","uri":"/zh-cn/how-to-debug-in-python/"},{"categories":["Python"],"content":"参考 pdb 的官方文档 ps. 有兴趣的可以查看我翻译的一个项目 - pdb 教程, 还挺有意思的 ","date":"2021-12-28","objectID":"/zh-cn/how-to-debug-in-python/:5:0","tags":["Debug","Python"],"title":"怎么 debug 一个 Python 文件","uri":"/zh-cn/how-to-debug-in-python/"},{"categories":null,"content":"简单介绍 git lfs 的使用方法和使用场景","date":"2021-12-06","objectID":"/zh-cn/gitlfs/","tags":["git"],"title":"git lfs 使用指南","uri":"/zh-cn/gitlfs/"},{"categories":null,"content":"什么是 git-lfs ","date":"2021-12-06","objectID":"/zh-cn/gitlfs/:1:0","tags":["git"],"title":"git lfs 使用指南","uri":"/zh-cn/gitlfs/"},{"categories":null,"content":"Github 对文件大小的限制 如果你在命令行用 git push \u003e 50 MB 的文件，你会收到一个 warning，但是你仍然可以正常 push，但是 \u003e 100 MB 的时候就无法 push 了 如果你在浏览器要上传文件的话，限制更为严重，不能超过 25 MB 另外有几点值得注意： Github 建议仓库的大小理想情况下不要超过 1 GB，最好不要超过 5 GB Github 从来不建议把仓库当成一种备份工具 ","date":"2021-12-06","objectID":"/zh-cn/gitlfs/:1:1","tags":["git"],"title":"git lfs 使用指南","uri":"/zh-cn/gitlfs/"},{"categories":null,"content":"为什么需要 gif-lfs 前面提到的 Github 对文件大小的限制是一点 另外因为每次我们在使用 git commit 的时候，其实是给当前的仓库创建了一次快照，本质是全仓库的克隆，如果大文件太多是很不好的，你的 Git 仓库会越来越大 ","date":"2021-12-06","objectID":"/zh-cn/gitlfs/:1:2","tags":["git"],"title":"git lfs 使用指南","uri":"/zh-cn/gitlfs/"},{"categories":null,"content":"什么情况下不需要用 gif-lfs 文件没有超过限制当然就没有必要用了 如果是要分发二进制文件（比如 *.exe）等，此时直接用 Github 提供的 release 功能就好了 ","date":"2021-12-06","objectID":"/zh-cn/gitlfs/:1:3","tags":["git"],"title":"git lfs 使用指南","uri":"/zh-cn/gitlfs/"},{"categories":null,"content":"git-lfs 原理 使用 gif-lfs 之后，在仓库中存储的其实是对大文件的引用，可以理解为指针。而真正的大文件托管在 Git Lfs 的服务器上 Github 给不同用户的 git-lfs 提供的额度不一样，免费用户和 Pro 用户都是 2 GB ","date":"2021-12-06","objectID":"/zh-cn/gitlfs/:2:0","tags":["git"],"title":"git lfs 使用指南","uri":"/zh-cn/gitlfs/"},{"categories":null,"content":"引用文件长什么样子 比如官方文档里面提到的例子： version https://git-lfs.github.com/spec/v1 oid sha256:4cac19622fc3ada9c0fdeadb33f88f367b541f38b89102a3f1261ac81fd5bcb5 size 84977953 其中 version 是你正在使用的 git-lfs 的版本，oid 是标志符（id），size 是文件的真实大小 ","date":"2021-12-06","objectID":"/zh-cn/gitlfs/:2:1","tags":["git"],"title":"git lfs 使用指南","uri":"/zh-cn/gitlfs/"},{"categories":null,"content":"开始使用 git-lfs ","date":"2021-12-06","objectID":"/zh-cn/gitlfs/:3:0","tags":["git"],"title":"git lfs 使用指南","uri":"/zh-cn/gitlfs/"},{"categories":null,"content":"如何安装 git-lfs (Mac 环境下) \u003e brew install git-lfs \u003e git lfa install # 如果输出为 Git LFS initialized. 就是正常安装好了 ","date":"2021-12-06","objectID":"/zh-cn/gitlfs/:3:1","tags":["git"],"title":"git lfs 使用指南","uri":"/zh-cn/gitlfs/"},{"categories":null,"content":"Case 1. 从 0 开始配置使用 git-lfs 我们要指定 git-lfs 会把哪些文件当作大文件，指定方式比如有： 指定文件后缀名——git lfs track \"*.filetype\" 指定某个目录下的所有文件——git lfs track \"directory/*\" 具体指定某个文件——git lfs track \"path/to/file\" \u003e mkdir \u003crepo\u003e \u003e cd \u003crepo\u003e \u003e git init \u003e git lfs track \"*.filetype\" # 比如 *.zip # 其实 git lfs track 会修改 .gitattributes 文件的内容，可以做一个快速的验证 # \u003e cat .gitattributes # *.zip filter=lfs diff=lfs merge=lfs -text # 下面假定在 Github 有一个远程仓库供我们使用 # 往仓库里加你先前指定的文件类型的大文件 \u003e git add . \u003e git commit -m \"\" \u003e git branch -M main \u003e git remote add origin git@github.com:\u003cusername\u003e/\u003cremote_repo_name\u003e.git # 这里替换为自己的用户名和远程仓库名 \u003e git push -u origin main # 此时命令行会显示 # \u003e uploading LFS objects # 如果没有采用 git-lfs，则显示如下内容 # \u003e Enumerating objects: 3, done. # Counting objects: 100% (3/3), done. # Delta compression using up to 8 threads # Compressing objects: 100% (2/2), done. ","date":"2021-12-06","objectID":"/zh-cn/gitlfs/:3:2","tags":["git"],"title":"git lfs 使用指南","uri":"/zh-cn/gitlfs/"},{"categories":null,"content":"Case 2. 要在已有的仓库上用 git-lfs 追踪某些文件 此时只是简单的使用 git lfs track \"\" 是没用的，因为你之前的 commit 已经生成了快照，你无法追踪历史中的这些大文件。 git-lfs 只会在你开始设置的此刻之后追踪新生成的指定文件 可以快速做个验证，假设我们还在这个仓库里⬇️ \u003e ls \u003e test1.txt \u003e ls -l \u003e test2.txt \u003e git add test1.txt test2.txt \u003e git commit -m \"Add txt files\" # 假设我们现在要把 txt 文件当成是大文件，我们可能会想这么做 \u003e git lfs track \"*.txt\" \u003e git add .gitattributes \u003e git commit -m \"Track *.txt files\" \u003e git lfs ls-files # 此时你会发现 git-lfs 并没有追踪 txt 文件 \u003e echo \"hello\" \u003e test3.txt \u003e git add test3.txt \u003e git commit -m \"Add test3.txt\" \u003e git lfs ls-files # 此时你可以在输出中看到 test3.txt 正确的方法是使用 git lfs migrate，这里只列举了简单的用法，更复杂的可以看看手册。比如可以用 --include-ref= 指定分支，多个分支的时候最好一个分支一个分支地迁移，最后是 git push --all -f \u003e git lfs migrate import --include=\"*.txt\" # 在当前分支上执行 \u003e git lfs ls-files # 此时可以发现 text1.txt 和 text2.txt 也被追踪到了 \u003e git push --force # 让远程仓库也改过来 ","date":"2021-12-06","objectID":"/zh-cn/gitlfs/:3:3","tags":["git"],"title":"git lfs 使用指南","uri":"/zh-cn/gitlfs/"},{"categories":null,"content":"Case 3. 不再跟踪某些文件 \u003e git lfs untrack \"*.filetype\" \u003e git rm --cached \"*.txt\" ","date":"2021-12-06","objectID":"/zh-cn/gitlfs/:3:4","tags":["git"],"title":"git lfs 使用指南","uri":"/zh-cn/gitlfs/"},{"categories":null,"content":"其他常用命令 查看当前 git-lfs 正在追踪的文件类型——git lfs track 查看当前 git-lfs 正在追踪哪些文件——git lfs ls-file ","date":"2021-12-06","objectID":"/zh-cn/gitlfs/:4:0","tags":["git"],"title":"git lfs 使用指南","uri":"/zh-cn/gitlfs/"},{"categories":null,"content":"参考 https://docs.github.com/en/repositories/working-with-files/managing-large-files/about-large-files-on-github ","date":"2021-12-06","objectID":"/zh-cn/gitlfs/:5:0","tags":["git"],"title":"git lfs 使用指南","uri":"/zh-cn/gitlfs/"},{"categories":["Machine-Learning"],"content":"简单介绍 Precision 和 Recall 以及 F1 score 的计算方式","date":"2021-12-05","objectID":"/zh-cn/f1score/","tags":["Machine-Learning"],"title":"从混淆矩阵到 F1 score","uri":"/zh-cn/f1score/"},{"categories":["Machine-Learning"],"content":"什么是混淆矩阵 每一列表示实际情况，每一行表示我们的预测，这样组合起来就得到了一个混淆矩阵，比如一个二分类的任务，可以画出如下的混淆矩阵⬇️ Positive Negative True TP = True Positive FP = False Positive False FN = False Negative TN = True Negative ","date":"2021-12-05","objectID":"/zh-cn/f1score/:1:0","tags":["Machine-Learning"],"title":"从混淆矩阵到 F1 score","uri":"/zh-cn/f1score/"},{"categories":["Machine-Learning"],"content":"accuracy 有多少样本我们预测正确了 预测正确的其实有下面两种情形⬇️ TP：本来是 positive，你也认为是 positive 的 TN：本来是 negative，你也认为是 negative 的 那么用 TP + TN（其实就是主对角线）除以总的样本数就可以得到 accuracy， 📒或者直接看表格，其实就是 $\\frac{主对角线}{四个单元格} =\\frac{TP+TN}{TP+TN+FN+FP}$ 一般来说 accuracy 是好用的评估指标，但是在某些情况下不是这样子的，比如样本数据不均衡的时候 类别 A 类别 B 判断是类别 A 0 0 判断是类别 B 1 99 假设类别 A 有 1 个，类别 B 有 99 个，如果不管输入的是什么都返回类别 B 的正确率是多少呢？ 答案是 $\\frac{0+99}{0+0+1+99}=99%$，我们可以说这个分类器效果很好吗，这显然是很荒谬的😂 ","date":"2021-12-05","objectID":"/zh-cn/f1score/:1:1","tags":["Machine-Learning"],"title":"从混淆矩阵到 F1 score","uri":"/zh-cn/f1score/"},{"categories":["Machine-Learning"],"content":"Precision 所有预测为 True 的样本里面，有多少是真的 positive 的 从定义出发可以知道，其实就是表格中判断为 True 的这一行中 positive 的比例，那么就是 $\\frac{TP}{TP+FP}$ ","date":"2021-12-05","objectID":"/zh-cn/f1score/:1:2","tags":["Machine-Learning"],"title":"从混淆矩阵到 F1 score","uri":"/zh-cn/f1score/"},{"categories":["Machine-Learning"],"content":"Recall 所有本来是 positive 的，有多少被我们成功预测了出来 从定义出发，所有本来是 positive 的就是 Positive 这一列之和，我们成功预测的是 TP，那么就是 $\\frac{TP}{TP+FN}$ 📒我们常常要在 Precision 和 Recall 中进行 tradeoff，因为其中一个升高，另一个就会降低 ","date":"2021-12-05","objectID":"/zh-cn/f1score/:1:3","tags":["Machine-Learning"],"title":"从混淆矩阵到 F1 score","uri":"/zh-cn/f1score/"},{"categories":["Machine-Learning"],"content":"F1 score 正是因为 Precision 和 Recall 的互斥特性，在衡量分类器好坏的时候会给我们带来困扰，特别是两者相差不多的情况下，于是就需要将这两个指标合并起来用另一个指标表示，也就是 F1 score F1 score 的计算方式如下： $$F1\\ score = \\frac{2PR}{P+R}$$ 其中 Precision = $P$； Recall = $R$ ","date":"2021-12-05","objectID":"/zh-cn/f1score/:2:0","tags":["Machine-Learning"],"title":"从混淆矩阵到 F1 score","uri":"/zh-cn/f1score/"},{"categories":["Machine-Learning"],"content":"F1 score 的不同计算方法 Macro：分别计算每个类别的 $P$ 和 $R$，再计算总的平均的 $P$ 和 $R$，最后用这个计算 F1 score Micro：合并多个类别的统计结果到一个表格里面，在分别算 $P$ 和 $R$ 和 F1 score 配合后面的例子🌰食用 ","date":"2021-12-05","objectID":"/zh-cn/f1score/:2:1","tags":["Machine-Learning"],"title":"从混淆矩阵到 F1 score","uri":"/zh-cn/f1score/"},{"categories":["Machine-Learning"],"content":"F1 score 的几个规律 F1 score 永远在 precision 和 recall 之间， F1 score 会给低的部分（$P\\ or\\ R$）更多的权重，所以如果算术平均值是一样的情况下，哪个分类器的短板更短，它的 F1 就会越差 情况一：比如 $P$ 和 $R$ 分别是 $60%$ 和 $60%$，可以算他们的 F1 score = $60%$ 情况二：比如 $P$ 和 $R$ 分别是 $50%$ 和 $70%$，可以看到他们和上一种情况的平均值是一样的，但是他们的 F1 score = $58.3%$ 由 1. 可知：📒 高 F1 score 不意味着分类器更好或更适合你的任务，有时候你可能更关注 Precision 或者 Recall 这两个中的一个 ","date":"2021-12-05","objectID":"/zh-cn/f1score/:2:2","tags":["Machine-Learning"],"title":"从混淆矩阵到 F1 score","uri":"/zh-cn/f1score/"},{"categories":["Machine-Learning"],"content":"一个完整的例子🌰 class 0 class 1 class 2 predict_class0 2 0 0 predict_class1 1 0 1 predict_class2 0 2 0 ","date":"2021-12-05","objectID":"/zh-cn/f1score/:3:0","tags":["Machine-Learning"],"title":"从混淆矩阵到 F1 score","uri":"/zh-cn/f1score/"},{"categories":["Machine-Learning"],"content":"Macro 的计算方式 要先得到每一个类别的 Precision 和 Recall，先画出表格⬇️ class 0 Not class 0 predict_class0 2 1 predict_not_class0 0 3 class 1 Not class 1 predict_class1 0 2 predict_not_class1 2 2 class 2 Not class 2 predict_class2 0 1 predict_not_class2 2 3 可以得到如下的结果 class 0：Precision = $\\frac{2}{3}$；Recall = $1$ class 1：Precision = $0$；Recall = $0$ class 2：Precision = $0$；Recall = $0$ 那么平均的 Precision 就是 $\\frac{2}{3} * \\frac{1}{3} = \\frac{2}{9}$；平均的 Recall 是 $\\frac{1}{3}$，代入 F1 score 的计算公式可以得到 $\\frac{4}{15}=0.26666$ ","date":"2021-12-05","objectID":"/zh-cn/f1score/:3:1","tags":["Machine-Learning"],"title":"从混淆矩阵到 F1 score","uri":"/zh-cn/f1score/"},{"categories":["Machine-Learning"],"content":"Micro 的计算方式 将三个表格叠起来（对应位置相加），可以得到如下的表格 class ? Not class ? predict_class? 2 4 predict_not_class? 4 8 代入公式算得 F1 score = $1/3=0.333333$ ","date":"2021-12-05","objectID":"/zh-cn/f1score/:3:2","tags":["Machine-Learning"],"title":"从混淆矩阵到 F1 score","uri":"/zh-cn/f1score/"},{"categories":["Machine-Learning"],"content":"代码验证 from sklearn.metrics import f1_score, confusion_matrix y_true = [0, 1, 2, 0, 1, 2] y_pred = [0, 2, 1, 0, 0, 1] print(confusion_matrix(y_true, y_pred)) # confusion matrix # [[2 0 0] # [1 0 1] # [0 2 0]] print(f1_score(y_true, y_pred, average='macro')) # 0.26666 print(f1_score(y_true, y_pred, average='micro')) # 0.33333 ","date":"2021-12-05","objectID":"/zh-cn/f1score/:4:0","tags":["Machine-Learning"],"title":"从混淆矩阵到 F1 score","uri":"/zh-cn/f1score/"},{"categories":["Machine-Learning"],"content":"参考 sklearn 的 f1_score 介绍 ","date":"2021-12-05","objectID":"/zh-cn/f1score/:5:0","tags":["Machine-Learning"],"title":"从混淆矩阵到 F1 score","uri":"/zh-cn/f1score/"}]
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Python - Tag - MartinLwx&#39;s blog</title>
        <link>https://martinlwx.github.io/tags/python/</link>
        <description>Python - Tag - MartinLwx&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>martinlwx@163.com (MartinLwx)</managingEditor>
            <webMaster>martinlwx@163.com (MartinLwx)</webMaster><lastBuildDate>Sun, 16 Oct 2022 15:14:57 &#43;0800</lastBuildDate><atom:link href="https://martinlwx.github.io/tags/python/" rel="self" type="application/rss+xml" /><item>
    <title>Pattern Matching in Python</title>
    <link>https://martinlwx.github.io/pattern-matching-in-python/</link>
    <pubDate>Sun, 16 Oct 2022 15:14:57 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/pattern-matching-in-python/</guid>
    <description><![CDATA[This post is originally written in jupyter notebook and then convert to markdown. To get the original notebook files. Please check the repo
Intro Today I want to talk about the new feature bring in Python 3.10 &ndash; Pattern matching ðŸŽ‰
Those who have learned C language must be familiar with the following switch statement:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 switch (expression) { case constant_1: // statements break; case constant_2: // statements break; // Fall through // the value of the expression can be either constant_3 or constant_4 :) case constant_3: case constant_4: // statements default: // default statements } To recap, the syntax rules of the switch statement:]]></description>
</item>
<item>
    <title>Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)</title>
    <link>https://martinlwx.github.io/proj3.ants-vs-somebees-of-cs61a-of-ucb/</link>
    <pubDate>Thu, 10 Mar 2022 21:43:59 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/proj3.ants-vs-somebees-of-cs61a-of-ucb/</guid>
    <description><![CDATA[Intro I have finished the first two projects - Hog and Cats. The first two projects are relatively simple and uncomplicated. But today, the difficulty of the third project has indeed increased (you can see how complicated this is by looking at the rules of the game). It feels like Plants vs. Zombies
So I&rsquo;m going to write a blog to sort out the ideas when writing code. ðŸ¤—
Phase 1: Basic gameplay Problem 1 (1 pt) Part A: Currently, there is no cost for placing any type of Ant, and so there is no challenge to the game.]]></description>
</item>
<item>
    <title>Lab14 CS61A of UCB(2021-Fall)</title>
    <link>https://martinlwx.github.io/lab14-cs61a-of-ucb/</link>
    <pubDate>Thu, 03 Mar 2022 08:17:14 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/lab14-cs61a-of-ucb/</guid>
    <description><![CDATA[Trees Q1: Prune Min Write a function that prunes a Tree t mutatively. t and its branches always have zero or two branches. For the trees with two branches, reduce the number of branches from two to one by keeping the branch that has the smaller label value. Do nothing with trees with zero branches.
Prune the tree in a direction of your choosing (top down or bottom up). The result should be a linear tree.]]></description>
</item>
<item>
    <title>Lab12 CS61A of UCB(2021-Fall)</title>
    <link>https://martinlwx.github.io/lab12-ca61a-of-ucb/</link>
    <pubDate>Wed, 02 Mar 2022 11:15:08 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/lab12-ca61a-of-ucb/</guid>
    <description><![CDATA[Regular Expressions Q1: Calculator Ops Write a regular expression that parses strings written in the 61A Calculator language and returns any expressions which have two numeric operands, leaving out the parentheses around them.
We need to write a regular expression to match a pattern - (operand operator1 operator2). The operands consist of +, -, *, /. We can use [] here. Don&rsquo;t forget to put a \ in front of - to escape it.]]></description>
</item>
<item>
    <title>Hw09 of CS61A of UCB(2021-Fall)</title>
    <link>https://martinlwx.github.io/hw09-of-cs61a-of-ucb/</link>
    <pubDate>Tue, 01 Mar 2022 21:13:22 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/hw09-of-cs61a-of-ucb/</guid>
    <description><![CDATA[Q2: Roman Numerals Write a regular expression that finds any string of letters that resemble a Roman numeral and aren&rsquo;t part of another word. A Roman numeral is made up of the letters I, V, X, L, C, D, M and is at least one letter long.
For the purposes of this problem, don&rsquo;t worry about whether or not a Roman numeral is valid. For example, &ldquo;VIIIII&rdquo; is not a Roman numeral, but it is fine if your regex matches it.]]></description>
</item>
<item>
    <title>Lab11 CS61A of UCB(2021-Fall)</title>
    <link>https://martinlwx.github.io/lab11-cs61a-of-ucb/</link>
    <pubDate>Tue, 01 Mar 2022 00:41:21 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/lab11-cs61a-of-ucb/</guid>
    <description><![CDATA[Context Problem 1 Important: Your code for this part should go in buffer.py.
Your job in this part is to implement the current and pop_first methods of the Buffer class.
current should return the current token of the current line we&rsquo;re on in the Buffer instance without removing it. If there are no more tokens in the current line, then current should move onto the next valid line, and return the first token of this line.]]></description>
</item>
<item>
    <title>Hw06 of CS61A of UCB(2021-Fall)</title>
    <link>https://martinlwx.github.io/hw06-of-cs61a-of-ucb/</link>
    <pubDate>Sun, 27 Feb 2022 13:17:39 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/hw06-of-cs61a-of-ucb/</guid>
    <description><![CDATA[OOP Q1: Vending Machine In this question you&rsquo;ll create a vending machine that only outputs a single product and provides change when needed.
Create a class called VendingMachine that represents a vending machine for some product. A Vending Machineobject returns strings describing its interactions. Remember to match exactly the strings in the doctests &ndash; including punctuation and spacing!
Fill in the VendingMachine class, adding attributes and methods as appropriate, such that its behavior matches the following doctests:]]></description>
</item>
<item>
    <title>Lab09 CS61A of UCB(2021-Fall)</title>
    <link>https://martinlwx.github.io/lab09-cs61a-of-ucb/</link>
    <pubDate>Sat, 26 Feb 2022 13:09:24 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/lab09-cs61a-of-ucb/</guid>
    <description><![CDATA[Recursion and Tree Recursion Q1: Subsequences A subsequence of a sequence S is a subset of elements from S, in the same order they appear in S. Consider the list [1, 2, 3]. Here are a few of it&rsquo;s subsequences [], [1, 3], [2], and [1, 2, 3].
Write a function that takes in a list and returns all possible subsequences of that list. The subsequences should be returned as a list of lists, where each nested list is a subsequence of the original input.]]></description>
</item>
<item>
    <title>Lab08 CS61A of UCB(2021-Fall)</title>
    <link>https://martinlwx.github.io/lab08-cs61a-of-ucb/</link>
    <pubDate>Thu, 24 Feb 2022 20:22:51 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/lab08-cs61a-of-ucb/</guid>
    <description><![CDATA[Q2: Convert Link Write a function convert_link that takes in a linked list and returns the sequence as a Python list. You may assume that the input list is shallow; that is none of the elements is another linked list.
Try to find both an iterative and recursive solution for this problem!
It is easy to solve this problem iteratively. All we have to do is to make a list to store these nodes we have visited while we iterating this linklist.]]></description>
</item>
<item>
    <title>Lab07 CS61A of UCB(2021-Fall)</title>
    <link>https://martinlwx.github.io/lab07-cs61a-of-ucb/</link>
    <pubDate>Thu, 24 Feb 2022 09:47:24 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/lab07-cs61a-of-ucb/</guid>
    <description><![CDATA[Accounts Q2: Retirement Add a time_to_retire method to the Account class. This method takes in an amount and returns how many years the holder would need to wait in order for the current balance to grow to at least amount, assuming that the bank adds balance times the interest rate to the total balance at the end of every year.
The description tells us that: We will add our balance every year, so when may we retire?]]></description>
</item>
</channel>
</rss>

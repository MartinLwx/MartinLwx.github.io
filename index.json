[{"categories":["Vim"],"content":"Configure your neovim from scratch, including LSP support","date":"2023-02-08","objectID":"/config-neovim-from-scratch/","tags":["Nvim"],"title":"Transform Your Neovim into a IDE: A Step-by-Step Guide","uri":"/config-neovim-from-scratch/"},{"categories":["Vim"],"content":"Versions info I use a Macbook pro-2020 Intel Edition with macOS 13.2. This is my Nvim edition: NVIM v0.8.3 Build type: Release LuaJIT 2.1.0-beta3 Compiled by brew@Ventura Features: +acl +iconv +tui See \":help feature-compile\" system vimrc file: \"$VIM/sysinit.vim\" fall-back for $VIM: \"/usr/local/Cellar/neovim/0.8.3/share/nvim\" Run :checkhealth for more info ","date":"2023-02-08","objectID":"/config-neovim-from-scratch/:1:0","tags":["Nvim"],"title":"Transform Your Neovim into a IDE: A Step-by-Step Guide","uri":"/config-neovim-from-scratch/"},{"categories":["Vim"],"content":"Why Neovim After using Vim for one year, I find myself having trouble in configure ~/.vimrc. The syntax of Vimscript is not my liking, leading me to switch Neovim(Nvim). Rather than migrating my old ~/.vimrc. I decided to start from scratch and take this opportunity to re-evaluate my previous Vim configuration. I aim to replace my plugins with the latest SOTA(State-of-the-art) alternatives. It‚Äôs been some time since I last edited my ~/.vimrc In my opinion, it‚Äôs essential to understand the meaning behind each option and statement in the configuration file. That‚Äôs the approach I took in this post. My goal is to make the configuration files self-contained and easily understandable. To achieve this, I aim to provide clear explanations for each setting and include comments to enhance readability. üí° Please note that I may have missed some options. However, as a reminder, you can always access the help docs in the Nvim by typing :h \u003cname\u003e to get more information üí° This post assumes that you have a basic understanding of Vim ","date":"2023-02-08","objectID":"/config-neovim-from-scratch/:2:0","tags":["Nvim"],"title":"Transform Your Neovim into a IDE: A Step-by-Step Guide","uri":"/config-neovim-from-scratch/"},{"categories":["Vim"],"content":"The basics ","date":"2023-02-08","objectID":"/config-neovim-from-scratch/:3:0","tags":["Nvim"],"title":"Transform Your Neovim into a IDE: A Step-by-Step Guide","uri":"/config-neovim-from-scratch/"},{"categories":["Vim"],"content":"Lua In my Nvim configuration, I will use the Lua programming language as much as possible. Thus, it‚Äôs recommended that the reader familiarize themselves with Lua. Take a look at Learn Lua in Y minutes ","date":"2023-02-08","objectID":"/config-neovim-from-scratch/:3:1","tags":["Nvim"],"title":"Transform Your Neovim into a IDE: A Step-by-Step Guide","uri":"/config-neovim-from-scratch/"},{"categories":["Vim"],"content":"Configurations files paths The configuration directory for Nvim is located at ~/.config/nvim. On Linux/Mac, Nvim will read ~/.config/nvim/init.lua when it starts up. Theoretically, we can put everything inside this single file. It‚Äôs a bad practice though. To keep things organized, I prefer to break it down into smaller, more manageable parts. If you follow this post to configure your Nvim, your ~/.config/nvim should look like this‚¨áÔ∏è nvim ‚îú‚îÄ‚îÄ init.lua ‚îî‚îÄ‚îÄ lua ‚îú‚îÄ‚îÄ colorscheme.lua ‚îú‚îÄ‚îÄ config ‚îÇ¬†‚îî‚îÄ‚îÄ nvim-cmp.lua ‚îú‚îÄ‚îÄ keymaps.lua ‚îú‚îÄ‚îÄ lsp.lua ‚îú‚îÄ‚îÄ options.lua ‚îî‚îÄ‚îÄ plugins.lua The explanations init.lua is the entry point. We will ‚Äúimport‚Äù other *.lua files in init.lua colorscheme.lua for the theme keymaps.lua for key mappings lsp.lua for the LSP support options.lua for some global options plugins.lua for third-party plugins Put the configurations of third-party plugins in this config folder. For example, nvim-cmp.lua for the nvim-cmp plugin lua folder. When we call require to import a module in Lua, it will search this folder. Replace the path separator / with ., and remove the suffix - .lua. That‚Äôs how you get the parameter of require For example, to import nvim-cmp.lua, you should write require('config.nvim-cmp') ","date":"2023-02-08","objectID":"/config-neovim-from-scratch/:3:2","tags":["Nvim"],"title":"Transform Your Neovim into a IDE: A Step-by-Step Guide","uri":"/config-neovim-from-scratch/"},{"categories":["Vim"],"content":"Options We mainly use these: vim.g, vim.opt, and vim.cmd. I made a cheatsheet below: In Vim In Nvim Note let g:foo = bar vim.g.foo = bar set foo = bar vim.opt.foo = bar set foo = vim.opt.foo = true some_vimscript vim.cmd(some_vimscript) ","date":"2023-02-08","objectID":"/config-neovim-from-scratch/:3:3","tags":["Nvim"],"title":"Transform Your Neovim into a IDE: A Step-by-Step Guide","uri":"/config-neovim-from-scratch/"},{"categories":["Vim"],"content":"key mappings The syntax of key binding in Nvim: vim.keymap.set(\u003cmode\u003e, \u003ckey\u003e, \u003caction\u003e, \u003copts\u003e) For a detailed explanation, please refer to :h vim.keymap.set ","date":"2023-02-08","objectID":"/config-neovim-from-scratch/:3:4","tags":["Nvim"],"title":"Transform Your Neovim into a IDE: A Step-by-Step Guide","uri":"/config-neovim-from-scratch/"},{"categories":["Vim"],"content":"Configure Nvim from scratch Now we can configure Nvim step by step :) ","date":"2023-02-08","objectID":"/config-neovim-from-scratch/:4:0","tags":["Nvim"],"title":"Transform Your Neovim into a IDE: A Step-by-Step Guide","uri":"/config-neovim-from-scratch/"},{"categories":["Vim"],"content":"Install Neovim I am a Mac user, so I use Homebrew to install Nvim1 $ brew install neovim After completing the installation, If the ~/.config/nvim/ directory doesn‚Äôt exist, you should create the folder and init.lua file $ mkdir ~/.config/nvim $ mkdir ~/.config/nvim/lua $ touch ~/.config/nvim/lua/init.lua üí° Please note that after making any modifications to the *.lua files, you need to restart the Nvim to see the changes take effect. I will assume that you restart your Nvim after each section ","date":"2023-02-08","objectID":"/config-neovim-from-scratch/:4:1","tags":["Nvim"],"title":"Transform Your Neovim into a IDE: A Step-by-Step Guide","uri":"/config-neovim-from-scratch/"},{"categories":["Vim"],"content":"Options configuration The features: Use the system‚Äôs clipboard Use the mouse in Nvim Tab and whitespace UI configuration Smart search Create ~/.config/nvim/lua/options.lua file and edit: -- Hint: use `:h \u003coption\u003e` to figure out the meaning if needed vim.opt.clipboard = 'unnamedplus' -- use system clipboard vim.opt.completeopt = {'menu', 'menuone', 'noselect'} vim.opt.mouse = 'a' -- allow the mouse to be used in Nvim -- Tab vim.opt.tabstop = 4 -- number of visual spaces per TAB vim.opt.softtabstop = 4 -- number of spacesin tab when editing vim.opt.shiftwidth = 4 -- insert 4 spaces on a tab vim.opt.expandtab = true -- tabs are spaces, mainly because of python -- UI config vim.opt.number = true -- show absolute number vim.opt.relativenumber = true -- add numbers to each line on the left side vim.opt.cursorline = true -- highlight cursor line underneath the cursor horizontally vim.opt.splitbelow = true -- open new vertical split bottom vim.opt.splitright = true -- open new horizontal splits right -- vim.opt.termguicolors = true -- enabl 24-bit RGB color in the TUI vim.opt.showmode = false -- we are experienced, wo don't need the \"-- INSERT --\" mode hint -- Searching vim.opt.incsearch = true -- search as characters are entered vim.opt.hlsearch = false -- do not highlight matches vim.opt.ignorecase = true -- ignore case in searches by default vim.opt.smartcase = true -- but make it case sensitive if an uppercase is entered Then edit the init.lua file, use require to import options.lua file require('options') ","date":"2023-02-08","objectID":"/config-neovim-from-scratch/:4:2","tags":["Nvim"],"title":"Transform Your Neovim into a IDE: A Step-by-Step Guide","uri":"/config-neovim-from-scratch/"},{"categories":["Vim"],"content":"Key mappings configuration The features: Use \u003cC-h/j/k/l\u003e to move the cursor among windows Use Ctrl + arrow keys to resize windows In select mode, we can use Tab or Shift-Tab to change the indentation repeatedly Create ~/.config/nvim/lua/keymaps.lua and edit: -- define common options local opts = { noremap = true, -- non-recursive silent = true, -- do not show message } ----------------- -- Normal mode -- ----------------- -- Hint: see `:h vim.map.set()` -- Better window navigation vim.keymap.set('n', '\u003cC-h\u003e', '\u003cC-w\u003eh', opts) vim.keymap.set('n', '\u003cC-j\u003e', '\u003cC-w\u003ej', opts) vim.keymap.set('n', '\u003cC-k\u003e', '\u003cC-w\u003ek', opts) vim.keymap.set('n', '\u003cC-l\u003e', '\u003cC-w\u003el', opts) -- Resize with arrows -- delta: 2 lines vim.keymap.set('n', '\u003cC-Up\u003e', ':resize -2\u003cCR\u003e', opts) vim.keymap.set('n', '\u003cC-Down\u003e', ':resize +2\u003cCR\u003e', opts) vim.keymap.set('n', '\u003cC-Left\u003e', ':vertical resize -2\u003cCR\u003e', opts) vim.keymap.set('n', '\u003cC-Right\u003e', ':vertical resize +2\u003cCR\u003e', opts) ----------------- -- Visual mode -- ----------------- -- Hint: start visual mode with the same area as the previous area and the same mode vim.keymap.set('v', '\u003c', '\u003cgv', opts) vim.keymap.set('v', '\u003e', '\u003egv', opts) Edit init.lua and import keymaps.lua ... require('keymaps') üí° ... means that we omit other lines(in order to save the length of the post) ","date":"2023-02-08","objectID":"/config-neovim-from-scratch/:4:3","tags":["Nvim"],"title":"Transform Your Neovim into a IDE: A Step-by-Step Guide","uri":"/config-neovim-from-scratch/"},{"categories":["Vim"],"content":"Install package manager A powerful Nvim should be augmented with third-party plugins. I have selected Packer.nvim as my plugin manager, which has several amazing features including: Support for dependencies Expressive configuration and lazy-loading options Post-install/update hooks ‚Ä¶ üí° The syntax of adding a third-party package is use ... Create ~/.config/nvim/lua/plugins.lua and paste the following code. At the moment, I haven‚Äôt added any third-party packages. The template code will do these for us: Install Packer.nvim if not installed After modifying the plugins.lua file and saving it, Packer.nvim will automatically update and configure the plugins. You should see a popped window on the right side of the Nvim indicating the status of the plugin updates. üí° You do not need to memorize all the commands available in Packer.nvim, as the template will handle the majority of the work for you. It‚Äôs worth mentioning that if you failed to update and configure because of the network issue, you can press \u003cR\u003e in the popped window to re-sync. Once the Packer.nvim syncs successfully, you can restart your Nvim to see the changes. -- Install Packer automatically if it's not installed(Bootstraping) -- Hint: string concatenation is done by `..` local ensure_packer = function() local fn = vim.fn local install_path = fn.stdpath('data')..'/site/pack/packer/start/packer.nvim' if fn.empty(fn.glob(install_path)) \u003e 0 then fn.system({'git', 'clone', '--depth', '1', 'https://github.com/wbthomason/packer.nvim', install_path}) vim.cmd [[packadd packer.nvim]] return true end return false end local packer_bootstrap = ensure_packer() -- Reload configurations if we modify plugins.lua -- Hint -- \u003cafile\u003e - replaced with the filename of the buffer being manipulated vim.cmd([[ augroup packer_user_config autocmd! autocmd BufWritePost plugins.lua source \u003cafile\u003e | PackerSync augroup end ]]) -- Install plugins here - `use ...` -- Packer.nvim hints -- after = string or list, -- Specifies plugins to load before this plugin. See \"sequencing\" below -- config = string or function, -- Specifies code to run after this plugin is loaded -- requires = string or list, -- Specifies plugin dependencies. See \"dependencies\". -- ft = string or list, -- Specifies filetypes which load this plugin. -- run = string, function, or table, -- Specify operations to be run after successful installs/updates of a plugin return require('packer').startup(function(use) -- Packer can manage itself use 'wbthomason/packer.nvim' --------------------------------------- -- NOTE: PUT YOUR THIRD PLUGIN HERE -- --------------------------------------- -- Automatically set up your configuration after cloning packer.nvim -- Put this at the end after all plugins if packer_bootstrap then require('packer').sync() end end) Again, import plugins.lua in init.lua ... require('plugins') If you see a black window with no content when opening Nvim, just wait for a moment as Packer.nvim is in the process of installing itself‚òïÔ∏è ","date":"2023-02-08","objectID":"/config-neovim-from-scratch/:4:4","tags":["Nvim"],"title":"Transform Your Neovim into a IDE: A Step-by-Step Guide","uri":"/config-neovim-from-scratch/"},{"categories":["Vim"],"content":"Colorscheme My favorite theme - monokai. Add this plugin in plugins.lua ... use 'tanvirtin/monokai.nvim' ... Save the changes and wait for Packer.nvim to finish installing. Create ~/.config/nvim/colorscheme.lua and edit: -- define your colorscheme here local colorscheme = 'monokai_pro' local is_ok, _ = pcall(vim.cmd, \"colorscheme \" .. colorscheme) if not is_ok then vim.notify('colorscheme ' .. colorscheme .. ' not found!') return end The pcall here refers to a protected call in Lua, which will return a boolean value to indicate its successful execution(a similar approach can be found in Go with the use of err). By using pcall instead of vim.cmd('colorscheme monokai_pro'), we can avoid some annoying error messages in case the colorscheme is not installed2 Again, import colorscheme.lua in init.lua ... require('colorscheme') ","date":"2023-02-08","objectID":"/config-neovim-from-scratch/:4:5","tags":["Nvim"],"title":"Transform Your Neovim into a IDE: A Step-by-Step Guide","uri":"/config-neovim-from-scratch/"},{"categories":["Vim"],"content":"Auto-completion It can be quite complicated to configure auto-completion manually, which is why we use some fantastic plugins to ease the burden. Now I will discuss a simpler solution I have found. First, use this plugin nvim-cmp, which can manage many completion sources for us. It can also let us customize the completion menu etc. Create ~/.config/nvim/lua/config/nvim-cmp.lua and edit üí° Let‚Äôs first write the configurations of nvim-cmp and then modify the plugins.lua file. It assures we won‚Äôt get an annoying error message when the nvim-cmp tries to read the missing nvim-cmp.lua file. The code below may seem a little complicated. Don‚Äôt worry, I will show you how it works. local has_words_before = function() unpack = unpack or table.unpack local line, col = unpack(vim.api.nvim_win_get_cursor(0)) return col ~= 0 and vim.api.nvim_buf_get_lines(0, line - 1, line, true)[1]:sub(col, col):match(\"%s\") == nil end local luasnip = require(\"luasnip\") local cmp = require(\"cmp\") cmp.setup({ snippet = { -- REQUIRED - you must specify a snippet engine expand = function(args) require('luasnip').lsp_expand(args.body) -- For `luasnip` users. end, }, mapping = cmp.mapping.preset.insert({ -- Use \u003cC-b/f\u003e to scroll the docs ['\u003cC-b\u003e'] = cmp.mapping.scroll_docs( -4), ['\u003cC-f\u003e'] = cmp.mapping.scroll_docs(4), -- Use \u003cC-k/j\u003e to switch in items ['\u003cC-k\u003e'] = cmp.mapping.select_prev_item(), ['\u003cC-j\u003e'] = cmp.mapping.select_next_item(), -- Use \u003cCR\u003e(Enter) to confirm selection -- Accept currently selected item. Set `select` to `false` to only confirm explicitly selected items. ['\u003cCR\u003e'] = cmp.mapping.confirm({ select = true }), -- A super tab -- sourc: https://github.com/hrsh7th/nvim-cmp/wiki/Example-mappings#luasnip [\"\u003cTab\u003e\"] = cmp.mapping(function(fallback) -- Hint: if the completion menu is visible select next one if cmp.visible() then cmp.select_next_item() elseif luasnip.expand_or_locally_jump() then -- You could replace the expand_or_jumpable() calls with expand_or_locally_jumpable() -- they way you will only jump inside the snippet region luasnip.expand_or_jump() elseif has_words_before() then cmp.complete() else fallback() end end, { \"i\", \"s\" }), -- i - insert mode; s - select mode [\"\u003cS-Tab\u003e\"] = cmp.mapping(function(fallback) if cmp.visible() then cmp.select_prev_item() elseif luasnip.jumpable( -1) then luasnip.jump( -1) else fallback() end end, { \"i\", \"s\" }), }), -- Let's configure the item's appearance -- source: https://github.com/hrsh7th/nvim-cmp/wiki/Menu-Appearance formatting = { -- Set order from left to right -- kind: single letter indicating the type of completion -- abbr: abbreviation of \"word\"; when not empty it is used in the menu instead of \"word\" -- menu: extra text for the popup menu, displayed after \"word\" or \"abbr\" fields = { 'abbr', 'menu' }, -- customize the appearance of the completion menu format = function(entry, vim_item) vim_item.menu = ({ nvim_lsp = '[Lsp]', luasnip = '[Luasnip]', buffer = '[File]', path = '[Path]', })[entry.source.name] return vim_item end, }, -- Set source precedence sources = cmp.config.sources({ { name = 'nvim_lsp' }, -- For nvim-lsp { name = 'luasnip' }, -- For luasnip user { name = 'buffer' }, -- For buffer word completion { name = 'path' }, -- For path completion }) }) Then we modify plugins.lua file to add the plugins needed: ... use { 'neovim/nvim-lspconfig' } use { 'hrsh7th/nvim-cmp', config = [[require('config.nvim-cmp')]] } use { 'hrsh7th/cmp-nvim-lsp', after = 'nvim-cmp' } use { 'hrsh7th/cmp-buffer', after = 'nvim-cmp' } -- buffer auto-completion use { 'hrsh7th/cmp-path', after = 'nvim-cmp' } -- path auto-completion use { 'hrsh7th/cmp-cmdline', after = 'nvim-cmp' } -- cmdline auto-completion use 'L3MON4D3/LuaSnip' use 'saadparwaiz1/cmp_luasnip' ... Explanations: cmp.setup function accepts a Lua table, which defines some options for customization. You will find that plenty of plugins follow this API design. It‚Äôs a common practice. The nvim-cmp is the main plugin we care about. All other plugins begin wit","date":"2023-02-08","objectID":"/config-neovim-from-scratch/:4:6","tags":["Nvim"],"title":"Transform Your Neovim into a IDE: A Step-by-Step Guide","uri":"/config-neovim-from-scratch/"},{"categories":["Vim"],"content":"Wrapping up With this configuration, we successfully turned Nvim into a lightweight IDE, which supports code highlighting, code completion, syntax checking, and other functionalities. And it is completely open source and freeü•∞ I realized that even after trying different code editors and IDEs, I always found myself searching for Vim support. So I chose to turn Nvim into an IDE, and host the configuration files on my martinlwx/dotfiles. In this way, I can easily clone my configuration files to any new machine and have a consistent programming experience across machines. Polishing tools requires effort and time. In order to understand the purpose of each option, I had to search for various materials. However, despite the challenges, I firmly believe that it‚Äôs worth it. Understanding your tools allows you to further extend and customize them. This article has aimed to present a simple and straightforward configuration, but there are still many beautification and customization things that can be done, including many excellent third-party plug-ins that have not been mentioned yet. The exploration and discovery are left to the readers ","date":"2023-02-08","objectID":"/config-neovim-from-scratch/:5:0","tags":["Nvim"],"title":"Transform Your Neovim into a IDE: A Step-by-Step Guide","uri":"/config-neovim-from-scratch/"},{"categories":["Vim"],"content":"Refs Installing-Neovim¬†‚Ü©Ô∏é Adding a colorscheme/theme¬†‚Ü©Ô∏é jdhao/nvim-config¬†‚Ü©Ô∏é Language Server Protocol - Wiki¬†‚Ü©Ô∏é ","date":"2023-02-08","objectID":"/config-neovim-from-scratch/:6:0","tags":["Nvim"],"title":"Transform Your Neovim into a IDE: A Step-by-Step Guide","uri":"/config-neovim-from-scratch/"},{"categories":["Python"],"content":"An introduction to type hints in Python","date":"2023-01-13","objectID":"/type-hints-in-python/","tags":["Python"],"title":"Type hints: what and why","uri":"/type-hints-in-python/"},{"categories":["Python"],"content":"Intro I was immediately drawn to Python when I first encountered it due to its dynamic language features. Python use the ‚Äúduck typing‚Äù design, which means that the type of an object is not as important as its behavior. This feature allows for faster development and a reduction in burdensome type declarations. Additionally, the support of powerful third-party libraries solidifies Python as my preferred programming language.üò∫ However, with the proposal of PEP 4841, Python decided to introduce type hints, which seem to be in line with statically typed languages. It‚Äôs not true though, Python‚Äôs type hints are optional, and it has no runtime effect. It seems that writing this blog post specifically to introduce Python‚Äôs type hints is unnecessary, but I have found that using them in my code still provides several benefits: Static type checker can check your code. For example, Mypy The code completion in IDE will become more intelligent. It will also report a bug if we use the wrong APIs. This is probably the biggest motivation for me to choose to write type hints Manage code complexity. Type hints expose useful information about APIs. As a developer, we can get a general idea by just looking at the signature of such an annotated function, without having to check the docstrings frequently. ! python --version Python 3.11.0\r","date":"2023-01-13","objectID":"/type-hints-in-python/:1:0","tags":["Python"],"title":"Type hints: what and why","uri":"/type-hints-in-python/"},{"categories":["Python"],"content":"Function annotations Shipped with Python 3.0, the syntax of type hints has been established2: Arguments: name[: type] [ = default_val ], the [] means optional Return type: the syntax is -\u003e return_type We can access the __annotations__ attribute to get type hints informatios. It returns a dict with {ParamName: ParamType}. ==It‚Äôs a bad practice to access this attribute directly. We can use the functions inside the inspect module(Python 3.10+) or the typing module(Python 3.5 ~ 3.9)==. See the following example: def maximum(a: float, b: float) -\u003e float: \"\"\" A simple function to return the maximum elements of two floats\"\"\" return max(a, b) # \u003e= Python 3.10, do this import inspect assert inspect.get_annotations(maximum) == maximum.__annotations__ # Python 3.5 ~ 3.9 import typing assert typing.get_type_hints(maximum) == maximum.__annotations__ inspect.get_annotations(maximum) {'a': float, 'b': float, 'return': float} üìí It‚Äôs important to reiterate that type hints in Python have no impact on the runtime of the program. This means that even if we violate the type hints, the program will still execute as normal. However, a static type checker like Mypy will throw warnings. # returns the maximum of two strings # , but we declared the arguments should be float! maximum('hello', 'world') 'world' ","date":"2023-01-13","objectID":"/type-hints-in-python/:2:0","tags":["Python"],"title":"Type hints: what and why","uri":"/type-hints-in-python/"},{"categories":["Python"],"content":"Variables annotations Prior to Python 3.6, the only way to annotate the type of a variable was to include this information in comments, such as # type ...1. This is referred to as ‚Äútype comments.‚Äù With the introduction of PEP 526, a new syntax for variable annotations was established, which is similar to the syntax used for annotating function arguments3 a: int # undefined typed value a: int = 0 # typed value with default value a 0 Similarly, we can access the module level __annotations__ attributes to get type hints information. __annotations__ {'a': int} ","date":"2023-01-13","objectID":"/type-hints-in-python/:3:0","tags":["Python"],"title":"Type hints: what and why","uri":"/type-hints-in-python/"},{"categories":["Python"],"content":"Common usage ","date":"2023-01-13","objectID":"/type-hints-in-python/:4:0","tags":["Python"],"title":"Type hints: what and why","uri":"/type-hints-in-python/"},{"categories":["Python"],"content":"Simple built-in types The simple built-in types refer to int, str etc. They can also be types defined in third-party packages. As an example, the arguments of the previously mentioned maximum function use float. ","date":"2023-01-13","objectID":"/type-hints-in-python/:4:1","tags":["Python"],"title":"Type hints: what and why","uri":"/type-hints-in-python/"},{"categories":["Python"],"content":"Any type The Any type denotes that it can be any type. But it‚Äôs different from the object type1 We can think of an unannotated function that is annotated with the Any type. def foo(x): ... # it assumes: def foo(x: Any) -\u003e Any: ... ","date":"2023-01-13","objectID":"/type-hints-in-python/:4:2","tags":["Python"],"title":"Type hints: what and why","uri":"/type-hints-in-python/"},{"categories":["Python"],"content":"Collections and Mappings We refer to each element inside a collection as an item. To add type hints for both the collection type and the item type, Python uses the [] notation. For example, to express a list of strings, we would write list[str]. This notation makes it clear that the list contains elements of the str type. Notes: After PEP 585(Python 3.9+)4, we can use the built-in list, dict etc instead of the counterparts in the typing module4. \u003c Python 3.9 \u003e= Python 3.9 typing.Tuple tuple typing.Dict dict typing.List list typing.Set set typing.Frozenset frozenset typing.Type type typing.AbstractSet collections.abc.Set typing.ContextManager contextlib.AbstractContextManager typing.AsyncContextManager contextlib.AbstractAsyncContextManager typing.Pattern, typing.re.Pattern re.Pattern typing.Match, typing.re.Match re.Match üìí Some features of the typing module will be removed in the future, so I will use the latest syntax below‚úèÔ∏è string_list: list[str] = ['hello', 'world'] # tuple[type1, type2, ..., typen] with fixed size date: tuple[int, int, int] = (2023, 1, 11) string_count: dict[str, int] = { 'hello': 1, 'world': 2, } __annotations__ {'a': int, 'string_list': list[str], 'date': tuple[int, int, int], 'string_count': dict[str, int]} The join_str_list function accepts a list of strings and uses the whitespace to join them. def join_str_list(string_list: list[str]) -\u003e str: \"\"\" join all string in a list\"\"\" return ' '.join(string_list) print(join_str_list(string_list)) print(inspect.get_annotations(join_str_list)) hello world {'string_list': list[str], 'return': \u003cclass 'str'\u003e} üìí In Python 3.9+, we can use tuple[type1, ...] to represent a tuple of any length whose types are all type1 def sum_variable_integers(data: tuple[int, ...]): \"\"\" Sum all integers of a tuple\"\"\" sum_val = 0 for integer in data: sum_val += integer return sum_val print(sum_variable_integers((1, 2, 3))) print(sum_variable_integers((3,))) 6 3 As we know, we can put any type of variable in the list. How do we add type hints for such a list? The solution is Any type: list[Any] We can just use list, which is less verbose. üìí If you want to know more collections types, please refer to collections.abc ","date":"2023-01-13","objectID":"/type-hints-in-python/:4:3","tags":["Python"],"title":"Type hints: what and why","uri":"/type-hints-in-python/"},{"categories":["Python"],"content":"Type alias Sometimes, the type will be so complicated that we don‚Äôt want to write it everywhere. So what do we do? Well, we can give it an alias with a meaningful name. The syntax is simple: AliasName = Type Take the previously defined date type as an example. A date is a tuple containing three int types. The type list[tuple[int, int, int] would denote a list of dates. To make the code more readable, it can be beneficial to give this type an alias, such as Date. See the following example: Date = tuple[int, int, int] DateList = list[Date] def print_date_list(l: DateList): \"\"\" Print all dates in the format `year-month-day` in the date list\"\"\" for year, month, day in l: print(f'{year}-{month}-{day}') print_date_list([(2022, 1, 1), (2023, 1, 3)]) print(inspect.get_annotations(print_date_list)) 2022-1-1 2023-1-3 {'l': list[tuple[int, int, int]]} The syntax of type alias is quite similar to defining a global variable. To make it more explicit, PEP 163(Python 3.10+) proposes a better way5: AliasName: TypeAlias = Type from typing import TypeAlias Date: TypeAlias = tuple[int, int, int] ","date":"2023-01-13","objectID":"/type-hints-in-python/:4:4","tags":["Python"],"title":"Type hints: what and why","uri":"/type-hints-in-python/"},{"categories":["Python"],"content":"Parameterized generic types In other programming languages, usually, they use an uppercase letter like T to denote a parameterized generic type. In python, we use TypeVar to do same thing. As the docs say: T = TypeVar('T') # Can be anything S = TypeVar('S', bound=str) # Can be any subtype of str A = TypeVar('A', str, bytes)# Must be exactly str or bytes To summarize, TypeVar provides two ways for us to restrict the generic types: use bound=some_type, then we can only pass the subtype of some_type. specify the allowed types directly üìí The definition of subtype is in PEP 4836. In general: each type is its own subtype; In Object-oriented programming, the subclass is the subtype of its superclass from typing import TypeVar GenericString = TypeVar('GenericString', str, bytes) def process(s: GenericString): \"\"\" The GenericString can be either str or bytes\"\"\" ... üìí The typing module already provides us a AnyStr type to represent either str or bytes ","date":"2023-01-13","objectID":"/type-hints-in-python/:4:5","tags":["Python"],"title":"Type hints: what and why","uri":"/type-hints-in-python/"},{"categories":["Python"],"content":"Optional and Union Optional[type1] represents a type that can be either type1 or None. The Union[type1, type2, ...] means that the allowed type is one of the types we specified, which is the logical or relationship. So we can know that the Optional[type1] is equal to Union[type1, None]. from typing import Optional, Union def parse(s: Union[str, int]) -\u003e Optional[int]: \"\"\" Parse `s` and get an integer value. The `s` may be a string. Return None if fail \"\"\" if isinstance(s, str): if not s.isdigit(): return None else: return int(s) elif isinstance(s, int): return s assert parse('foo') is None assert parse('123') == 123 assert parse(123) == 123 inspect.get_annotations(parse) {'s': typing.Union[str, int], 'return': typing.Optional[int]} In Python 3.10+, it introduces | to replace the Union. Some other programming languages also use |. For example, Rust use | to seperate multiple possible patterns. The parse function we defined earlier can be written in the following form: def parse(s: str | int) -\u003e int | None: \"\"\" Parse `s` and get an integer value. The `s` may be a string. Return None if fail \"\"\" if isinstance(s, str): if not s.isdigit(): return None else: return int(s) elif isinstance(s, int): return s inspect.get_annotations(parse) {'s': str | int, 'return': int | None} ","date":"2023-01-13","objectID":"/type-hints-in-python/:4:6","tags":["Python"],"title":"Type hints: what and why","uri":"/type-hints-in-python/"},{"categories":["Python"],"content":"Callables We use the function as an example of callable. In Python, a function is a first-class object, which means that it can be a parameter or a return value of another function. The type hints to support this: Callable[[ParamType1, ParamType2], ReturnType] Let‚Äôs define a apply function which can apply a function on the data # from typing import Callable # Python \u003c 3.9 from collections.abc import Callable def apply(f: Callable[[str | int], int | None], data: list): \"\"\" Apply callable object on data. The `Callable[[str | int], int | None]` is the type hints of `parse` we aforementioned \"\"\" for d in data: print(f(d)) apply(parse, ['hello', 123]) None 123 ","date":"2023-01-13","objectID":"/type-hints-in-python/:4:7","tags":["Python"],"title":"Type hints: what and why","uri":"/type-hints-in-python/"},{"categories":["Python"],"content":"Summary Well, that‚Äôs the entire content of this blog. I have covered some of the most common and practical uses of type hints that I have found useful. However, it is not an exhaustive guide, and there are more advanced features such as static protocols7 that readers can explore. Personally, I follow the strategy of using type hints only when the added benefits outweigh the potential added complexity. In situations where the type hints become too complex, I choose not to use them unless it is deemed necessary. I will also give you some advice based on my experiencesüéØ: When you decide what to add, try to think what this type it can do7. The static protocols7 are well suited to this requirement. This makes me think of the traits in Rust :) Always make the return type as precise as possible. Just try to imagine that a function returns Union[str, int]. We have to check it manually, which makes me fell like the type hints are a little unnecessary. Even if you pass the type checker, you are not free of bugs. Software testing is the standard practice to make your programs work as expected. Add the cheatsheet to your bookmark üëç ","date":"2023-01-13","objectID":"/type-hints-in-python/:5:0","tags":["Python"],"title":"Type hints: what and why","uri":"/type-hints-in-python/"},{"categories":["Python"],"content":"Refs PEP 484. Type Hints¬†‚Ü©Ô∏é¬†‚Ü©Ô∏é¬†‚Ü©Ô∏é PEP 3107. Function Annotations¬†‚Ü©Ô∏é PEP 526. Syntax for Variable Annotations¬†‚Ü©Ô∏é PEP 585. Type Hinting Generics In Standard Collections¬†‚Ü©Ô∏é¬†‚Ü©Ô∏é PEP 613. Explicit Type Aliases¬†‚Ü©Ô∏é PEP 483. The Theory of Type Hints¬†‚Ü©Ô∏é PEP 544. Protocols: Structural subtyping (static duck typing)¬†‚Ü©Ô∏é¬†‚Ü©Ô∏é¬†‚Ü©Ô∏é ","date":"2023-01-13","objectID":"/type-hints-in-python/:6:0","tags":["Python"],"title":"Type hints: what and why","uri":"/type-hints-in-python/"},{"categories":["Python"],"content":"A simple introduction of the unpakcing operators in python","date":"2022-12-05","objectID":"/unpacking-in-python/","tags":["Python"],"title":"Unpacking in Python 3.5","uri":"/unpacking-in-python/"},{"categories":["Python"],"content":" This post is originally written in jupyter notebook and then convert to markdown. To get the original notebook files. Please check the repo ","date":"2022-12-05","objectID":"/unpacking-in-python/:0:0","tags":["Python"],"title":"Unpacking in Python 3.5","uri":"/unpacking-in-python/"},{"categories":["Python"],"content":"Intro Today I want to talk about the unpacking operators(* and **) in python. ","date":"2022-12-05","objectID":"/unpacking-in-python/:1:0","tags":["Python"],"title":"Unpacking in Python 3.5","uri":"/unpacking-in-python/"},{"categories":["Python"],"content":"Basic usage We use * for numeric data types to indicate we want to do multiplication. However, we can also apply * to iterable objects1, which means we want to unpack all the elements inside them. üìíThe built-in iterable objects: list, tuple, set, and dict ","date":"2022-12-05","objectID":"/unpacking-in-python/:2:0","tags":["Python"],"title":"Unpacking in Python 3.5","uri":"/unpacking-in-python/"},{"categories":["Python"],"content":"Starred assignment/expression In the release of python 3.0, it is shipped with powerful iterable unpacking operations2, which is called the starred assignment/expression(or parallel assignment). We are allowed to specify a catch-all name in the LHS(i.e. Left Hand Side) of = to catch values in the RHS(i.e. Right Hand Side). The example says more: \u003e\u003e\u003e first, *rest, last = [1, 2, 3, 4, 5] \u003e\u003e\u003e first 1 \u003e\u003e\u003e rest [2, 3, 4] \u003e\u003e\u003e last 5 üìí The syntax is quite simple: a variable name follows a star - *foo. we can put it anywhere in the LHS of = to catch items, but only once. Also, the type of foo will be list In my opinion, this feature makes python code more human-readableüëç There are some restrictions though: We can‚Äôt just use a single *foo in the LHS of = as a long assignment target. The LHS must be in a list or tuple It would be an error if the RHS of = doesn‚Äôt have enough items to unpack To demonstrate the restrictions: *first = [1, 2, 3] Cell In [1], line 1 *first = [1, 2, 3] ^ SyntaxError: starred assignment target must be in a list or tuple # just add `,` would be fine # now the LHS is a tuple *first, = [1, 2, 3] first [1, 2, 3] first, second, *rest = [1] --------------------------------------------------------------------------- ValueError Traceback (most recent call last) Cell In [3], line 1 ----\u003e 1 first, second, *rest = [1] ValueError: not enough values to unpack (expected at least 2, got 1) üìí Usually, we will combine * and _(i.e. *_) to indicate we don‚Äôt care about the items it caught first, *_ = [1, 2, 3] first 1 ","date":"2022-12-05","objectID":"/unpacking-in-python/:2:1","tags":["Python"],"title":"Unpacking in Python 3.5","uri":"/unpacking-in-python/"},{"categories":["Python"],"content":"More power Start from Python 3.5, we can use * and ** in more circumstances.3 Case 1. we are allowed to use them as many times as we want inside function calls foo, bar = {'a': 1, 'b': 2}, {'c': 3, 'd': 4} dict(**foo, **bar) # dict is a function {'a': 1, 'b': 2, 'c': 3, 'd': 4} üìíThe keys in a dictionary remain in a right-to-left priority order3. i.e. The later values will always override the earlier ones. See the following example: {**{'a': 1, 'b': 2}, **{'a': 3}} {'a': 3, 'b': 2} üìíWhen we use multiple ** in function calls. We need to make sure they have no duplicate keys. dict(**{'a': 1, 'b': 2}, **{'a': 3}) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) Cell In [7], line 1 ----\u003e 1 dict(**{'a': 1, 'b': 2}, **{'a': 3}) TypeError: dict() got multiple values for keyword argument 'a' Case 2. We can use them in tuple/list/set/dict literals. But we can‚Äôt use them inside the list/set/dict comprehensionsüò∫ # an example drawn from PEP 448 \u003e\u003e\u003e *range(4), 4 (0, 1, 2, 3, 4) \u003e\u003e\u003e [*range(4), 4] [0, 1, 2, 3, 4] \u003e\u003e\u003e {*range(4), 4} {0, 1, 2, 3, 4} \u003e\u003e\u003e {'x': 1, **{'y': 2}} {'x': 1, 'y': 2} {'x': 1, 'y': 2} matrix = [ [1, 2, 3] [4, 5, 6] ] [*sublist for sublist in matrix] Cell In [9], line 5 [*sublist for sublist in matrix] ^ SyntaxError: iterable unpacking cannot be used in comprehension ","date":"2022-12-05","objectID":"/unpacking-in-python/:2:2","tags":["Python"],"title":"Unpacking in Python 3.5","uri":"/unpacking-in-python/"},{"categories":["Python"],"content":"Wrap up The unpacking feature in python makes life easier. It‚Äôs an intuitive way to destructure the iterable object. With the help of this operator, we can avoid some silly indexErrorüôÖ ","date":"2022-12-05","objectID":"/unpacking-in-python/:3:0","tags":["Python"],"title":"Unpacking in Python 3.5","uri":"/unpacking-in-python/"},{"categories":["Python"],"content":"Refs Python iterators¬†‚Ü©Ô∏é PEP 3132. Extended Iterable Unpacking¬†‚Ü©Ô∏é PEP 448. Additional Unpacking Generalizations¬†‚Ü©Ô∏é¬†‚Ü©Ô∏é ","date":"2022-12-05","objectID":"/unpacking-in-python/:4:0","tags":["Python"],"title":"Unpacking in Python 3.5","uri":"/unpacking-in-python/"},{"categories":["Python"],"content":"A simple tutorial for the f-strings in python 3.6","date":"2022-11-16","objectID":"/f-strings-in-python/","tags":["Python"],"title":"f-strings in Python 3.6","uri":"/f-strings-in-python/"},{"categories":["Python"],"content":" This post is originally written in jupyter notebook and then convert to markdown. To get the original notebook files. Please check the repo ","date":"2022-11-16","objectID":"/f-strings-in-python/:0:0","tags":["Python"],"title":"f-strings in Python 3.6","uri":"/f-strings-in-python/"},{"categories":["Python"],"content":"Intro String formatting can be regarded as one of the most common activities in daily programming. We often need to output various strings and precisely control their format. In some outdated Python tutorials, you may see the use of % to format strings. However, after Python 3.6, f-strings have become the optimal choice for formatting strings. The advantages include: Expressions can be embedded in the string literals conveniently More human-readable The following simple comparison shows the advantages of f-strings in readability: name = \"Martin\" f\"My name is {name}\" 'My name is Martin' name = \"Martin\" \"My name is %s\" % name 'My name is Martin' We implemented the same string output in different ways. Without any effort, we can find that the f-strings here are to output the name (this requires you to use meaningful variables names, such as name here). On the contrary, it is slightly unnatural to look at the % format string. We first saw it use %s as a placeholder, then we need to go to the right to find out which variable it refers to. The example here is too short to show the real power of f-strings. Just trying to imagine that we are reading a long format string written in % syntax, we will need to look it back and forth to figure out what it means. Not just about reading the code, if you write a long format string by yourself, you have to check whether the order of the placeholders and variables is consistent, which is undoubtedly a burden. üò´ ","date":"2022-11-16","objectID":"/f-strings-in-python/:1:0","tags":["Python"],"title":"f-strings in Python 3.6","uri":"/f-strings-in-python/"},{"categories":["Python"],"content":"Syntax rules The syntax rules of f-strings are quite simple. I will just borrow the definition from1: f'\u003ctext\u003e{\u003cexpression\u003e\u003coptional !s, !r, or !a\u003e \u003coptional:format_specifier\u003e }\u003ctext\u003e...' In general, it can be summarized as f\"...\" or f'...'. Like regular strings in python, we can choose to use single quotes '' or double quotes \"\" to enclose the content of the string. Triple quotes - \"\"\"...\"\"\" is also available. As for the other parts, we divide them into several subsections: ","date":"2022-11-16","objectID":"/f-strings-in-python/:2:0","tags":["Python"],"title":"f-strings in Python 3.6","uri":"/f-strings-in-python/"},{"categories":["Python"],"content":"\u003ctext\u003e It means the string literals. The simplest usage scenario is a string without any expressions, which makes f-strings behave like regular strings. like f\"Hello world\". It would be an overkill if we just use f-strings to represent regular strings ","date":"2022-11-16","objectID":"/f-strings-in-python/:2:1","tags":["Python"],"title":"f-strings in Python 3.6","uri":"/f-strings-in-python/"},{"categories":["Python"],"content":"{\u003cexpression\u003e} Let‚Äôs consider the simplest form: {expression} without any option parts (\u003coption...\u003e in aforementioned grammar) The {\u003cexpression\u003e} shows how to embed an expression in f-strings: just put it inside {}. Here is a simple example: left, right = 3, 5 f\"{left} + {right} = {left + right}\" '3 + 5 = 8' Using {} as a placeholder naturally leads to a question-what if we want to output {} in the string. The answer is also very simple, we only need to use this format: {{expression}} # 'hello' is an expression too. # Note that we need to use different quote syntax inside {} f\"{{'hello'}}\" \"{'hello'}\" It is also worth mentioning that : and ! and \\ are not allowed in expression These characters rarely appear in expression though. One usage scenario of \\ is to escape quotes. However, we could just use a different type of quote inside the expression. As for :, a use case would be defining a lambda function in expression1. In this situation, we only need to enclose the lambda expression within (): # note that we need to add () around the lambda expression f\"{(lambda x: x + 1)(3)}\" '4' ","date":"2022-11-16","objectID":"/f-strings-in-python/:2:2","tags":["Python"],"title":"f-strings in Python 3.6","uri":"/f-strings-in-python/"},{"categories":["Python"],"content":"\u003coption...\u003e \u003coptional !s, !r, or !a\u003e These are used to perform type conversion on \u003cexpression\u003e {foo!s} # it's equal to call str(foo) first {foo!r} # similarily, call repr(foo) first {foo!a} # similarilyÔºåcall ascii(foo) first In fact, these three are redundant1. It is just for minimizing the differences with str.format() \u003coptional:format_specifier\u003e This part is to define how expression should be displayed, for example, control the precision of decimals, or do string alignment, etc.. Below I will briefly talk about some of them. For more detailed explanations, please refer to2 Note that this format_specifier begins with : (this explains why we are not allowed use : in expression) The grammar of format_specifier: [[fill]align][sign][z][#][0][width][,][grouping_option][.precision][type] In grammar, the [...] symbol means it is optional [[fill]align] This part is used to pad(specify a character with fill) the expression and do alignments. The fill here can be any character(defaults to a space). Note: We need to set minumul width by [width] when we declare [[fill]align] The various ways of alignment options: \u003c # left-aligned \u003e # right-aligned ^ # centered = # only valid for numeric types, pad between sign and digits f\"{-1:*^9}\" # set `fill` to *, and set width to 9 '***-1****' f\"{-1:*\u003e9}\" # set `fill` to *, and set width to 9 '*******-1' f\"{-1:*\u003c9}\" # set `fill` to *, and set width to 9 '-1*******' f\"{-1:*=9}\" # set `fill` to *, and set width to 9 '-*******1' [sign] It decides how the sign will be represented and is only valid for numerical values. + # both positive and negative - # only negative (default) space # a leading space for positive and minus sign for negative f\"{1:+}\" '+1' f\"{-1:+}\" '-1' assert f\"{1}\" == f\"{1:-}\" # because it's the default behavior [z] After Python 3.11, we can use z to handle negative zero(i.e. -0.). According to the PEP3, programmars usually will suppress negative zero. x = -0.0001 f\"{x:.1f}\" # set the precision to 1, so it will round to -0.0 '-0.0' x = -0.0001 f\"{x:z.1f}\" # with z, we will get 0.0 rather than -0.0 '0.0' [#] and [type] [#] is only valid for integer, float, and complex types. integer: add the respective prefix for the different base(radix) float and complex: always add a decimal-point even if no digits follow it How to interpret the numbers in the different bases(radixes)? It‚Äôs the [type]‚Äôs job: b # base 2 o # base 8 d # base 10 x # base 16, low-case letters X # base 16, upper-case letters f\"{15:#b}\" # represent 15 in base 2, use # to add prefix 0b '0b1111' f\"{15:#X}\" # represent 15 in base 16, use # to add prefix 0X '0XF' f\"{3:.0f}\" '3' f\"{3:#.0f}\" '3.' [0][width] we set the minimal width by setting the width. If we also add the prefix 0 here, it means we will use 0 to pad the rest part. f\"{123:5}\" # width 5 ' 123' f\"{123:05}\" # width 5 with leading 0 '00123' f\"{123.1:5}\" # Note: the width includes the decimal point char '123.1' [grouping_option] Specify the thousands separators. Two options available45Ôºö _ , Both separators will make the long numbers more human-readable. f\"{123456789:,}\" '123,456,789' f\"{1234.56789:,}\" '1,234.56789' f\"{123456789:_}\" '123_456_789' f\"{1234.56789:_}\" '1_234.56789' [.precision] How many digits should be displayed after the .? f\"{123.456:.2f}\" '123.46' ","date":"2022-11-16","objectID":"/f-strings-in-python/:2:3","tags":["Python"],"title":"f-strings in Python 3.6","uri":"/f-strings-in-python/"},{"categories":["Python"],"content":"Wrap up When I start to learn python a long time ago, most of the tutorials says we should use % to format strings. After str.format appears, it became a better choice and outdated the % syntax. F-strings, released with python 3.6, has become the best practice now.üöÄ It meets the zen of python - There should be one‚Äì and preferably only one ‚Äìobvious way to do it ","date":"2022-11-16","objectID":"/f-strings-in-python/:3:0","tags":["Python"],"title":"f-strings in Python 3.6","uri":"/f-strings-in-python/"},{"categories":["Python"],"content":"Refs PEP 498 ‚Äì Literal String Interpolation¬†‚Ü©Ô∏é¬†‚Ü©Ô∏é¬†‚Ü©Ô∏é Format Specifications¬†‚Ü©Ô∏é PEP 682 ‚Äì Format Specifier for Signed Zero¬†‚Ü©Ô∏é PEP 378 ‚Äì Format Specifier for Thousands Separator¬†‚Ü©Ô∏é PEP 515. Underscores in Numeric Literals¬†‚Ü©Ô∏é ","date":"2022-11-16","objectID":"/f-strings-in-python/:4:0","tags":["Python"],"title":"f-strings in Python 3.6","uri":"/f-strings-in-python/"},{"categories":["Python"],"content":"A simple tutorial for the walrus operator in python 3.8","date":"2022-10-29","objectID":"/walrus-operator-in-python/","tags":["Python"],"title":"Walrus Operator in Python 3.8","uri":"/walrus-operator-in-python/"},{"categories":["Python"],"content":" This post is originally written in jupyter notebook and then convert to markdown. To get the original notebook files. Please check the repo ","date":"2022-10-29","objectID":"/walrus-operator-in-python/:0:0","tags":["Python"],"title":"Walrus Operator in Python 3.8","uri":"/walrus-operator-in-python/"},{"categories":["Python"],"content":"Intro Today I‚Äôm going to talk about a new feature introduced in Python 3.8: the Walrus operatorÔºà:=Ôºâ, which is a much-debated feature, but it‚Äôs finally passed and released ü§î In Python, an assignment statement (=) is not an expression but a statement. Walrus operator is expression though. The difference between statement and expression can be simply understood as: expression always returns a value, while statement does not return a value. The difference between the two can be seen in the following code: # `=` is a statement, so it will print no value x = 5 # `:=` is an expression, so it will evaluate to a value # not recommended :) (x := 5) 5 üìí The () needs to be added to avoid confusion. According to the Zen of Python: ‚ÄúThere should be one‚Äì and preferably only one ‚Äìobvious way to do it.‚Äù. If we can use it without (), we definitely will be confused about which one to use ü§ïÔ∏è In C/C++, = is an expression. We can write this: // = will store the value in the LHS(left-hand-side) variable. // , and it has the value of the LHS // so we store the result of `foo` function call to `a` // , then we check if `a` \u003e 0 while ( (a = foo(...)) \u003e 0 ) { ... } Before Python 3.8, it was not possible to do something similar. Because the = is a statement. This is where the walrus expression comes into play ü§© ","date":"2022-10-29","objectID":"/walrus-operator-in-python/:1:0","tags":["Python"],"title":"Walrus Operator in Python 3.8","uri":"/walrus-operator-in-python/"},{"categories":["Python"],"content":"Syntax rules The syntax of walrus expressions is quite simple: NAME := EXPRESSION. := assigns the value of EXPRESSION to NAME. we are not allowed to use attributes or subscripts as NAME. See the code below # a dummy example. we bind `1 + 2 + 3` to `res` for future usage if (res := 1 + 2 + 3) \u003e 5: print(f\"res is {res}\") res is 6 class foo: val: int = 0 some_foo = foo() (some_foo.val := 1) Input In [4] (some_foo.val := 1) ^ SyntaxError: cannot use assignment expressions with attribute x = [1, 2, 3] (x[1] := 3) Input In [5] (x[1] := 3) ^ SyntaxError: cannot use assignment expressions with subscript The scope of NAME Walrus expressions do not introduce new scopes ü§© NAME can be used in the current scope, with one exception: if it is used inside a list/dict/set comprehension. We can use NAME in the enclosing scope. See the following example: s = [1, 2, 3] # the list comprehension forms a new scope. # its enclosing scope is the global scope double_s = [item * 2 for item in s] # `item` is not in the global scope :) print(item) --------------------------------------------------------------------------- NameError Traceback (most recent call last) Input In [6], in \u003ccell line: 7\u003e() 4 double_s = [item * 2 for item in s] 6 # `item` is not in the global scope :) ----\u003e 7 print(item) NameError: name 'item' is not defined s = [1, 2, 3] # the list comprehension forms a new scope. # its enclosing scope is the global scope double_s = [last := item * 2 for item in s] # so we can use `last` variable here print(last) Order of evaluation: lower than others except the comma(,) x = 1, 2 x (1, 2) (x := 1, 2) x 1 ","date":"2022-10-29","objectID":"/walrus-operator-in-python/:2:0","tags":["Python"],"title":"Walrus Operator in Python 3.8","uri":"/walrus-operator-in-python/"},{"categories":["Python"],"content":"Usage üìí Combined with the content of 1 and my personal programming experience. The most convenient thing about walrus expressions is: dealing with functions whose return value may be None To deal with functions that may return None, we will usually first use the = statement to save the return result of the function. Then we check if it is None so we can refer to it later safely some_thing = foo(....) if some_thing: ... else: ... I will use the re as an example import re # define a regex pattern to extract digits in a string DIGIT_PATTERN = r'\\d+' text = 'There are 10 dogs' # re.search will return None if no match was found. match = re.search(DIGIT_PATTERN, text) if match: # group(0) will return the entire match print(f\"Find match: {match.group(0)}\") else: print(\"Not match was found\") Find match: 10 To avoid getting an AttributeError: 'NoneType' object has no attribute 'group' error when using match.group() later, we have to use an intermediate variable match to temporarily hold the return value rather then chain them together: re.search(DIGIT_PATTERN, text).group(0). It may seem kind of redundant though. üìí In Rust, the return type that may return None is called Option\u003cT\u003e. We can use ? to handle this situation, it will try to extract the value inside, and if it fails it will terminate early with an error. So in Rust, we can do this (assuming Rust has a similar API): re.search(DIGIT_PATTERN, text)?.group(0) üç∫ The readability is slightly weaker in my opinion, of course, this is quite personal. i.e. We can only use the match variable when match is not None. There is no chance to use it inside the else branch. However, if we look at the code from the top down quickly, match = ... on a separate line is like the match can be used later everywhere ü§£ Instead, we can use := to bind its return value here: if match := re.search(DIGIT_PATTERN, text): # group(0) will return the entire match print(f\"Find match: {match.group(0)}\") else: print(\"Not match was found\") Find match: 10 1 One of the reasons for supporting := is that research shows that developers tend to write fewer lines of code rather than shorter code. That‚Äôs what we did here. At the same time, we can see the scope of match at a glance üëè Similarly, we can use this feature in while loops too: val = foo(...) while val: # do something while val is not None val = foo(...) ","date":"2022-10-29","objectID":"/walrus-operator-in-python/:3:0","tags":["Python"],"title":"Walrus Operator in Python 3.8","uri":"/walrus-operator-in-python/"},{"categories":["Python"],"content":"üÜö = A few differences worth mentioning: = is a statement, := is an expression. This also determines their application scenarios. Only = supports the continuous use of foo = bar = 1; and the left side of = can be an attribute like foo.bar, or an subscript like foo[1], but := can only be a simple variable name on the left = supports the augmented form of +=, but := does not ","date":"2022-10-29","objectID":"/walrus-operator-in-python/:4:0","tags":["Python"],"title":"Walrus Operator in Python 3.8","uri":"/walrus-operator-in-python/"},{"categories":["Python"],"content":"Wrap up In my opinion, the walrus operator is quite useful in the aforementioned scenarios (Recommended üëç), and the readability is much improved üöÄ. But some examples in 1 just make me more confused ","date":"2022-10-29","objectID":"/walrus-operator-in-python/:5:0","tags":["Python"],"title":"Walrus Operator in Python 3.8","uri":"/walrus-operator-in-python/"},{"categories":["Python"],"content":"Refs PEP 572. Assignment Expressions¬†‚Ü©Ô∏é¬†‚Ü©Ô∏é¬†‚Ü©Ô∏é ","date":"2022-10-29","objectID":"/walrus-operator-in-python/:6:0","tags":["Python"],"title":"Walrus Operator in Python 3.8","uri":"/walrus-operator-in-python/"},{"categories":["Python"],"content":"The tutorial about the pattern matching in Python 3.10","date":"2022-10-16","objectID":"/pattern-matching-in-python/","tags":["Python"],"title":"Pattern Matching in Python 3.10","uri":"/pattern-matching-in-python/"},{"categories":["Python"],"content":" This post is originally written in jupyter notebook and then convert to markdown. To get the original notebook files. Please check the repo ","date":"2022-10-16","objectID":"/pattern-matching-in-python/:0:0","tags":["Python"],"title":"Pattern Matching in Python 3.10","uri":"/pattern-matching-in-python/"},{"categories":["Python"],"content":"Intro Today I want to talk about the new feature bring in Python 3.10 ‚Äì Pattern matching üéâ Those who have learned C language must be familiar with the following switch statement: switch (expression) { case constant_1: // statements break; case constant_2: // statements break; // Fall through // the value of the expression can be either constant_3 or constant_4 :) case constant_3: case constant_4: // statements default: // default statements } To recap, the syntax rules of the switch statement: expression should be the int or char type. constant should be the int or char constant The execution process of the switch statement: Calculate the value of expression, and compare this value with each constant from top to bottom. If they are equal, the statements inside the specific case and all the case after the matched case will be executed, unless it finds a break statement. This feature is called Fall through, and we can use this feature to stack multiple case statements together to represent a logical ‚Äúor‚Äù relationship The default branch will be executed when all the previous case branches fail to match Python does not provide a switch statement, but we can use if...elif..elif..else to achieve the same effect, for example, suppose we want to perform different operations depending on the length of the list, We can write this: some_list = [1, 2, 3, 4, 5] if len(some_list) == 1: # do something when the length is 1 ... # or more pythonic way: elif len(some_list) in [3, 5]: elif len(some_list) == 3 or len(some_list) == 5: # do something when the length is 3 or 5 ... else: ... The above series of if...elif..elif..else is actually slightly less readable, and it also violates the DRY(Don‚Äôt repeat yourself) principle, we write len(some_list) many times. Of course, we can choose to use a variable length to remember the length of some_list first, so that we can type less code. However, if the situation is more complicated, this trick is not applicable. A more elegant way to handle this situation is what this article is about: Pattern matching ‚¨áÔ∏è match len(some_list): case 1: # do something when the length is 1 ... case 3 | 5: # do something when the length is 3 or 5 ... case _: # equal to the `default:` ... ","date":"2022-10-16","objectID":"/pattern-matching-in-python/:1:0","tags":["Python"],"title":"Pattern Matching in Python 3.10","uri":"/pattern-matching-in-python/"},{"categories":["Python"],"content":"Syntax rules The syntax of the pattern matching is: match subject: case \u003cpattern_1\u003e: \u003caction_1\u003e case \u003cpattern_2\u003e: \u003caction_2\u003e case \u003cpattern_3\u003e: \u003caction_3\u003e # [Optional] wildcard to cover all situations case _: \u003caction_wildcard\u003e Syntactically, it is similar to the aforementioned switch statement in C. The differences are: There is no fall through in pattern matching. Only the code inside the matched case branch will be executed. So we don‚Äôt need to add a break statement at the end of each case block No default available. But we can use case _ to capture all cases, which is called the Wildcard pattern that will be discussed later The subject and pattern here are much more powerful than the C language, not only the integer and char types, but pattern can also be combined and nested with each other. It will be explained in detail later ","date":"2022-10-16","objectID":"/pattern-matching-in-python/:2:0","tags":["Python"],"title":"Pattern Matching in Python 3.10","uri":"/pattern-matching-in-python/"},{"categories":["Python"],"content":"Patterns In pattern matching, a pattern basically does two things: Structure constraints: we can add constraints to the subject in various ways. For example the length, the specific value in a specific position, etc Bind variables: we can bind some names in the pattern to component elements of the subject. See the Capture pattern below. Below I discuss different patterns :) To avoid confusion, it‚Äôs worth explaining in advance that both () and [] are optional when pattern matching matches a sequence. For example, case foo, bar and case (foo, bar) and case [foo, bar] are equivalent. They have the same meaning. ","date":"2022-10-16","objectID":"/pattern-matching-in-python/:3:0","tags":["Python"],"title":"Pattern Matching in Python 3.10","uri":"/pattern-matching-in-python/"},{"categories":["Python"],"content":"Capture pattern Capture pattern means that when we check whether a pattern matches, we can use variable names to bind to any part of it, and we can use these variables later some_list = [\"foo\", \"bar\"] match some_list: # we want to match a seq which has length = 2 # , we also use `first` and `second` to capture \\ # the 1st and 2nd elements here. case [first, second]: # we can access first, second now print(f'the 1st element: {first}, 2nd element: {second}') the 1st element: foo, 2nd element: bar People who often deal with sequences must be familiar with the following code: *before, last = [1, 2, 3, 4] assert last == 4, \"Error\" first, *middle, last = [1, 2, 3, 4] assert first == 1 and last == 4, \"Error\" first, *rest = [1, 2, 3, 4] assert first == 1, \"Error\" Similarly, we can do this in pattern matching: some_list = [\"foo\", \"bar\", \"another_foo\", \"another_bar\"] match some_list: # we want to match a seq # , we also use `*rest` to capture the remaining elements case [first, *rest]: print(f'the 1st element: {first}, 2nd element: {rest}') the 1st element: foo, 2nd element: ['bar', 'another_foo', 'another_bar'] ","date":"2022-10-16","objectID":"/pattern-matching-in-python/:3:1","tags":["Python"],"title":"Pattern Matching in Python 3.10","uri":"/pattern-matching-in-python/"},{"categories":["Python"],"content":"Literal pattern Literal pattern means that we can specify literal values in specific positions. The literals here can be number literals, string literals, True, False, and None üìí Note: For number literals and string literals, python will use == for comparison, and for True/False/None these three will use is. some_list = [\"foo\", \"bar\"] match some_list: # we want to match a seq which has length = 2 # , the 1st element should be equal to \"foo\" # , and we use `second` to capture the 2nd element case [\"foo\", second]: print(f'the 2nd element: {second}') the 2nd element: bar some_list = [True] match some_list: case [1]: print(f'Matched, 1 == True') Matched, 1 == True ","date":"2022-10-16","objectID":"/pattern-matching-in-python/:3:2","tags":["Python"],"title":"Pattern Matching in Python 3.10","uri":"/pattern-matching-in-python/"},{"categories":["Python"],"content":"Wildcard pattern It is a common practice in python that: use _ to indicate that we don‚Äôt care about the value. Similarly, _ can be used here, and it will not bind any variables some_list = [\"foo\", \"bar\"] match some_list: # we want to match a seq which has length = 2 # , the 1st element should be equal to \"foo\" # , and we use `_` to ignore the 2nd value case [\"foo\", _]: print(f'the 2nd value: {_}') # you should see empty output because we aren't binding value here the 2nd value: Another common usage is the case _ that appeared before. The _ will match everything, so case _ is often put at the end to indicate the default case some_list = [\"foo\", \"bar\"] match some_list: # this case branch will not be matched case [\"bar\", _]: print('Match successfully') case _: print('Default case') Default case ","date":"2022-10-16","objectID":"/pattern-matching-in-python/:3:3","tags":["Python"],"title":"Pattern Matching in Python 3.10","uri":"/pattern-matching-in-python/"},{"categories":["Python"],"content":"Or pattern Just like in the if statement we can use or, in pattern matching we also have a similar syntax. Like most other languages, Python chooses to use | to express an ‚Äúor‚Äù logical relationship. We can declare the alternatives conveniently some_list1 = [\"foo\"] some_list2 = [\"bar\"] match some_list1: # we want to match a seq which has length = 1 # , the 1st element can be \"foo\" or \"bar\" case [\"foo\" | \"bar\"]: print('[First match] Match foo or bar') match some_list2: case [\"foo\" | \"bar\"]: print('[Second match] Match foo or bar') [First match] Match foo or bar [Second match] Match foo or bar The disadvantage of the Or pattern above is that we have no way of knowing which one we matched exactly ","date":"2022-10-16","objectID":"/pattern-matching-in-python/:3:4","tags":["Python"],"title":"Pattern Matching in Python 3.10","uri":"/pattern-matching-in-python/"},{"categories":["Python"],"content":"As pattern In the previous example, we may match any of the alternatives, so how do we know which one we match? Because we may need to decide what to do based on which one is matched. In pattern matching, we can use as to bind a value some_list = [\"foo\"] match some_list: # we want to match a seq which has length = 1 # , the 1st element can be \"foo\" or \"bar\" # we bind matched string literal with `matched_element` case (\"foo\" | \"bar\") as matched_element: print(f'Match {matched_element}') ","date":"2022-10-16","objectID":"/pattern-matching-in-python/:3:5","tags":["Python"],"title":"Pattern Matching in Python 3.10","uri":"/pattern-matching-in-python/"},{"categories":["Python"],"content":"Class pattern Python is a dynamically typed language, and sometimes we need to decide whether to match based on the type. The intuitive way is using isinstance() to check if it is qualified, but there is a better way. Next, I will show you how to add type constraints step by step: some_list = [\"foo\", 1, 3.14] match some_list: # match without type constraints case [s, v1, v2]: if isinstance(s, str) and isinstance(v1, int) and isinstance(v2, float): print(f'Match {s} - {v1} - {v2}') Match foo - 1 - 3.14 The intuitive way: we use the Capture pattern to bind values, and use isinstance to check the type in the code block some_list = [\"foo\", 1, 3.14] match some_list: # match with type constraints case [str() as s, int() as v1, float() as v2]: print(f'Match {s} - {v1} - {v2}') Match foo - 1 - 3.14 The syntax here is quite similar to the previous Literal pattern + As pattern. i.e. We declare the type we want to match in the corresponding position. At the same time, we use the as keyword to bind the value. Less typing but still less elegant :(. Fortunately, python provides us with syntactic sugar üç¨ some_list = [\"foo\", 1, 3.14] match some_list: # match with type constraints case [str(s), int(v1), float(v2)]: print(f'Match {s} - {v1} - {v2}') Match foo - 1 - 3.14 ","date":"2022-10-16","objectID":"/pattern-matching-in-python/:3:6","tags":["Python"],"title":"Pattern Matching in Python 3.10","uri":"/pattern-matching-in-python/"},{"categories":["Python"],"content":"Mapping pattern The previous ones are all matching against a sequence, here we are matching against the dict. I believe that after reading the previous examples, it is not difficult to understand the following example. But there are a few things to keep in mind: we match dict based on its present keys. The keys here must be a literal value or a value of enum type (for performance considerations), values do not have this restriction we can use **\u003cname\u003e to capture the key-value pair we didn‚Äôt write in pattern. Otherwise the undeclared key-value pairs will be ignored some_dict = { 'first_name': 'foo', 'second_name': 'bar' } match some_dict: case {'first_name': first_name}: print(f'[First match] The first_name: {first_name}') match some_dict: case {'first_name': first_name, **rest}: print(f'[Second match] The rest: {rest}') [First match] The first_name: foo [Second match] The rest: {'second_name': 'bar'} ","date":"2022-10-16","objectID":"/pattern-matching-in-python/:3:7","tags":["Python"],"title":"Pattern Matching in Python 3.10","uri":"/pattern-matching-in-python/"},{"categories":["Python"],"content":"Value pattern It‚Äôs good practice to use ‚Äúnamed variables‚Äù as parameter values or to clarify the meaning of specific values. e.g. case (HttpStatus.OK, body) is better than case (200, body) The challenge of implementing the Value pattern in Python is to distinguish it from the previous Capture pattern. A discussion of this can be found at 1 The final solution provided by python is a restricted Value pattern that only supports Value pattern of the form foo.bar. Common usage will be combined with the enum type, see the following example from enum import Enum class HttpStatusCode(Enum): CONTINUE = 100 OK = 200 some_list = [HttpStatusCode[\"OK\"]] match some_list: case [HttpStatusCode.OK as status_code]: print(f\"Receive {status_code}\") Receive HttpStatusCode.OK ","date":"2022-10-16","objectID":"/pattern-matching-in-python/:3:8","tags":["Python"],"title":"Pattern Matching in Python 3.10","uri":"/pattern-matching-in-python/"},{"categories":["Python"],"content":"Use pattern matching on a class If we can only use pattern matching on built-in types, it doesn‚Äôt seem to be that useful. But in fact, Python also allows us to use pattern matching on objects of our own custom classes. Considering the application scenario, when we use pattern matching on an object, we often want to check whether the object is a certain class type. We may also care about some of its fields and want to extract the values. But in Python, this is difficult to implement1, mainly because the class has a lot of fields, most of which are special methods like __repr__, and these fields are unordered. Because it is unordered, we can‚Äôt directly bind variables by position in pattern, see the following example: class Point: \"\"\" A simple class represents a Point in a 2D\"\"\" def __init__(x: int, y: int): self.x = x self.y = y some_point = Point(1, 2) match some_point: # the intuitive way, we want to match a Point type # , and we want to bind the `x` and `y` and their two fields respectively case Point(x, y): print(f\"The x: {x}\") print(f\"The y: {y}\") --------------------------------------------------------------------------- TypeError Traceback (most recent call last) Input In [17], in \u003ccell line: 7\u003e() 4 self.x = x 5 self.y = y ----\u003e 7 some_point = Point(1, 2) 9 match some_point: 10 # the intuitive way, we want to match a Point type 11 # , and we want to bind the `x` and `y` and their two fields respectively 12 case Point(x, y): 13 print(f\"The x: {x}\") 14 print(f\"The y: {y}\") TypeError: Point.__init__() takes 2 positional arguments but 3 were given Python provides two solutions, which are syntactically very similar to calling a function: we can choose to pass arguments by position, or we can choose to use the form foo=bar Let‚Äôs talk about the simple one first: add constraints by using foo=bar, which means that the object should have a field called foo and we want to bind bar to it. class Point: \"\"\" A simple class represents a Point in a 2D\"\"\" def __init__(self, x: int, y: int): self.x = x self.y = y some_point = Point(1, 2) match some_point: # the intuitive way, we want to match a Point type # , and we want to bind the `x` and `y` and their two fields respectively case Point(x=x, y=y): print(f\"The x: {x}\") print(f\"The y: {y}\") The x: 1 The y: 2 Another solution is to modify the __match_args__ attribute of the class, which specifies the order of the fields class Point: \"\"\" A simple class represents a Point in a 2D\"\"\" # we tell python that the order is first \"x\" and then \"y\" __match_args__ = (\"x\", \"y\") def __init__(self, x: int, y: int): self.x = x self.y = y some_point = Point(1, 2) match some_point: # the intuitive way, we want to match a Point type # , and we want to bind the `x` and `y` and their two fields respectively case Point(x, y): print(f\"The x: {x}\") print(f\"The y: {y}\") The x: 1 The y: 2 if you are familiar with @dataclass2, you can do this: from dataclasses import dataclass @dataclass(match_args=True) class Point: \"\"\" A simple class represents a Point in a 2D\"\"\" x: int y: int print(f\"The order is {Point.__match_args__}\") some_point = Point(1, 2) match some_point: # the intuitive way, we want to match a Point type # , and we want to bind the `x` and `y` and their two fields respectively case Point(x, y): print(f\"The x: {x}\") print(f\"The y: {y}\") The order is ('x', 'y') The x: 1 The y: 2 ","date":"2022-10-16","objectID":"/pattern-matching-in-python/:4:0","tags":["Python"],"title":"Pattern Matching in Python 3.10","uri":"/pattern-matching-in-python/"},{"categories":["Python"],"content":"Guard Sometimes we not only care about whether the pattern matches, but we also want to impose certain restrictions. Consider such a situation where we want to match a sequence containing two int values, but we require the first element shoudld be larger than the second. How would you write it? Combined with the previous Class pattern, it is not difficult for us to write the following code: some_list = [3, 4] match some_list: case [int(first), int(second)]: if first \u003e second: ... else: print(\"Expect first \u003e second. Match failed\") Expect first \u003e second. Match failed The above solution is fine, we definitely can use the if statement in the code block to add constraints. But just like type constraints, Python has taken this requirement into account, so it provides a Guard üíÇ‚Äç‚ôÄÔ∏è mechanism, which allows us to move the if statement to the end of the pattern for readability. The syntax rules to follow: match subject: case \u003cpattern\u003e if \u003cexpression\u003e: ... \u003cpattern\u003e followed by an if statement Note how python evaluates this here: Check if \u003cpattern\u003e matches If it matches, bind values if we declared Check if the if \u003cexpression\u003e statement returns True. The \u003cexpression\u003e here can use the previously bound variable in step 2 The code inside the code block will be executed if and only if \u003cpattern\u003e matches + if statement returns True. Otherwise, it will fail and try to match the next \u003cpattern\u003e some_list = [3, 4] match some_list: case [int(first), int(second)] if first \u003e second: print(\"Match successfully!\") ","date":"2022-10-16","objectID":"/pattern-matching-in-python/:5:0","tags":["Python"],"title":"Pattern Matching in Python 3.10","uri":"/pattern-matching-in-python/"},{"categories":["Python"],"content":"Wrap up I would prefer pattern matching to the if...elif...elif...else for several reasons: We can easily bind values for subsequent processing when matching For better readabilityg The various patterns of pattern matching can actually be nested and combined, that‚Äôs what makes pattern matching a shining point. The above is a brief introduction to pattern matching introduced in Python 3.10 üöÄ ","date":"2022-10-16","objectID":"/pattern-matching-in-python/:6:0","tags":["Python"],"title":"Pattern Matching in Python 3.10","uri":"/pattern-matching-in-python/"},{"categories":["Python"],"content":"Refs PEP 635 ‚Äì Structural Pattern Matching: Motivation and Rationale¬†‚Ü©Ô∏é¬†‚Ü©Ô∏é dataclasses - documentation¬†‚Ü©Ô∏é ","date":"2022-10-16","objectID":"/pattern-matching-in-python/:7:0","tags":["Python"],"title":"Pattern Matching in Python 3.10","uri":"/pattern-matching-in-python/"},{"categories":["System-Programming"],"content":"the differences between the stack and the heap","date":"2022-09-19","objectID":"/what-is-the-heap-and-stack/","tags":["System-programming"],"title":"What is stack and heap","uri":"/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"Intro If you‚Äôve been using dynamic languages like Python, Javascript, etc., you probably won‚Äôt notice the difference between stack and heap. Because these languages have garbage collectors (GCs) that will automatically manage memory for you, you just need to program at a high level without considering the details. The bad news is that GC is not a cost-free design. No matter how well designed a GC algorithm is, the performance of the code will be degraded to some extent. If you have been in programming for a long time, you may have heard something like ‚Äúthe recursion explodes the stack‚Äù. You may or may not click on the search engine to understand the difference between stack and heap. Chances are you just clicked into this article :) üìí Although GC will degrade the performance, it removes the mental burden of manually managing memory for developers, which can greatly speed up software development. This is sacrificing performance for development speed. However, when the performance bottleneck occurs in the later stage of the software, it is necessary to study how to refactor or even rewrite the key parts of code to improve performance. The stack and heap I mentioned here are not the heap and stack in the data structure, but the two mechanisms of memory management. Understanding the detailed differences between stack and heap helps us understand some programming languages that are closer to the low-level, such as Rust, C, C++, etc. In Rust, the most important concept is ownership. Mastering the ownership can make you feel easier when you are learning other designs in rustüòÑ. ","date":"2022-09-19","objectID":"/what-is-the-heap-and-stack/:1:0","tags":["System-programming"],"title":"What is stack and heap","uri":"/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"The layout of a program in memory To run a program, it must be loaded into the memory. During the process of the program running, the data also needs to be read into the memory, so have you ever wondered how all this is distributed in the memory? I will give you a rough illustration below1: In the image above, the meanings of different parts: text: store code data: store the initialized static variables. such as global variable, static variable bss: store the uninitialized static data, such as the declaration static int i in C heap stack What is stored on the heap and stack will be discussed later. üìí The thing to remember here is that the stack and the heap are moving closer to each other as they are growing. The stack grows from high address -\u003e low address, and the heap grows from low address -\u003e high address. After understanding this, you will get a better understanding when you see that the sp pointer is got subtracted in the assembly code. üìí It seems that as we allocate more and more memory, the stack and heap may collide (because they are getting closer to each other). However, there is no need to worry about this problem, because: 1) This layout is happening in virtual memory. Today‚Äôs processors are generally 64-bit, and the capacity is very large. 2) Before the conflict, it is very likely that your physical memory has been exhausted long ago, this should be your first concern. ","date":"2022-09-19","objectID":"/what-is-the-heap-and-stack/:2:0","tags":["System-programming"],"title":"What is stack and heap","uri":"/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"Stack ","date":"2022-09-19","objectID":"/what-is-the-heap-and-stack/:3:0","tags":["System-programming"],"title":"What is stack and heap","uri":"/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"Terms Stack pointer(SP): the value of a specific register, which stores the address of the top of the stack Stack frame: created as function calls are made, it is a frame of data(for one function call) that gets pushed onto the stack. push: allocating space on the stack pop: free space on the stack ","date":"2022-09-19","objectID":"/what-is-the-heap-and-stack/:3:1","tags":["System-programming"],"title":"What is stack and heap","uri":"/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"stack allocation The biggest feature of the stack is the last in first out (LIFO), which is also the pattern we follow when allocating and freeing space on the stack. Allocating space on the stack is quite simple, we just need to modify the value of the stack pointer. Naturally, from the bottom of the stack (A in the figure below) to the top of the stack (the position pointed to by sp) is the space we have allocated. The following figure1 shows the simple logic behind: It should be emphasized again here that the stack grows from high address -\u003e low address, so from left to right in the above figure is high address -\u003e low address. How does the function call work(simplified version)? Function call: subtract the value of sp -\u003e construct the stack frame for the called function, push them to the stack -\u003e enter the callee Function exit: just reverse the above process The full procedure of function call can be found on 2 üìí The problem to be worried about when allocating space on the stack is: do not keep allocating which causes the stack to blow up (that is, the famous Stack Overflow problem). Keep this in mind when writing recursive functions. You can choose to implement the function in an iterative way or consider increasing the size limit of the stack. For example, in Python, you can use sys.getrecursionlimit() to modify the size limit of the stack. In some programming languages, we can also change the recursive function to the tail recursion version, which can benefit from the optimizations. ","date":"2022-09-19","objectID":"/what-is-the-heap-and-stack/:3:2","tags":["System-programming"],"title":"What is stack and heap","uri":"/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"An example: fibonacci sequence When explaining recursion in CS courses, we usually use the Fibonacci sequence as an example. Now we use F(n) to represent the nth value of the Fibonacci sequence, then the formulas are: F(0) = 0 F(1) = 1 F(n) = F(n - 1) + F(n - 2) Take F(4) as the example, the process of the recursive function call is as follows: F(4) = F(3) + F(2) = F(2) + F(1) + F(1) + F(0) = F(1) + F(0) + F(1) + F(1) + F(0) = 3 * F(1) + 2 * F(0) If we ignore some details and illustrate the changes in the stack, it will look like this: ps: the F(n) is a stack frame stack: F(4) stack: F(4) | F(3) # F(4): enter F(3) stack: F(4) | F(3) | F(2) # F(3): enter F(2) stack: F(4) | F(3) | F(2) | F(1) # F(2): enter F(1), F(1) is the base case, ready to exit function call stack: F(4) | F(3) | F(2) # Function return, return to the body of F(2) stack: F(4) | F(3) | F(2) | F(0) # F(2): enter F(0), F(0) is the base case, ready to exit function call stack: F(4) | F(3) | F(2) # Function return, return to the body of F(2) stack: F(4) | F(3) | F(1) # F(3): enter F(1), F(1) is the base case, ready to exit function call stack: F(4) | F(3) # Function return, return to the body of F(3) stack: F(4) # Function return, return to the body of F(4) stack: F(4) | F(2) # F(4): enter F(2) stack: F(4) | F(2) | F(1) # F(2): enter F(1), F(1) is the base case, ready to exit function call stack: F(4) | F(2) # Function return, return to the body of F(2) stack: F(4) | F(2) | F(0) # F(2): enter F(0), F(0) is the base case, ready to exit function call stack: F(4) | F(2) # Function return, return to the body of F(2) stack: F(4) # Function return, return to the body of F(4) ","date":"2022-09-19","objectID":"/what-is-the-heap-and-stack/:3:3","tags":["System-programming"],"title":"What is stack and heap","uri":"/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"The data on the stack Memory space management on the stack is achieved by modifying the value of the sp pointer, so we can conclude that: It is very efficient when allocating or freeing the space on the stack. We can think of it as O(1) complexity. The logic of this LIFO of the stack is relatively simple. The compiler can shandle it for us. As developers, we do not need to intervene in this process. To modify the sp pointer, we need to know how much space will be used, so the data on the stack should be a fixed and known size(at compile time). As for data of variable size, this is the problem to be solved by the heap. ","date":"2022-09-19","objectID":"/what-is-the-heap-and-stack/:3:4","tags":["System-programming"],"title":"What is stack and heap","uri":"/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"Heap The disadvantage of the stack allocation is: it can not handle variable size data, and we can‚Äôt know how much the value of sp needs to be modified at this time. How do you bridge the gap between variable-sized data and stack? This requires the use of pointers. Although the size of the actual data stored is unknown, the size of the pointer is fixed (usually, it is equal to the word size of the underlying machine), so we can store a fixed-size pointer on the stack, let it point to the real data stored on the heap. ","date":"2022-09-19","objectID":"/what-is-the-heap-and-stack/:4:0","tags":["System-programming"],"title":"What is stack and heap","uri":"/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"Heap allocation As mentioned earlier, allocating memory on the heap is finding a large enough space on the heap, returning a pointer to this location, and then pushing the pointer onto the stack. Later, when we want to access this data, we can dereference the pointer. The * operator in C or Rust is used for this purpose. Hopefully understanding this will make it easier for you to learn pointers. :) Unlike simply modifying the sp value on stack allocation, memory management on the heap is much more complicated. Including the following points: The location and size of the memory that can be allocated on the heap are arbitrary (within the physical memory size limit), we need to invent some algorithm and data structure to trace the usage. This brings great difficulties to memory management on the heap. The efficiency of allocating space on the heap is also relatively low. We need to find a space of sufficient size. This process of finding is more time-consuming than directly modifying the value of sp. We must also deal with the problem of ‚Äúfragmentation‚Äù. Because the allocated space on the heap is scattered everywhere, a lot of fragments will be left in the memory in the process of heap allocation. The extreme case is: the total size of the fragments meets your requirements, but because they are scattered all over the memory and cannot be used together, the program throws an out-of-memory warning. üìí The memory that can be allocated on the heap is way larger than the stack, but better management mechanisms are needed to handle this more complex situation. For developers, it also causes a certain burden. We can‚Äôt rely on the compiler to automatically handle it for us, we have to manage the memory manually. If you forget to call free() after allocating space, then your program will have a memory leak problem. Not to mention other issues such as dangling pointers and double-free. ","date":"2022-09-19","objectID":"/what-is-the-heap-and-stack/:4:1","tags":["System-programming"],"title":"What is stack and heap","uri":"/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"The data on the heap After having a certain understanding of the allocation of memory space on the heap, it is not difficult for us to draw the following conclusions: Variable-size data is stored on the heap. More flexibility at the expense of a little performance Sometimes it can be fixed-size data, but you don‚Äôt want to put it on the stack. Why is this the case? For example, in Rust, data on the stack is copied by default. Sometimes for performance considerations, you may want to put large data on the heap to avoid the overhead of multiple copies. I don‚Äôt know if this reminds you of the optimization that we often did. i.e. passing function parameter by reference rather than value. ","date":"2022-09-19","objectID":"/what-is-the-heap-and-stack/:4:2","tags":["System-programming"],"title":"What is stack and heap","uri":"/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"Wrap up Stack and heap are concepts in memory management, they are different from the concept of stack and heap in the data structure. The reason why the stack is called the stack is because we follow the classical LIFO pattern when we manage the memory on the stack, and the name of the heap implies disorganization. Generally speaking, it is more efficient to allocate and free memory space on the stack. For this reason, Rust operates on the stack by default. Data of ‚Äúfixed size‚Äù is generally placed on the stack, and data of ‚Äúvariable size‚Äù is generally placed on the heap. However, sometimes for performance considerations, fixed-size data can also be stored on the heap. In the subject of CS, you can often see the layered design. For example, OSI model in the computer network. Programming languages themselves can also be divided into high-level languages and low-level languages. I would like to share with you a sentence from a performance engineering teacher1 - ‚ÄúMany times, if you want to learn this level well, you must understand the underlying level. You don‚Äôt have to work at that level, but after knowing the details of that level. It will help you learn this level quite well‚Äù. At least for me, after knowing the difference between stack and heap, the following questions seem to me to have a very reasonable explanation: What are pointers in C/C++ language used for? Why do they exist? Why does tail recursion optimization exist? Why do we have to consider the problem of deep recursion when writing recursive functions? Why does Rust put data on the stack by default? Why did I see someone recommend passing references when implementing a function? üìí Personal speaking, the abstraction layer design is the most important concept in CS. Should you choose a language with GC that is easy to use but less efficient, or choose to manually manage memory yourself to make your code more efficient? It depends on the job at hand. If you want to develop speed, of course, it is the former, and if you focus on performance, it is the latter. Of course, in the middle is no GC + basically no need to manually manage memory by yourself + efficient = Rust language üöÄ. Why not learn some Rust üòâ ‚ö†Ô∏è Some details are ignored when I write this article. I only wrote down what I think is important. If you want to learn more, you may check the refs. ","date":"2022-09-19","objectID":"/what-is-the-heap-and-stack/:5:0","tags":["System-programming"],"title":"What is stack and heap","uri":"/what-is-the-heap-and-stack/"},{"categories":["System-Programming"],"content":"Refs 6.172. Performance engineering of software systems - Lecture 11 \u0026\u0026 Lecture 12¬†‚Ü©Ô∏é¬†‚Ü©Ô∏é¬†‚Ü©Ô∏é Stack frame¬†‚Ü©Ô∏é ","date":"2022-09-19","objectID":"/what-is-the-heap-and-stack/:6:0","tags":["System-programming"],"title":"What is stack and heap","uri":"/what-is-the-heap-and-stack/"},{"categories":["Vim"],"content":"How to use vim's macro system","date":"2022-07-02","objectID":"/vim-macro-101/","tags":["Vim"],"title":"Vim Macro 101","uri":"/vim-macro-101/"},{"categories":["Vim"],"content":"Intro In the process of learning vim, the most enlightening sentence for me is : vim is a kind of programming language I once try to learn vim a long time ago. However, the key combination logic is very difficult to remember in my opinion. So I later gave up learning vim and switched to a normal text editor. My view of vim changed when I met this course: Missing semester. I started to regard vim as a kind of programming language rather than just a text editor. :) It seems that I am talking about something unrelated to this blog post. That‚Äôs not true. As programmers, we often do repetitive tasks by programming. Different people have different favorites. vim is definitely one of the options for solving problems. ","date":"2022-07-02","objectID":"/vim-macro-101/:1:0","tags":["Vim"],"title":"Vim Macro 101","uri":"/vim-macro-101/"},{"categories":["Vim"],"content":"What is macro in vim? I assume you have a basic understanding of basic vim usage : ) We know that we can use . to repeat the last change, well, a simple change I mean. Have you wondered if there is a more powerful way to repeat complex changes? Yeah, It is called macro in vim. You can record your typed characters(operations) into a register and execute them later. It is just a sequence of characters that could be understood by vim. ","date":"2022-07-02","objectID":"/vim-macro-101/:2:0","tags":["Vim"],"title":"Vim Macro 101","uri":"/vim-macro-101/"},{"categories":["Vim"],"content":"Macro-how? ","date":"2022-07-02","objectID":"/vim-macro-101/:3:0","tags":["Vim"],"title":"Vim Macro 101","uri":"/vim-macro-101/"},{"categories":["Vim"],"content":"How to record your macro Steps followed: In normal mode, press q\u003cregister\u003e. It means you first press q and then choose a register you like to store your macro. the regitsers you can use: 0-9, a-z, and \". I will explain why not use the uppercase letters here later Start typing. If everything goes right, you will see recording @\u003cregister\u003e in the bottom left. From now on, everything you typed will be recorded. Press q again to exit the recording. üìí The most important thing when you record your macro is: you should make all steps repeatable in other similar files. So, the takeaway is: look into the files and figure out the common pattern before recording :) ","date":"2022-07-02","objectID":"/vim-macro-101/:3:1","tags":["Vim"],"title":"Vim Macro 101","uri":"/vim-macro-101/"},{"categories":["Vim"],"content":"How to check my macro I previously mentioned that the macro is just a sequence of characters stored in a specific register. So if we want to look into the register, we just type the :reg command. :reg \u003cregister\u003e You may see some strange characters: ^[ means \u003cESC\u003e \u003c80\u003ekb means BAKESPACE ","date":"2022-07-02","objectID":"/vim-macro-101/:3:2","tags":["Vim"],"title":"Vim Macro 101","uri":"/vim-macro-101/"},{"categories":["Vim"],"content":"How to execute my macro Within a file @\u003cregister\u003e: execute the macro in \u003cregister\u003e @@: execute the previously executed macro What if I want to execute my macro many times? Well, it is easy. You just add [COUNT] before @@ or @\u003cregister\u003e. Remember, vim is a kind of programming language. Do all these make sense if you consider it as a kind of programming language? e.g. 100@@ means executing the previous executed macro 100 times : ) It is worth mentioning that if you want to apply your macro within a file, you can set a larger [COUNT]. The exceeding part will be ignored. a bunch of files Open a file and apply a macro repeatedly could be very tedious. It is absolutely a violation of the DRY(Don‚Äôt repeat yourself) principle. vim allows us to open multiple files at the same time and edit them one by one. What‚Äôs more, we can apply our macro to all files in a single command. For example, you want to edit all the txt files in the current directory. You can open all of them by typing vim *.txt in your terminal. At first glance, it looks like you are editing a file, except that if you try to type :x to save and exit you will get an error! The basic way is modifying and then typing :wn to save the changes and go to the next file. Now I will tell you how to do this cleverly. Record your specific macro first then drop the changes by typing :edit! in the 1st file because we will change all files later. Without this step, the 1st file will be modified twice. Typing :bufdo execute \"normal @\u003cregister\u003e\" | update. More details can be found here ","date":"2022-07-02","objectID":"/vim-macro-101/:3:3","tags":["Vim"],"title":"Vim Macro 101","uri":"/vim-macro-101/"},{"categories":["Vim"],"content":"How to modify my macro simple case If you are recording a quite long macro and you press q unexpectedly, you may need this feature. It is good news that we don‚Äôt need to start from the beginning again. Do you still remember that I deliberately skip the uppercase letter registers earlier? Actually. When you press q\u003cREIGSTER\u003e(REGISTER means A-Z). Everything you typed will be appended to the REGISTER üöÄ complex case You may need to change some operations in the middle of the macro. Still, you don‚Äôt need to redo all these. You may follow the steps to modify your macro: Press G to jump to the last line, then type :put \u003cregister\u003e. You will see the content of the register now appear below. Just edit the content After you have edited the content, you can type :d \u003cregister\u003e to put back the content e.g. The followed gif shows the procedure of modifying a macro. I have a dumb macro in the register y whose function is appending world in the current line. I just modify it to append hello world instead. ","date":"2022-07-02","objectID":"/vim-macro-101/:3:4","tags":["Vim"],"title":"Vim Macro 101","uri":"/vim-macro-101/"},{"categories":["Vim"],"content":"Combined with other tools In the Linux world, we can combine the CLI tools to achieve what we want in an elegant way. Let‚Äôs say you want to edit a bunch of files(the operation is the same) using vim. Check this link. You can using find \u003cpattern\u003e -exec vim {} + to open all the files in vim. Use the bufdo technology aforementioned to modify files. ","date":"2022-07-02","objectID":"/vim-macro-101/:4:0","tags":["Vim"],"title":"Vim Macro 101","uri":"/vim-macro-101/"},{"categories":["Vim"],"content":"Wrap up This is a simple tutorial about the macro in vim. It is just the tip of the iceberg in vim. Only when you really master the vim you may make the most of it. It would be great if this blog get you interested in vim. I once heard that: at first, we choose the tools we like, and then the tool will shape us. Hope this tutorial will be helpful üòâ ","date":"2022-07-02","objectID":"/vim-macro-101/:5:0","tags":["Vim"],"title":"Vim Macro 101","uri":"/vim-macro-101/"},{"categories":["Compiler"],"content":"use the semantic actions to generate the symbol tables in ANTLR4","date":"2022-05-28","objectID":"/how-to-use-antlr4-to-make-semantic-actions/","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"What are the semantic actions When the parser processes the input code, it not only determines whether the syntax is correct but also performs some useful actions. These actions are called semantic actions. In fact, it is a piece of code, which is generally embedded in the rules of the grammar file. Then when the parser applies this specific rule, the code you set will be executed. From another perspective, semantic actions are actually ‚Äútriggers‚Äù, and the trigger condition is that the parser applies the corresponding rules. Today‚Äôs post is about an application of semantic actions-implementing a simple symbol table, the tool used here is ANTLR4. ","date":"2022-05-28","objectID":"/how-to-use-antlr4-to-make-semantic-actions/:1:0","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"What‚Äôs the symbol table When the compiler processes our code, it will maintain a symbol table internally, which is used to store all the information about variables in the program: variable name, data type, scope to which the variable belongs, etc. The symbol table can be of this form: Symbol name Type Scope bar function, double extern x double function parameter foo function, double global count int function parameter sum double block local i int for-loop statement ","date":"2022-05-28","objectID":"/how-to-use-antlr4-to-make-semantic-actions/:2:0","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"How to use actions in the ANTLR4 ANTLR4 is a powerful parse generator. As long as we provide the grammar file, it can automatically generate a parser for us. The generated parser can support multiple target languages. For example, I use [Python](https://pypi .org/project/antlr4-python3-runtime) as my target language, then the final generated parser is a xxxParser.py file. The xxx is your grammar filename. ANTLR4 also provides methods that allow us to insert actions into the grammar file, and these actions will eventually be injected into the generated parser file. Therefore, the programming language in which the action is written depends on the target language of your output parser ‚ö†Ô∏èIt is assumed here that you have a basic understanding of how to write ANTLR4 grammar files (*.g4), and will not go into details about this. The article only focuses on how to insert actions into grammar files. ","date":"2022-05-28","objectID":"/how-to-use-antlr4-to-make-semantic-actions/:3:0","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"Basic overview Below is a simplified code template for the generated parser file. In general, the locations we can inject are as follows(\u003c...\u003e in the code): \u003cheader\u003e class xxxParser(Parser): ... \u003cmember\u003e def rule(self): ... \u003caction\u003e I will explain the different syntax for each location: \u003cheader\u003e The ANTLR4 is originally written in Java, so if the target language you use is also Java, this will be more useful. Usually, it is used to place import statements. The format of the code to be injected into this location is as follows (in the *.g4 file, the same below) @header{ everything here will go to \u003cheader\u003e } \u003cmember\u003e This position is used to put the member of the class, which can be a field or a method. The ANTLR4 supports injecting code into Lexer and Parser separately or simultaneously. The format for injecting code into this location is as follows: @members { everything here will go to \u003cmember\u003e in xxxLexer \u0026\u0026 xxxParser } @Lexer::members { everything here will go to \u003cmember\u003e in xxxLexer } @Parser::members { everything here will go to \u003cmember\u003e in xxxParser } ‚ö†Ô∏èIn the antlr4-python3-runtime edition I use (4.10), it is not yet possible to annotate the fields. You can‚Äôt put # comments like this. \u003caction\u003e In ANTLR4, an action is a code enclosed in **curly braces {\u003cspecific-language-here\u003e}. As mentioned earlier, it is depending on what language your final output parser wants to be. Actions are generally placed after a symbol in a rule. When the parser applies the rule, the corresponding action will be executed after finishing matching the symbol. The symbol here can be terminal or nonterminal. We can use $symbol.attr to access the corresponding attributes, there are the following: $terminal.text # origin text $terminal.type # an integer stands for type $terminal.attributes $terminal.line # the line number $terminal.pos # the position of the first char in the lineÔºå0-based $terminal.index $terminal.channel # the channel of this terminal, won't discuss in this post $terminal.int # return an interger if this terminal is an integer $nonterminal.text # origin text $nonterminal.start # 1st Token $nonterminal.stop # last Token $nonterminal.ctx # return context object ","date":"2022-05-28","objectID":"/how-to-use-antlr4-to-make-semantic-actions/:3:1","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"An example ‚ö†Ô∏èOnly part of the code is given below, the complete code is in my Github repo ‚ö†Ô∏èBecause this project requires printing warnings before other outputs, so I use warning_list and output_list to store them temporarily, and then finally print them together. The following is an example of the [project assignment] (https://engineering.purdue.edu/~milind/ece573/2015fall/project/step3/step3.html) of the compiler course offered by Purdue University in 2015. The entire project requires to Implementing a compiler for Micro language. The grammar of the Micro language can be found here. Below I will give a brief introduction to the homework requirements. In this assignment we need to build a symbol table and print relevant information at the corresponding moment: Whenever we enter a new scope (which can be a function or a code block) Whenever we encounter variable declarations If the declared variable has been declared in the outer scope, print: SHADOW WARNING \u003cvar_name\u003e If there is already a variable with the same name in the current scope, print: DECLARATION ERROR \u003cvar_name\u003e. If this is the case, then the final program only outputs this information Symbol table \u003cscope_name\u003e name \u003cvar_name\u003e type \u003ctype_name\u003e name \u003cvar_name\u003e type \u003ctype_name\u003e value \u003cstring_value\u003e ","date":"2022-05-28","objectID":"/how-to-use-antlr4-to-make-semantic-actions/:4:0","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"What data structure should I use ü§îThe first question to be solved is, what data structure should be used to represent the symbol table? A symbol table should meet the following characteristics: Efficient query Efficient insertion Record the scope of the variable It is not difficult to figure out that the data structure that supports efficient query and insertion is the ‚Äúhash table‚Äù. To maintain the scope of variables, We can put variables in the same hash table, and use a list to remember all scopes. The structure should be like: [{scope1} , {scope2},...]. In order to remember the current scope, I use the self.current_scope variable. Whenever a new scope appears, save the current scope and insert a new scope into the list. Don‚Äôt forget to update the self.current_scope also. üìíConceptually, the list here is a stack ü§îWhat method are we going to implement? lookup(identifier, value): Insert a variable into the current symbol table. According to the requirements of this assignment, we should also query whether the variable has been declared before enter_new_scope(): Save the current symbol table, enter the new scope, and initialize it. exit_scope(): Clear the current symbol table and find the previous symbol table(the top of the stack) So the corresponding code in @parser::members are as follows @parser::members { def init(self): self.current_scope = None self.block_count = 0 self.warning_list = [] # just for printing self.output_list = [] # just for printing self.declaration_error = '' def enter_new_scope(self): if not hasattr(self, '_scopes'): setattr(self, '_scopes', []) # save the current_scope import copy if len(self._scopes) \u003e 0: self._scopes.append(copy.deepcopy(self.current_scope)) self._scopes.append({}) self.current_scope = self._scopes[-1] def exit_scope(self): del self._scopes[-1] if len(self._scopes) \u003e 0: self.current_scope = self._scopes[-1] def lookup(self, identifier, value): # check all scopes found = False for scope in self._scopes[:-1][::-1]: #print(f\"the scope: {scope}\") if identifier in scope: found = True if found: self.warning_list.append(f\"SHADOW WARNING {identifier}\") # only record the 1st declaration error if identifier in self.current_scope and self.declaration_error == '': self.declaration_error = f\"DECLARATION ERROR {identifier}\" self.current_scope[identifier] = value } ","date":"2022-05-28","objectID":"/how-to-use-antlr4-to-make-semantic-actions/:4:1","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"Inject actions into the grammar rule ü§îThe next step is to inject actions into the corresponding grammar rules. We want to output relevant information when variable declarations happen, so we must first observe what the rules of variable declaration in the Micro language are. The corresponding grammar rules are as follows ... var_decl : var_type id_list ';' ; var_type : 'FLOAT' | 'INT' ; any_type : var_type | 'VOID' ; id_list : id id_tail ; id_tail : ',' id id_tail | ; ... As you can see, the var_decl rule shows the basic structure to declare variables. You can declare one or more variables at a time, and each variable is separated by ,, so we can inject the following action code at the end of this rule. ‚ö†Ô∏èNote that if you are also using python, the indentation here is a bit weird, because each line starts from the leftmost, but the final generated code is fine. the ANTLR4 will take care of this. ... var_decl : var_type id_list ';' { # NOTE: the indentation is correct, ANLTR4 will handle this for us :) # for all variable declarations, we should output the name \u0026\u0026 type # in the same variable declaration, it means all of the variables have the same type for variable in $id_list.text.split(','): self.lookup(variable, None) self.output_list.append(f\"name {variable} type {$var_type.text}\") } ; ... We use $id_list.text to get the text corresponding to the variable declaration, and $var_type.text to get the corresponding variable type. ","date":"2022-05-28","objectID":"/how-to-use-antlr4-to-make-semantic-actions/:4:2","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"How to solve the scope problem Takes the program rule as an example (functions and code blocks are similar). The program rule is the starting rule of the Micro grammar, which specifies the big framework that a Micro program should have. The rule is as follows: program : 'PROGRAM' id 'BEGIN' pgm_body 'END' ; After processing the PROGRAM token, we can create and initialize the first scope (global scope), and finally, exit the global scope after finishing processing. So we can quickly figure out where to inject the action program : 'PROGRAM' id 'BEGIN' pgm_body 'END' ; ^ ^ | 2 The final code should be like this: program : 'PROGRAM' { self.init() self.output_list.append(\"Symbol table GLOBAL\") self.enter_new_scope() } id 'BEGIN' pgm_body 'END' { self.exit_scope() # output everything after we parsing this program if self.declaration_error != '': print(self.declaration_error) else: if len(self.warning_list) \u003e 0: print('\\n'.join(self.warning_list)) print('\\n'.join(self.output_list)) } ; ","date":"2022-05-28","objectID":"/how-to-use-antlr4-to-make-semantic-actions/:4:3","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"Extended reading The aforementioned example only involves simple actions injection, but ANTLR4 supports more powerful ways: For example, we can make a nonterminal return value If there are multiple nonterminals with the same name in the same rule, you can alias them Here‚Äôs an example from the book that nicely demonstrates the above two usages: e returns [int v] : a=e op=('*'|'/') b=e {$v = self.eval($a.v, $op, $b.v)} | a=e op=('+'|'-') b=e {$v = self.eval($a.v, $op, $b.v)} | INT {$v = $INT.int} | ID ","date":"2022-05-28","objectID":"/how-to-use-antlr4-to-make-semantic-actions/:5:0","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"Wrap up From this example, we can learn how to use actions in ANTLR4. Generating the symbol table is just one of the applications. Injecting actions into the code is a very intuitive way to quickly implement the functions you want. However, the disadvantage is also obvious. It is language-dependent, which means that once you change the target language output by ANTLR, all the actions you have written must be changed. Also, The grammar file will be a mess ","date":"2022-05-28","objectID":"/how-to-use-antlr4-to-make-semantic-actions/:6:0","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Compiler"],"content":"Refs Symbol table - wiki The Definitive ANTLR 4 Reference ","date":"2022-05-28","objectID":"/how-to-use-antlr4-to-make-semantic-actions/:7:0","tags":["Compiler","Course"],"title":"How to use the semantic actions to generate the symbol tables in ANTLR4","uri":"/how-to-use-antlr4-to-make-semantic-actions/"},{"categories":["Algorithm"],"content":"A simple explanation of the boyer-moore majority voting algorithm","date":"2022-03-24","objectID":"/boyer-moore-majority-voting-algorithm-explained/","tags":["Algorithm"],"title":"Boyer-Moore Majority Voting Algorithm Explained","uri":"/boyer-moore-majority-voting-algorithm-explained/"},{"categories":["Algorithm"],"content":"Intro Today I coded the Leetcode 169. Majority Element again. I vaguely remember what the optimal solution is called Boyer-Moore Majority Voting Algorithm. However, I have no idea what is except for its name. So I plan to systematically learn the principle of this algorithm and summarize it to write this blog. I once heard that: If you want to master something, teach it :) So, I‚Äôm here today to share this algorithm with you, and try to teach you this method in plain language, so let‚Äôs get started :) ","date":"2022-03-24","objectID":"/boyer-moore-majority-voting-algorithm-explained/:1:0","tags":["Algorithm"],"title":"Boyer-Moore Majority Voting Algorithm Explained","uri":"/boyer-moore-majority-voting-algorithm-explained/"},{"categories":["Algorithm"],"content":"Let‚Äôs start from the baselines If you have never heard of the Boyer-Moore Majority Voting Algorithm, how would you try to solve this problem? I think these methods should come to your mind: Exchange space for time efficiency, that is, we use a hash table to record the number of occurrences of each element in the array, and then we check our hash table again to find the number of occurrences that is greater than $\\lfloor n/2\\rfloor$. Apparently, the time complexity and space complexity are both $O(n)$ Try to sort the array, because the element we are looking for exceeds the half-length of the array, which means it must appear in the middle of the array after sorting. However, although the space complexity is $O( 1)$, the time complexity is still greater than $O(n)$. For example, if you use quicksort, the time complexity is $O(nlogn)$ So is there a way to achieve a time complexity of $O(n)$ and a space complexity of $O(1)$? That is to combine the advantages of the above two methods. Yes, the answer is the Boyer-Moore Majority Voting Algorithm! ","date":"2022-03-24","objectID":"/boyer-moore-majority-voting-algorithm-explained/:2:0","tags":["Algorithm"],"title":"Boyer-Moore Majority Voting Algorithm Explained","uri":"/boyer-moore-majority-voting-algorithm-explained/"},{"categories":["Algorithm"],"content":"Boyer-Moore Majority Voting Algorithm Problem description: Suppose our array has $n$ elements, and we want to find the elements that appear more than $\\lfloor n/2\\rfloor$ times. Algorithm: Choose one of these $n$ elements as a candidate and record its votes as votes = 1. At this point there are $n-1$ elements in our array, we take out one element each time (denoted as current), and repeat the following steps (a total of n-1 times) Compare it to our current candidate, if they have the same value, then votes++, which is an affirmative vote If their values are different, votes--, that is, a dissenting vote. If we get votes = 0 at this time, then candidate \u003c- current, which means that we make current the new candidate, and reset votes = 1 The final value of the candidate is maybe the element that appears more than half of the times we want, at this point, we have to traverse the array again to check if it is After reading the above algorithm procedure, you may be as confused as I was. Why do we finally find the elements with more than half of the occurrences? In order to answer this question, we need to understand this: üí° If there is an element that appears more than $\\lfloor n/2\\rfloor$ times, then the other elements in the array must appear less than $\\lfloor n/2\\rfloor$ in all. Why it is useful? ‚¨ÜÔ∏è Because what this algorithm does is actually voting: It can be an affirmative vote, which is equal to the occurrences times of this element It can be a dissenting vote, which is equivalent to canceling one affirmative vote But the number of votes (affirmative votes) for the elements that appear more than $\\lfloor n/2\\rfloor$ times \u003e the remaining all that are not (dissenting votes) is always to be true, so no matter what, the final winner will always be the element we are searching(if it exists) :) To get a intuitive understanding ‚¨áÔ∏è ","date":"2022-03-24","objectID":"/boyer-moore-majority-voting-algorithm-explained/:3:0","tags":["Algorithm"],"title":"Boyer-Moore Majority Voting Algorithm Explained","uri":"/boyer-moore-majority-voting-algorithm-explained/"},{"categories":["Algorithm"],"content":"Code class Solution { public int majorityElement(int[] nums) { if (nums.length \u003c 2) { return nums[0]; } int candidates = nums[0]; int votes = 1; // step 1. start to vote for (int i = 0; i \u003c nums.length; i++) { if (nums[i] != candidates) { votes -= 1; if (votes == 0) { candidates = nums[i]; votes = 1; } } else { votes += 1; } } // step2. check int occurs = 0; for (var val: nums) { if (candidates == val) { occurs += 1; } } if (occurs \u003e= nums.length / 2) { return candidates; } else { return -1; } } } ","date":"2022-03-24","objectID":"/boyer-moore-majority-voting-algorithm-explained/:4:0","tags":["Algorithm"],"title":"Boyer-Moore Majority Voting Algorithm Explained","uri":"/boyer-moore-majority-voting-algorithm-explained/"},{"categories":["Algorithm"],"content":"FAQ Q: Why do you need a second round of for-loop? Can we just check the votes directly? A: No, first of all, the element that ‚Äúoccurs more than $\\lfloor n/2\\rfloor$ times‚Äù does not always exist. e.g. [1,2,3]. In addition, even if it exists, after traversing the array for the first time, the votes does not necessarily equal to it real occurrence times. e.g. [1, 2, 2, 2, 3] ","date":"2022-03-24","objectID":"/boyer-moore-majority-voting-algorithm-explained/:5:0","tags":["Algorithm"],"title":"Boyer-Moore Majority Voting Algorithm Explained","uri":"/boyer-moore-majority-voting-algorithm-explained/"},{"categories":["Course"],"content":"The simple solution of proj3.Ants vs. SomeBees of CS61B","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Intro I have finished the first two projects - Hog and Cats. The first two projects are relatively simple and uncomplicated. But today, the difficulty of the third project has indeed increased (you can see how complicated this is by looking at the rules of the game). It feels like Plants vs. Zombies So I‚Äôm going to write a blog to sort out the ideas when writing code. ü§ó ","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/:1:0","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Phase 1: Basic gameplay ","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/:2:0","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Problem 1 (1 pt) Part A: Currently, there is no cost for placing any type of Ant, and so there is no challenge to the game. The base class Ant has a food_cost of zero. Override this class attribute for HarvesterAnt and ThrowerAnt according to the ‚ÄúFood Cost‚Äù column in the table below. Part B: Now that placing an Ant costs food, we need to be able to gather more food! To fix this issue, implement the HarvesterAnt class. A HarvesterAnt is a type of Ant that adds one food to the gamestate.food total as its action. Set the properties of HarversterAnt and ThrowerAnt according to the requirements of the description, and implement the action method of HarvesterAnt, so that it can give food + 1 each time it acts class HarvesterAnt(Ant): \"\"\"HarvesterAnt produces 1 additional food per turn for the colony.\"\"\" name = 'Harvester' implemented = True food_cost = 2 def action(self, gamestate): \"\"\"Produce 1 additional food for the colony. gamestate -- The GameState, used to access game state information. \"\"\" gamestate.food += 1 class ThrowerAnt(Ant): \"\"\"ThrowerAnt throws a leaf each turn at the nearest Bee in its range.\"\"\" name = 'Thrower' implemented = True damage = 1 food_cost = 3 ","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/:2:1","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Problem 2 (1 pt) In this problem, you‚Äôll complete Place.__init__ by adding code that tracks entrances. Right now, a Place keeps track only of its exit. We would like a Place to keep track of its entrance as well. A Place needs to track only one entrance. Tracking entrances will be useful when an Ant needs to see what Bees are in front of it in the tunnel. However, simply passing an entrance to a Place constructor will be problematic; we would need to have both the exit and the entrance before creating a Place! (It‚Äôs a chicken or the egg problem.) To get around this problem, we will keep track of entrances in the following way instead. Place.__init__ should use this logic: A newly created Place always starts with its entrance as None. If the Place has an exit, then the exit‚Äôs entrance is set to that Place. In fact, this colony is a bit like the structure of a doubly linked list in the data structure. Use .exit to go to the left and .entrance method to go to the right. class Place: \"\"\"A Place holds insects and has an exit to another Place.\"\"\" is_hive = False def __init__(self, name, exit=None): \"\"\"Create a Place with the given NAME and EXIT. name -- A string; the name of this Place. exit -- The Place reached by exiting this Place (may be None). \"\"\" self.name = name self.exit = exit self.bees = [] # A list of Bees self.ant = None # An Ant self.entrance = None # A Place # Phase 1: Add an entrance to the exit if exit is not None: self.exit.entrance = self ","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/:2:2","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Problem 3 (1 pt) In order for a ThrowerAnt to throw a leaf, it must know which bee to hit. The provided implementation of the nearest_bee method in the ThrowerAnt class only allows them to hit bees in the same Place. Your job is to fix it so that a ThrowerAnt will throw_at the nearest bee in front of it that is not still in the Hive. This includes bees that are in the same Place as a ThrowerAnt Hint: All Places have an is_hive attribute which is True when that place is the Hive. Change nearest_bee so that it returns a random Bee from the nearest place that contains bees. Your implementation should follow this logic: Start from the current Place of the ThrowerAnt. For each place, return a random bee if there is any, and if not, inspect the place in front of it (stored as the current place‚Äôs entrance). If there is no bee to attack, return None. Now we have to add a function to ThrowerAnt, so that it can attack the closest beeüêù. Note that if the bee is in the same place as it, it can also attack the üêù. Our job requirement is to traverse each grid (just like you traverse the linked list) to find the first place that contains at least a bee, and return a random bee def nearest_bee(self): \"\"\"Return the nearest Bee in a Place that is not the HIVE, connected to the ThrowerAnt's Place by following entrances. This method returns None if there is no such Bee (or none in range). \"\"\" pos = self.place while pos.entrance is not None: if not pos.is_hive: if len(pos.bees) \u003e 0: return random_bee(pos.bees) pos = pos.entrance return None ","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/:2:3","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Phase 2: Ants! ","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/:3:0","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Problem 4 (2 pt) A ThrowerAnt is a powerful threat to the bees, but it has a high food cost. In this problem, you‚Äôll implement two subclasses of ThrowerAnt that are less costly but have constraints on the distance they can throw: The LongThrower can only throw_at a Bee that is found after following at least 5 entrance transitions. It cannot hit Bees that are in the same Place as it or the first 4 Places in front of it. If there are two Bees, one too close to the LongThrower and the other within its range, the LongThrower should only throw at the farther Bee, which is within its range, instead of trying to hit the closer Bee. The ShortThrower can only throw_at a Bee that is found after following at most 3 entrance transitions. It cannot throw at any bees further than 3 Places in front of it. Neither of these specialized throwers can throw_at a Bee that is exactly 4 Places away. Now we have to implement two classes, LongThrower and ShortThrower. Both of them are subclasses of ThrowererAnt . In fact, it can be seen from their names that the differences are the attack range. How do we express the concept of attack range? In fact, it is very simple. In problem 3, when we find the nearest bee, we move forward one place at a time, and we can calculate the number of steps at the same time, then we will get the distance. Then we may check whether the distance is fall between the min_range and max_range (class variables, indicating the attack range of the ants corresponding to this class) Also, note that we cannot affect the results in problem 3. Just need to do some simple modifications. We let min_range=-1, max_range=float('inf'), which is equivalent to no limit ~! Because of The advantages of OOP, we save a lot of code. # In problem 3 class ThrowerAnt(Ant): \"\"\"ThrowerAnt throws a leaf each turn at the nearest Bee in its range.\"\"\" name = 'Thrower' implemented = True damage = 1 food_cost = 3 min_range = -1 max_range = float('inf') def nearest_bee(self): \"\"\"Return the nearest Bee in a Place that is not the HIVE, connected to the ThrowerAnt's Place by following entrances. This method returns None if there is no such Bee (or none in range). \"\"\" steps_cnt = 0 pos = self.place while pos.entrance is not None: if steps_cnt \u003e self.max_range: return None if not pos.is_hive: if len(pos.bees) \u003e 0 and steps_cnt \u003e= self.min_range: return random_bee(pos.bees) pos = pos.entrance steps_cnt += 1 return None class ShortThrower(ThrowerAnt): \"\"\"A ThrowerAnt that only throws leaves at Bees at most 3 places away.\"\"\" name = 'Short' food_cost = 2 # OVERRIDE CLASS ATTRIBUTES HERE implemented = True # Change to True to view in the GUI max_range = 3 class LongThrower(ThrowerAnt): \"\"\"A ThrowerAnt that only throws leaves at Bees at least 5 places away.\"\"\" name = 'Long' food_cost = 2 # OVERRIDE CLASS ATTRIBUTES HERE implemented = True # Change to True to view in the GUI min_range = 5 ","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/:3:1","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Problem 5 (3 pt) Implement the FireAnt, which does damage when it receives damage. Specifically, if it is damaged by amount health units, it does a damage of amount to all bees in its place (this is called reflected damage). If it dies, it does an additional amount of damage, as specified by its damage attribute, which has a default value of 3 as defined in the FireAnt class. To implement this, override FireAnt‚Äôs reduce_health method. Your overriden method should call the reduce_health method inherited from the superclass (Ant) to reduce the current FireAnt instance‚Äôs health. Calling the inherited reduce_health method on a FireAnt instance reduces the insect‚Äôs health by the given amount and removes the insect from its place if its health reaches zero or lower. When the FireAnt receives damage, it will reflect the damage it has received to all bees in the current place, and if it dies because of the bee‚Äôs attack, it can also deal its damage to these bees again (depending on the damage of the FireAnt) Details: All the bees in the current place are stored as a list. As a result, **we may mutate the list while we are iterating it, so we need to traverse its copy(slice) We can‚Äôt directly call the reduce_health method of this FireAnt, otherwise, if it dies, the object will not exist. The final code is as follows: class FireAnt(Ant): \"\"\"FireAnt cooks any Bee in its Place when it expires.\"\"\" name = 'Fire' damage = 3 food_cost = 5 implemented = True # Change to True to view in the GUI def __init__(self, health=3): \"\"\"Create an Ant with a HEALTH quantity.\"\"\" super().__init__(health) def reduce_health(self, amount): \"\"\"Reduce health by AMOUNT, and remove the FireAnt from its place if it has no health remaining. Make sure to reduce the health of each bee in the current place, and apply the additional damage if the fire ant dies. \"\"\" # FireAnt attack bees for bee in self.place.bees[:]: bee.reduce_health(amount) # FireAnt will be dead if self.health \u003c= amount: for bee in self.place.bees[:]: bee.reduce_health(self.damage) super().reduce_health(amount) else: super().reduce_health(amount) ","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/:3:2","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Phase 3: More Ants! ","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/:4:0","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Problem 6 (1 pt) We are going to add some protection to our glorious home base by implementing the WallAnt, an ant that does nothing each turn. A WallAnt is useful because it has a large health value. Unlike with previous ants, we have not provided you with a class header. Implement the WallAnt class from scratch. Give it a class attribute name with the value 'Wall' (so that the graphics work) and a class attributeimplemented with the value True (so that you can use it in a game). Implement a WallAnt from scratch. This one is easy ! class WallAnt(Ant): \"\"\"WallAnt has a large health value\"\"\" name = 'Wall' damage = 0 food_cost = 4 implemented = True def __init__(self, health=4): super().__init__(health) ","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/:4:1","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Problem 7 (3 pt) Implement the HungryAnt, which will select a random Bee from its place and eat it whole. After eating a Bee, a HungryAnt must spend 3 turns chewing before eating again. If there is no bee available to eat, HungryAnt will do nothing. Give HungryAnt a chew_duration class attribute that stores the number of turns that it will take a HungryAnt to chew (set to 3). Also, give each HungryAnt an instance attribute chew_countdown that counts the number of turns it has left to chew (initialized to 0, since it hasn‚Äôt eaten anything at the beginning. You can also think of chew_countdown as the number of turns until a HungryAnt can eat another Bee). Implement the action method of the HungryAnt: First, check if it is chewing; if so, decrement its chew_countdown. Otherwise, eat a random Bee in its place by reducing the Bee‚Äôs health to 0. Make sure to set the chew_countdownwhen a Bee is eaten! Implementing a HungryAnt from scratch that can swallow a whole bee at random!!!! But it takes chew_duration to chew before the next attack. Isn‚Äôt this the piranha in Plants vs. Zombies!!! We only need to judge whether it is currently in the chewing state. Note that the value of chew_duration may be modified in the runtime. class HungryAnt(Ant): \"\"\"HungryAnt will select a random bee from its place and eat it whole\"\"\" name = 'Hungry' damage = 0 food_cost = 4 implemented = True chew_duration = 3 def __init__(self, health=1): super().__init__(health) self.chew_countdown = 0 def action(self, gamestate): # it is chewing if self.chew_countdown != 0: self.chew_countdown -= 1 # it is not chewing else: if len(self.place.bees) \u003e 0: # WARNING: the test cases may change the chew_duration variable in runtime self.chew_countdown = self.chew_duration bee = random_bee(self.place.bees) bee.reduce_health(bee.health) ","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/:4:2","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Problem 8 (3 pt) A BodyguardAnt differs from a normal ant because it is a ContainerAnt; it can contain another ant and protect it, all in one Place. When a Bee stings the ant in a Place where one ant contains another, only the container is damaged. The ant inside the container can still perform its original action. If the container perishes, the contained ant still remains in the place (and can then be damaged). Each ContainerAnt has an instance attribute ant_contained that stores the ant it contains. This ant, ant_contained, initially starts off as None to indicate that there is no ant being stored yet. Implement the store_ant method so that it sets the ContainerAnt‚Äôs ant_contained instance attribute to the passed in antargument. Also implement the ContainerAnt‚Äôs action method to perform its ant_contained‚Äôs action if it is currently containing an ant. The ant to be implemented here is also very interesting, it can protect an ant. It can even stay in the same place with the protected ant inside. Note a few details here: BodyguardAnt cannot protect BodyguardAnt! When BodyguardAnt and the ant inside are in the same place, make place.ant always point to BodyguardAnt There are actually a lot of things to be changed here (some code changes may be missed below, see my repo) class Ant(Insect): \"\"\"An Ant occupies a place and does work for the colony.\"\"\" implemented = False # Only implemented Ant classes should be instantiated food_cost = 0 is_container = False ... def add_to(self, place): if place.ant is None: place.ant = self else: assert ( (place.ant is None) or self.can_contain(place.ant) or place.ant.can_contain(self) ), 'Two ants in {0}'.format(place) if place.ant.is_container and place.ant.can_contain(self): place.ant.store_ant(self) elif self.is_container and self.can_contain(place.ant): self.store_ant(place.ant) # the place.ant should refer to the container ant place.ant = self Insect.add_to(self, place) class ContainerAnt(Ant): \"\"\" ContainerAnt can share a space with other ants by containing them. \"\"\" is_container = True def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.ant_contained = None def can_contain(self, other): # we can't have two BodyguardAnt in the same place if self.ant_contained is None and not other.is_container: return True def store_ant(self, ant): self.ant_contained = ant def remove_ant(self, ant): if self.ant_contained is not ant: assert False, \"{} does not contain {}\".format(self, ant) self.ant_contained = None def remove_from(self, place): # Special handling for container ants (this is optional) if place.ant is self: # Container was removed. Contained ant should remain in the game place.ant = place.ant.ant_contained Insect.remove_from(self, place) else: # default to normal behavior Ant.remove_from(self, place) def action(self, gamestate): if self.ant_contained is not None: return self.ant_contained.action(gamestate) class BodyguardAnt(ContainerAnt): \"\"\"BodyguardAnt provides protection to other Ants.\"\"\" name = 'Bodyguard' food_cost = 4 implemented = True # Change to True to view in the GUI def __init__(self, health=2): super().__init__(health) ","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/:4:3","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Problem 9 (1 pt) The BodyguardAnt provides great defense, but they say the best defense is a good offense. The TankAnt is a container that protects an ant in its place and also deals 1 damage to all bees in its place each turn. We have not provided you with a class header. Implement the TankAnt class from scratch. Give it a class attribute name with the value 'Tank' (so that the graphics work) and a class attribute implemented with the value True (so that you can use it in a game). You should not need to modify any code outside of the TankAnt class. If you find yourself needing to make changes elsewhere, look for a way to write your code for the previous question such that it applies not just to BodyguardAnt and TankAnt objects, but to container ants in general. According to the description, we can know that TankAnt is a special kind of ContainerAntI its attack method is quite special: the attack method of the ant it protects + deals its damage to all the bees in the same place class TankAnt(ContainerAnt): name = 'Tank' damage = 1 food_cost = 6 implemented = True def __init__(self, health=2): super().__init__(health) def action(self, gamestate): if self.ant_contained is not None: self.ant_contained.action(gamestate) # 1 damage for all the bees for bee in self.place.bees[:]: bee.reduce_health(self.damage) ","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/:4:4","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Phase 4: Water and Might ","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/:5:0","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Problem 10 (1 pt) Let‚Äôs add water to the colony! Currently there are only two types of places, the Hive and a basic Place. To make things more interesting, we‚Äôre going to create a new type of Place called Water. Only an insect that is waterproof can be placed in Water. In order to determine whether an Insect is waterproof, add a new class attribute to the Insect class named is_waterproof that is set to False. Since bees can fly, set their is_waterproof attribute to True, overriding the inherited value. Now, implement the add_insect method for Water. First, add the insect to the place regardless of whether it is waterproof. Then, if the insect is not waterproof, reduce the insect‚Äôs health to 0. Do not repeat code from elsewhere in the program. Instead, use methods that have already been defined. In order to make the game more interesting, we will add a new kind of Place - Water, only creatures with is_waterproof = True can be placed in(Of course, bees can fly, ants can‚Äôt) Add the class attribute is_waterproof in many classes, I will only put the code of the Water class below class Water(Place): \"\"\"Water is a place that can only hold waterproof insects.\"\"\" def add_insect(self, insect): \"\"\"Add an Insect to this place. If the insect is not waterproof, reduce its health to 0.\"\"\" super().add_insect(insect) if not insect.is_waterproof: insect.reduce_health(insect.health) ","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/:5:1","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Problem 11 (1 pt) Currently there are no ants that can be placed on Water. Implement the ScubaThrower, which is a subclass of ThrowerAnt that is more costly and waterproof, but otherwise identical to its base class. A ScubaThrower should not lose its health when placed in Water. We have not provided you with a class header. Implement the ScubaThrower class from scratch. Give it a class attribute name with the value 'Scuba' (so that the graphics work) and remember to set the class attributeimplemented with the value True (so that you can use it in a game). Implementing a ScubaThrower from scratch, it can be seen from the name that it should be a special ThrowerAnt. It can be placed in Water ! class ScubaThrower(ThrowerAnt): name = 'Scuba' food_cost = 6 is_waterproof = True implemented = True def __init__(self, health=1): super().__init__(health) ","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/:5:2","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Problem 12 (3 pt) Finally, implement the QueenAnt. The queen is a waterproof ScubaThrower that inspires her fellow ants through her bravery. In addition to the standard ScubaThrower action, the QueenAnt doubles the damage of all the ants behind her each time she performs an action. Once an ant‚Äôs damage has been doubled, it is not doubled again for subsequent turns. However, with great power comes great responsibility. The QueenAnt is governed by three special rules: If the queen ever has its health reduced to 0, the ants lose. You will need to override Ant.reduce_health in QueenAnt and call ants_lose() in that case in order to signal to the simulator that the game is over. (The ants also still lose if any bee reaches the end of a tunnel.) There can be only one queen. A second queen cannot be constructed. To check if an Ant can be constructed, we use the Ant.construct() class method to either construct an Ant if possible, or return None if not. You will need to override Ant.construct as a class method of QueenAnt in order to add this check. To keep track of whether a queen has already been created, you can use an instance variable added to the current GameState. The queen cannot be removed. Attempts to remove the queen should have no effect (but should not cause an error). You will need to override Ant.remove_from in QueenAnt to enforce this condition. Finally, we came to the last question (except the extra questions), we have to implement a queen antüêú. It has the following features: It can be placed in water Thought: The description also said that it is a kind of ScrubaThrower After it moves, it will double the attack power of the ants behind it, but not multiple times!!! Thought: How to express the relationship of ‚Äúbehind‚Äù? From the previous topic, we know the colony is a double linked list. The right side is the positive direction, so ‚Äúbehind‚Äù is actually corresponding to the left side. We can access the .exit method of Place to get all the ants behind. Thought: How to indicate that it cannot be doubled multiple times? It is easy to think that we need to set a flag to indicate whether the current ant has doubled its attack power. So we can directly add an instance variable to the Ant class Thought: Pay attention to how to deal with the GuardAnt here, because the ant it contains may be replaced by a new one. At this time we have to double the attack power of this new ant inside. There can only be one queen antüêú Thought: How to make it possible that even if we call the constructor of queen ants üêú many times, there will be exactly only one queen antüêú? This depends on a class called GameState. We can add a has_queen variable to the GameState class to indicate whether the queen antüêú has been created. Queen Ant üêú cannot be removed That‚Äôs easy. The final code is probably as follows: class QueenAnt(ScubaThrower): \"\"\"The Queen of the colony. The game is over if a bee enters her place.\"\"\" name = 'Queen' food_cost = 7 implemented = True # Change to True to view in the GUI @classmethod def construct(cls, gamestate): \"\"\" Returns a new instance of the Ant class if it is possible to construct, or returns None otherwise. Remember to call the construct() method of the superclass! \"\"\" if cls.food_cost \u003e gamestate.food: print('Not enough food remains to place ' + cls.__name__) return # I add a class variable to indict if we have created a QueenAnt() if not gamestate.has_queen: gamestate.has_queen = True return super().construct(gamestate) else: return None def action(self, gamestate): \"\"\"A queen ant throws a leaf, but also doubles the damage of ants in her tunnel. \"\"\" super().action(gamestate) pos = self.place.exit while pos: if pos.ant is not None: if not pos.ant.is_doubled: pos.ant.is_doubled = True pos.ant.buff() if pos.ant.is_container and pos.ant.ant_contained is not None: # the pos.ant.ant_contained may change if not pos.ant.ant_contained.is_doubled: pos.ant.ant_contained.buff() pos.ant.ant_contained.is_doubled = True pos = pos.exit def ","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/:5:3","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Extra Credit (2 pt) Implement two final thrower ants that do zero damage, but instead apply a temporary ‚Äústatus‚Äù on the actionmethod of a Bee instance that they throw_at. This ‚Äústatus‚Äù lasts for a certain number of turns, after which it ceases to take effect. We will be implementing two new ants that inherit from ThrowerAnt. SlowThrower throws sticky syrup at a bee, slowing it for 3 turns. When a bee is slowed, it can only move on turns when gamestate.time is even, and can do nothing otherwise. If a bee is hit by syrup while it is already slowed, it is slowed for an additional 3 turns. ScaryThrower intimidates a nearby bee, causing it to back away instead of advancing. (If the bee is already right next to the Hive and cannot go back further, it should not move. To check if a bee is next to the Hive, you might find the is_hive instance attribute of Places useful). Bees remain scared until they have tried to back away twice. Bees cannot try to back away if they are slowed and gamestate.time is odd. Once a bee has been scared once, it can‚Äôt be scared ever again. Implement two special types of ants, which do no damage themselves, but add debuffs to bees. SlowThrower can slow down the bees, so that they can only move forward when the current time is even. This effect can last for 3 turns, but **we can slow the bees as many times as we want. ScaryThrower will make the bee move back(if you can‚Äôt move back, just keep still). This effect lasts for 2 turns. But if it is slowed, it will continue to stay still. This kind of debuff only can last time This question, really, is completely difficult. I debug the code for a long time before I succeeded. Let me talk about the design ideas: SlowThrower Set the is_slow variable to indicate whether the current bee is being slowed down, and set another variable called slow_turns to remember how many turns left to cancel this state Every turn, if the current bee is slowed down, it needs to check if the current gametime is an even number, if it is, it can move forward, otherwise stay in place, but no matter if you are moving, slow_turns -= 1 forever established ScaryThrower is_scared and scared_turns are set like is_slow and slow_turns Firstly, we don‚Äôt consider whether the current bee is slowed down for now (it‚Äôs easier to think about it this way). Obviously, what we need to do every turn is to let scared_turns -= 1, and the is_scared state actually determines the bee‚Äôs destination. Now, we will add more complexity to this. It‚Äôs problematic that we didn‚Äôt consider whether we were being slowed down. The description says that if it is slowed down while it is in scared state, it will keep still in its place. However, we let scared_turns -= 1 anyway, so we need to add one more judgment here, that is, in the case of being decelerated + being scared, if we do not move successfully, then we need to undo our changes to scared_turns The code is as follows: class Bee(Insect): \"\"\"A Bee moves from place to place, following exits and stinging ants.\"\"\" name = 'Bee' damage = 1 is_waterproof = True # 2 flags is_slow = False is_scared = False # turns remained slow_turns = 0 scared_turns = 0 # we can't scare a bee twice has_been_scared = False def action(self, gamestate): \"\"\"A Bee's action stings the Ant that blocks its exit if it is blocked, or moves to the exit of its current place otherwise. gamestate -- The GameState, used to access game state information. \"\"\" if self.is_scared: destination = self.place.entrance self.scared_turns -= 1 else: destination = self.place.exit if self.is_slow: self.slow_turns -= 1 if self.slow_turns == 0: self.is_slow = False if gamestate.time % 2 == 0 and self.health \u003e 0 and destination is not None: self.move_to(destination) elif self.is_scared: # is_slow + is_scared + gamestate.time is odd, we need to cancel `self.scared_turns -= 1` \\ # if we didn't move self.scared_turns += 1 else: if self.blocked(): self.sting(self.place.ant) elif self.health \u003e 0 and destination is not None: self.mo","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/:5:4","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Optional Problems ","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/:6:0","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Optional Problem 1 Implement the NinjaAnt, which damages all Bees that pass by, but can never be stung. A NinjaAnt does not block the path of a Bee that flies by. To implement this behavior, first modify the Ant class to include a new class attribute blocks_path that is set to True, then override the value of blocks_path to Falsein the NinjaAnt class. Second, modify the Bee‚Äôs method blocked to return False if either there is no Ant in the Bee‚Äôs place or if there is an Ant, but its blocks_path attribute is False. Now Bees will just fly past NinjaAnts. Finally, we want to make the NinjaAnt damage all Bees that fly past. Implement the action method in NinjaAntto reduce the health of all Bees in the same place as the NinjaAnt by its damage attribute. Similar to the FireAnt, you must iterate over a potentially changing list of bees. Ninja Antü•∑üêú, pay attention to a few details: Cannot be attacked by bees It will not block the bees, but will cause harm to the passing bees This problem is relatively simple, and the solutions are indicated by the description. class Bee(Insect): \"\"\"A Bee moves from place to place, following exits and stinging ants.\"\"\" def blocked(self): \"\"\"Return True if this Bee cannot advance to the next Place.\"\"\" if self.place.ant is None: return False if not self.place.ant.blocks_path: return False return True class NinjaAnt(Ant): \"\"\"NinjaAnt does not block the path and damages all bees in its place. This class is optional. \"\"\" name = 'Ninja' damage = 1 food_cost = 5 blocks_path = False implemented = True # Change to True to view in the GUI def action(self, gamestate): for bee in self.place.bees[:]: bee.reduce_health(self.damage) ","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/:6:1","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Optional Problem 2 The LaserAnt shoots out a powerful laser, damaging all that dare to stand in its path. Both Bees and Ants, of all types, are at risk of being damaged by LaserAnt. When a LaserAnt takes its action, it will damage all Insects in its place (excluding itself, but including its container if it has one) and the Places in front of it, excluding the Hive. If that were it, LaserAnt would be too powerful for us to contain. The LaserAnt has a base damage of 2. But, LaserAnt‚Äôs laser comes with some quirks. The laser is weakened by 0.25 each place it travels away fromLaserAnt‚Äôs place. Additionally, LaserAnt has limited battery. Each time LaserAnt actually damages an Insect its laser‚Äôs total damage goes down by 0.0625 (1/16). If LaserAnt‚Äôs damage becomes negative due to these restrictions, it simply does 0 damage instead. Laser üêú, pay attention to several features: Damage all creatures in your own place, including all creatures in the entire colony But each time it deals damage to other creatures, the damage will decrease, minus 0.0625 each time The power of the laser is also related to its distance from the laser antsüêú. For each additional place, the distance will be subtracted by 0.25 Just handle two functions calculate_damage : Note that if the calculated damage is \u003c 0, then you need to return 0 instead. insects_in_front : This returns a dict indicating the distance of each creature from the laser üêú. I divided it into the current place and the remaining places to process, and I calculate the distance while traversing all places. class LaserAnt(ThrowerAnt): name = 'Laser' food_cost = 10 implemented = True # Change to True to view in the GUI damage = 2 def __init__(self, health=1): super().__init__(health) self.insects_shot = 0 self.current_damage = LaserAnt.damage def insects_in_front(self): \"\"\"Return a dict contains every Insect\"\"\" dis = {} for bee in self.place.bees: dis[bee] = 0 # take care of the ContainerAnt if self.place.ant is not self: dis[self.place.ant] = 0 pos = self.place.entrance distance = 1 while pos.entrance is not None: if not pos.is_hive: for bee in pos.bees: dis[bee] = distance if pos.ant is not None: dis[pos.ant] = distance # take care of the ContainerAnt if pos.ant.is_container and pos.ant.ant_contained is not None: dis[pos.ant.ant_contained] = distance distance += 1 pos = pos.entrance return dis def calculate_damage(self, distance): damage_result = self.damage - 0.0625 * self.insects_shot - 0.25 * distance return damage_result if damage_result \u003e 0 else 0 def action(self, gamestate): insects_and_distances = self.insects_in_front() for insect, distance in insects_and_distances.items(): damage = self.calculate_damage(distance) insect.reduce_health(damage) if damage: self.insects_shot += 1 ","date":"2022-03-10","objectID":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/:6:2","tags":["Course","Python"],"title":"Proj3.Ants vs SomeBees of CS61A of UCB(2021-Fall)","uri":"/proj3.ants-vs-somebees-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"the simple solutions for lab14 of CS61A of UCB","date":"2022-03-03","objectID":"/lab14-cs61a-of-ucb/","tags":["Course","Python"],"title":"Lab14 CS61A of UCB(2021-Fall)","uri":"/lab14-cs61a-of-ucb/"},{"categories":["Course"],"content":"Trees ","date":"2022-03-03","objectID":"/lab14-cs61a-of-ucb/:1:0","tags":["Course","Python"],"title":"Lab14 CS61A of UCB(2021-Fall)","uri":"/lab14-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q1: Prune Min Write a function that prunes a Tree t mutatively. t and its branches always have zero or two branches. For the trees with two branches, reduce the number of branches from two to one by keeping the branch that has the smaller label value. Do nothing with trees with zero branches. Prune the tree in a direction of your choosing (top down or bottom up). The result should be a linear tree. The details: the leaf node: It is the base case, we return a node with only one branch: the current node meets the requirements of the description. However, its subtree may violate. So we still need to recursively process the branches. a node with two branches: Find the smaller one, and del the bigger one. def prune_min(t): \"\"\"Prune the tree mutatively. \"\"\" # base case: the leaf node has 0 children if t.is_leaf(): return # go deeper if it has 1 child if len(t.branches) == 1: prune_min(t.branches[0]) left, right = t.branches[0], t.branches[1] if left.label \u003c right.label: del t.branches[1] # prune right branch prune_min(left) else: del t.branches[0] # prune left branch prune_min(right) ","date":"2022-03-03","objectID":"/lab14-cs61a-of-ucb/:1:1","tags":["Course","Python"],"title":"Lab14 CS61A of UCB(2021-Fall)","uri":"/lab14-cs61a-of-ucb/"},{"categories":["Course"],"content":"Regex ","date":"2022-03-03","objectID":"/lab14-cs61a-of-ucb/:2:0","tags":["Course","Python"],"title":"Lab14 CS61A of UCB(2021-Fall)","uri":"/lab14-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q4: Address First Line Write a regular expression that parses strings and returns any expressions which contain the first line of a US mailing address. US mailing addresses typically contain a block number, which is a sequence of 3-5 digits, following by a street name. The street name can consist of multiple words but will always end with a street type abbreviation, which itself is a sequence of 2-5 English letters. The street name can also optionally start with a cardinal direction (‚ÄúN‚Äù, ‚ÄúE‚Äù, ‚ÄúW‚Äù, ‚ÄúS‚Äù). Everything should be properly capitalized. Proper capitalization means that the first letter of each name is capitalized. It is fine to have things like ‚ÄúWeirdCApitalization‚Äù match. See the doctests for some examples. The details of the regex: a block number has a sequence of 3-5 digits The street name may contain multiple words, but the last one should be the abbreviation(2-5 English letters) The street name may start with one of ‚ÄúN‚Äù, ‚ÄúE‚Äù, ‚ÄúW‚Äù, ‚ÄúS‚Äù ps. The word should be properly capitalized(check the description) Let‚Äôs break down this problem: a block number: \\d{2,5} is enough The possible prefix - ‚ÄúN‚Äù, ‚ÄúE‚Äù, ‚ÄúW‚Äù, ‚ÄúS‚Äù. Use (?:[NSWE] )?. Keep in mind that it has whitespace inside The street name: we should first have a word, then we can repeat the whitespace + word combination as many times as we want. ‚úÖ [A-Z][A-Za-z]*(?: [A-Z][A-Za-z]*)*. The abbreviation: Why do I use {1,4} instead of {2,5}? The length of the abbreviation is between 2 and 5. However, after excluding the first capitalized letter, it should be in the range of 1 - 4. def address_oneline(text): \"\"\" Finds and returns expressions in text that represent the first line of a US mailing address. \"\"\" block_number = r'\\d{3,5}' cardinal_dir = r'(?:[NSWE] )?' # whitespace is important! street = r'[A-Z][A-Za-z]*(?: [A-Z][A-Za-z]*)*' type_abbr = r' [A-Z][A-Za-z]{1,4}\\b' street_name = f\"{cardinal_dir}{street}{type_abbr}\" return re.findall(f\"{block_number} {street_name}\", text) ","date":"2022-03-03","objectID":"/lab14-cs61a-of-ucb/:2:1","tags":["Course","Python"],"title":"Lab14 CS61A of UCB(2021-Fall)","uri":"/lab14-cs61a-of-ucb/"},{"categories":["Course"],"content":"SQL ","date":"2022-03-03","objectID":"/lab14-cs61a-of-ucb/:3:0","tags":["Course","Python"],"title":"Lab14 CS61A of UCB(2021-Fall)","uri":"/lab14-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q5: Opening Times You‚Äôd like to have lunch before 1pm. Create a opening table with the names of all Pizza places that open before 1pm, listed in reverse alphabetical order. Find the pizza place whose opening time is before 1:00 pm. Note that the time in the database is the 24-hour clock CREATE TABLE opening AS SELECT name FROM pizzas WHERE open \u003c 13 ORDER BY name DESC; ","date":"2022-03-03","objectID":"/lab14-cs61a-of-ucb/:3:1","tags":["Course","Python"],"title":"Lab14 CS61A of UCB(2021-Fall)","uri":"/lab14-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q6: Double Pizza If two meals are more than 6 hours apart, then there‚Äôs nothing wrong with going to the same pizza place for both, right? Create a double table with three columns. The first columns is the earlier meal, the second is the later meal, and the third is the name of a pizza place. Only include rows that describe two meals that are more than 6 hours apart and a pizza place that is open for both of the meals. The rows may appear in any order. The details: Two meals should be more than 6 hours apart. The start time of the first meal and the end time of the second meal must be within the business hours of the restaurant create TABLE double AS SELECT m1.meal, m2.meal, p.name FROM meals AS m1, meals AS m2, pizzas AS p WHERE m2.time - m1.time \u003e 6 AND m1.time \u003e= p.open AND m2.time \u003c= p.close; ","date":"2022-03-03","objectID":"/lab14-cs61a-of-ucb/:3:2","tags":["Course","Python"],"title":"Lab14 CS61A of UCB(2021-Fall)","uri":"/lab14-cs61a-of-ucb/"},{"categories":["Course"],"content":"Objects ","date":"2022-03-03","objectID":"/lab14-cs61a-of-ucb/:4:0","tags":["Course","Python"],"title":"Lab14 CS61A of UCB(2021-Fall)","uri":"/lab14-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q7: Player First, let‚Äôs implement the Player class. Fill in the debate and speech methods, that take in another Player other, and implement the correct behavior as detailed above. Here are two additional things to keep in mind: In the debate method, you should call the provided random function, which returns a random float between 0 and 1. The player should gain 50 popularity if the random number is smaller than the probability described above, and lose 50 popularity otherwise. Neither players‚Äô popularity should ever become negative. If this happens, set it equal to 0 instead. The calculation method has been given in the description. Note that both of votes and popularity need to be modified in the speech method class Player: def __init__(self, name): self.name = name self.votes = 0 self.popularity = 100 def debate(self, other): prob1 = max(0.1, self.popularity / (self.popularity + other.popularity)) #prob2 = max(0.1, other.popularity / (self.popularity + other.popularity)) if random() \u003e prob1: self.popularity -= 50 else: self.popularity += 50 if self.popularity \u003c 0: self.popularity = 0 def speech(self, other): self.votes += (self.popularity // 10) self.popularity += (self.popularity // 10) other.popularity -= (other.popularity // 10) def choose(self, other): return self.speech ","date":"2022-03-03","objectID":"/lab14-cs61a-of-ucb/:4:1","tags":["Course","Python"],"title":"Lab14 CS61A of UCB(2021-Fall)","uri":"/lab14-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q8: Game Now, implement the Game class. Fill in the play method, which should alternate between the two players, starting with p1, and have each player take one turn at a time. The choose method in the Player class returns the method, either debate or speech, that should be called to perform the action. In addition, fill in the winner property method, which should return the player with more votes, or None if the players are tied. We determine who is the current player based on whether self.turn is odd or even. Note that the choose method returns a function, so we need to pass the parameters class Game: def __init__(self, player1, player2): self.p1 = player1 self.p2 = player2 self.turn = 0 def play(self): while not self.game_over: if self.turn % 2 == 0: self.p1.choose(self.p2)(self.p2) else: self.p2.choose(self.p1)(self.p1) self.turn += 1 return self.winner @property def game_over(self): return max(self.p1.votes, self.p2.votes) \u003e= 50 or self.turn \u003e= 10 @property def winner(self): if self.p1.votes \u003e self.p2.votes: return self.p1 else: return self.p2 ","date":"2022-03-03","objectID":"/lab14-cs61a-of-ucb/:4:2","tags":["Course","Python"],"title":"Lab14 CS61A of UCB(2021-Fall)","uri":"/lab14-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q9: New Players The choose method in the Player class is boring, because it always returns the speech method. Let‚Äôs implement two new classes that inherit from Player, but have more interesting choose methods. Implement the choose method in the AggressivePlayer class, which returns the debate method if the player‚Äôs popularity is less than or equal to other‚Äôs popularity, and speech otherwise. Also implement the choose method in the CautiousPlayer class, which returns the debate method if the player‚Äôs popularity is 0, and speech otherwise. :) class AggressivePlayer(Player): def choose(self, other): if self.popularity \u003c= other.popularity: return self.debate else: return self.speech class CautiousPlayer(Player): def choose(self, other): if self.popularity == 0: return self.debate else: return self.speech ","date":"2022-03-03","objectID":"/lab14-cs61a-of-ucb/:4:3","tags":["Course","Python"],"title":"Lab14 CS61A of UCB(2021-Fall)","uri":"/lab14-cs61a-of-ucb/"},{"categories":["Course"],"content":"Tree Recursion ","date":"2022-03-03","objectID":"/lab14-cs61a-of-ucb/:5:0","tags":["Course","Python"],"title":"Lab14 CS61A of UCB(2021-Fall)","uri":"/lab14-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q10: Add trees Define the function add_trees, which takes in two trees and returns a new tree where each corresponding node from the first tree is added with the node from the second tree. If a node at any particular position is present in one tree but not the other, it should be present in the new tree as well. Hint: You may want to use the built-in zip function to iterate over multiple sequences at once. This problem asks us to add one tree to another. Note who is the subject (useful for later thinking about how to solve it recursively). How to solve it with recursion? base case: We are adding the tree t2 to the tree t1. What if t2 is None, do t2 still need to be added? No, this is one of our base cases ü§ó. On the basis that t2 is not None, what if t1 is empty? Obviously, the result of adding two trees at this time is t2, so we can just return t2. recursive decomposition At this time, we can guarantee that t1 and t2 are both non-empty, but we can‚Äôt guarantee that they have the same number of children, so we can‚Äôt use zip according to the hint. Because when zip is processing the two sequences of different lengths, some elements of the longer one are ignored. The zip_longest in itertools should be used here, and None will be returned if a sequence is already empty. This way we can guarantee that this recursive call will eventually come to the base case we discussed earlier. (Don‚Äôt forget to write from itertools import zip_longest) Then what we do at the current node is: add the labels of the two nodes, and then recursively call add_trees on their subtrees. üöÄ def add_trees(t1, t2): # base case: no need to add_trees anymore if t2 is None: return t1 if t1 is None: return t2 else: # both of t1 and t2 are not None # however, the number of children may not equal return Tree(t1.label + t2.label, [add_trees(x, y) for x, y in zip_longest(t1.branches, t2.branches)]) ","date":"2022-03-03","objectID":"/lab14-cs61a-of-ucb/:5:1","tags":["Course","Python"],"title":"Lab14 CS61A of UCB(2021-Fall)","uri":"/lab14-cs61a-of-ucb/"},{"categories":["Course"],"content":"Linked Lists ","date":"2022-03-03","objectID":"/lab14-cs61a-of-ucb/:6:0","tags":["Course","Python"],"title":"Lab14 CS61A of UCB(2021-Fall)","uri":"/lab14-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q11: Fold Left Write the left fold function by filling in the blanks. This is calculated from top to bottom, that is, we will calculate the result before entering deeper recursive calls. When we reach the empty node (indicating that we have done all the operations), we get the z in the base case, but it is not the original z at the first call, but the z of the operation result we want to get at the end. def foldl(link, fn, z): \"\"\" Left fold \u003e\u003e\u003e lst = Link(3, Link(2, Link(1))) \u003e\u003e\u003e foldl(lst, sub, 0) # (((0 - 3) - 2) - 1) -6 \u003e\u003e\u003e foldl(lst, add, 0) # (((0 + 3) + 2) + 1) 6 \u003e\u003e\u003e foldl(lst, mul, 1) # (((1 * 3) * 2) * 1) 6 \"\"\" if link is Link.empty: return z z = fn(z, link.first) return foldl(link.rest, fn, z) ","date":"2022-03-03","objectID":"/lab14-cs61a-of-ucb/:6:1","tags":["Course","Python"],"title":"Lab14 CS61A of UCB(2021-Fall)","uri":"/lab14-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q12: Fold Right Now write the right fold function. In fact, this problem will be simpler than Q1, and it is more in line with our understanding of recursion. We return the result operation layer by layer from the bottom layer. You can see the following examples to understand this def foldr(link, fn, z): \"\"\" Right fold \u003e\u003e\u003e lst = Link(3, Link(2, Link(1))) \u003e\u003e\u003e foldr(lst, sub, 0) # (3 - (2 - (1 - 0))) 2 \u003e\u003e\u003e foldr(lst, add, 0) # (3 + (2 + (1 + 0))) 6 \u003e\u003e\u003e foldr(lst, mul, 1) # (3 * (2 * (1 * 1))) 6 \"\"\" if link.rest is Link.empty: return fn(link.first, z) return fn(link.first, foldr(link.rest, fn, z)) ","date":"2022-03-03","objectID":"/lab14-cs61a-of-ucb/:6:2","tags":["Course","Python"],"title":"Lab14 CS61A of UCB(2021-Fall)","uri":"/lab14-cs61a-of-ucb/"},{"categories":["Course"],"content":"Regex ","date":"2022-03-03","objectID":"/lab14-cs61a-of-ucb/:8:0","tags":["Course","Python"],"title":"Lab14 CS61A of UCB(2021-Fall)","uri":"/lab14-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q13: Basic URL Validation In this problem, we will write a regular expression which matches a URL. URLs look like the following: For example, in the link https://cs61a.org/resources/#regular-expressions, we would have: Scheme: https Domain Name: cs61a.org Path to the file: /resources/ Anchor: #regular-expressions The port and parameters are not present in this example and you will not be required to match them for this problem. You can reference this documentation from MDN if you‚Äôre curious about the various parts of a URL. For this problem, a valid domain name consists of any sequence of letters, numbers, dashes, and periods. For a URL to be ‚Äúvalid,‚Äù it must contain a valid domain name and will optionally have a scheme, path, and anchor. A valid scheme will either be http or https. Valid paths start with a slash and then must be a valid path to a file or directory. This means they should match something like /composingprograms.html or path/to/file but not /composing.programs.html/. A valid anchor starts with #. While they are more complicated, for this problem assume that valid anchors will then be followed by letters, numbers, hyphens, or underscores. Hint 1: You can use \\ to escape special characters in regex. \u003eHint 2: The provided code already handles making the scheme, path, and anchor optional by using non-capturing groups. The details: scheme : Either http or https, which can be expressed by (?:...). domain : The www may show at the beginning of the domain, which can be expressed by (?:...)? path to the file: /path/to/file.extension, /path, /file.extension. They are all valid anchor : letters, numbers, hyphens, or underscores. def match_url(text): scheme = r'(?:https|http)://' domain = r'(?:\\w+\\.)?\\w+\\.\\w+' path = r'(?:/\\w+|/(\\w+/)*)(\\w+\\.\\w+)?' anchor = r'#[\\w\\-_]*' return bool(re.match(rf\"^(?:{scheme})?{domain}(?:{path})?(?:{anchor})?$\", text)) ","date":"2022-03-03","objectID":"/lab14-cs61a-of-ucb/:8:1","tags":["Course","Python"],"title":"Lab14 CS61A of UCB(2021-Fall)","uri":"/lab14-cs61a-of-ucb/"},{"categories":["Course"],"content":"BNF ","date":"2022-03-03","objectID":"/lab14-cs61a-of-ucb/:9:0","tags":["Course","Python"],"title":"Lab14 CS61A of UCB(2021-Fall)","uri":"/lab14-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q14: Simple CSV CSV, which stands for ‚ÄúComma Separated Values,‚Äù is a file format to store columnar information. We will write a BNF grammar for a small subset of CSV, which we will call SimpleCSV. Create a grammar that reads SimpleCSV, where a file contains rows of words separated by commas. Words are characters [a-zA-Z] (and may be blank!) Spaces are not allowed in the file. Write the BNF of a simple csv file. It is simple because: the value can only be a word, and them should be seperated by , The details: There may be cases of ,,,, so we need to use | in word to count the cases where no characters are placed lines: line (newline line)* | line newline | line line: word (\",\" word)* word: WORD | newline: \"\\n\" %import common.WORD ","date":"2022-03-03","objectID":"/lab14-cs61a-of-ucb/:9:1","tags":["Course","Python"],"title":"Lab14 CS61A of UCB(2021-Fall)","uri":"/lab14-cs61a-of-ucb/"},{"categories":["Course"],"content":"The simple solutions of hw10 of CS61A of UCB","date":"2022-03-02","objectID":"/hw10-of-cs61a-of-ucb/","tags":["Course","BNF","Mysql"],"title":"Hw10 of CS61A of UCB(2021-Fall)","uri":"/hw10-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"BNF ","date":"2022-03-02","objectID":"/hw10-of-cs61a-of-ucb/:1:0","tags":["Course","BNF","Mysql"],"title":"Hw10 of CS61A of UCB(2021-Fall)","uri":"/hw10-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q1: Grouping and Pipes In this question, you will add support for grouping and piping. Recall that grouping allows for an entire regular expression to be treated as a single unit, and piping allows for a pattern to match an expression on either side. Combined, these will let us create patterns which match multiple strings! Define the group and pipe expressions in your grammar. A group consists of any regex expression surrounded by parentheses (()). A pipe operator consists of a regex expression, followed by a pipe (|) character, and lastly followed by another regex expression. For example, r\"apples\" would match exactly the phrase ‚Äúapples‚Äù in an input. If we wanted our pattern from before to match ‚Äúoranges‚Äù as well, we could expand our rstring to do so using groupings and pipes: r\"(apples)|(oranges)\". Hint: note that groups and pipes are valid regex expressions on their own! You may need to update a previously defined expression. The description indicates the way to solve this problem. Remember that the group and the pipe are a part of ?regex, so we should add them to ?regex. ?start: rstring rstring: \"r\\\"\" regex* \"\\\"\" ?regex: character | word | group | pipe group: \"(\" regex* \")\" pipe: regex \"|\" regex character: LETTER | NUMBER word: WORD %ignore /\\s+/ %import common.LETTER %import common.NUMBER %import common.WORD ","date":"2022-03-02","objectID":"/hw10-of-cs61a-of-ucb/:1:1","tags":["Course","BNF","Mysql"],"title":"Hw10 of CS61A of UCB(2021-Fall)","uri":"/hw10-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q2: Classes Now, we will add support for character classes. Recall that character classes allow for the pattern to match any singular character defined within the class. The class itself consists either of individual characters, or ranges of characters. Specifically, we define the following: A range consists of either NUMBERs or LETTERs separated by a hyphen (-). A class expression consists of any number of characters or character ranges surrounded by square brackets ([]). Note that for this question, a range may only consist of either NUMBERs or LETTERs; this means that while [0-9] and [A-Z] are valid ranges, [0-Z] would not be a valid range. In addition, the characters and ranges in a class may appear in any order and any number of times. For example, [ad-fc0-9], [ad-f0-9c], [a0-9d-fc], and [0-9ad-fc] are all valid classes. The details: range : character \"-\" character is wrong ‚ùå. For example, [0-z] is illegal. Because the order in which range and character appear in [] is arbitrary, we can use *, both of which may be at the beginning or end of [] class itself is also a valid regular expression, so it should be placed inside ?regex ?start: rstring rstring: \"r\\\"\" regex* \"\\\"\" ?regex: character | word | group | pipe | class group: \"(\" regex* \")\" pipe: regex \"|\" regex range: NUMBER \"-\" NUMBER | LETTER \"-\" LETTER class: \"[\" range* character* range* character* \"]\" character: LETTER | NUMBER word: WORD %ignore /\\s+/ %import common.LETTER %import common.NUMBER %import common.WORD ","date":"2022-03-02","objectID":"/hw10-of-cs61a-of-ucb/:1:2","tags":["Course","BNF","Mysql"],"title":"Hw10 of CS61A of UCB(2021-Fall)","uri":"/hw10-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q3: Quantifiers Lastly, we will add support for quantifiers. Recall that quantifiers allow for a pattern to match a specified number of a unit. Specifically, we define the following: A plus_quant expression consists of a group, a character, or a class, followed by a plus symbol (+). A star_quant expression consists of a group, a character, or a class, followed by a star symbol (*). A num_quant expression consists of either a group, a character, or a class, followed by one of the following: a NUMBER enclosed in curly braces ({}); a range of NUMBERs (separated by a comma (,), which may potentially be open on only one side. For example, {2,7}, {2,}, and {,7} are valid numeric quantifiers. {,} is not valid. Hint: these three quantifiers share many similarities. Consider defining additional expressions in this question! We can make a ?tmp: class | group | character to represent the similarities. Also, we can define ?quants: plus_quant | star_quant | num_quant rstring: \"r\\\"\" regex* \"\\\"\" ?regex: character | word | group | pipe | class | quants group: \"(\" regex* \")\" pipe: regex \"|\" regex range: NUMBER \"-\" NUMBER | LETTER \"-\" LETTER class: \"[\" range* character* range* character* \"]\" ?tmp: class | group | character plus_quant: tmp \"+\" star_quant: tmp \"*\" num_quant: tmp \"{\" ((NUMBER \",\" NUMBER) | (NUMBER \",\" NUMBER?) | (\",\" NUMBER)) \"}\" ?quants: plus_quant | star_quant | num_quant character: LETTER | NUMBER word: WORD %ignore /\\s+/ %import common.LETTER %import common.NUMBER %import common.WORD ","date":"2022-03-02","objectID":"/hw10-of-cs61a-of-ucb/:1:3","tags":["Course","BNF","Mysql"],"title":"Hw10 of CS61A of UCB(2021-Fall)","uri":"/hw10-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"SQL ","date":"2022-03-02","objectID":"/hw10-of-cs61a-of-ucb/:2:0","tags":["Course","BNF","Mysql"],"title":"Hw10 of CS61A of UCB(2021-Fall)","uri":"/hw10-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q4: Size of Dogs The F√©d√©ration Cynologique Internationale classifies a standard poodle as over 45 cm and up to 60 cm. The sizes table describes this and other such classifications, where a dog must be over the min and less than or equal to the max in height to qualify as a size. Create a size_of_dogs table with two columns, one for each dog‚Äôs name and another for its size. We need to determine the size of the dogs, which can be described as select ... from ... where. CREATE TABLE size_of_dogs AS SELECT d.name, s.size FROM dogs as d, sizes as s where d.height \u003c= s.max and d.height \u003e s.min; ","date":"2022-03-02","objectID":"/hw10-of-cs61a-of-ucb/:2:1","tags":["Course","BNF","Mysql"],"title":"Hw10 of CS61A of UCB(2021-Fall)","uri":"/hw10-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q5: By Parent Height Create a table by_parent_height that has a column of the names of all dogs that have a parent, ordered by the height of the parent from tallest parent to shortest parent. Sort results by height descending by using DESC keyword. CREATE TABLE siblings AS SELECT p1.child AS dogone, p2.child AS dogtwo, s1.size AS dogonesize, s2.size AS dogtwosize FROM parents AS p1, parents AS p2, size_of_dogs AS s1, size_of_dogs AS s2 WHERE p1.parent = p2.parent AND p1.child \u003c p2.child AND p1.child = s1.name AND p2.child = s2.name; -- Use `\u003c` to filter the result -- `!=` is not enough, you will get `barack clinton` and `clinton barack` in the same time ","date":"2022-03-02","objectID":"/hw10-of-cs61a-of-ucb/:2:2","tags":["Course","BNF","Mysql"],"title":"Hw10 of CS61A of UCB(2021-Fall)","uri":"/hw10-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q6: Sentences There are two pairs of siblings that have the same size. Create a table that contains a row with a string for each of these pairs. Each string should be a sentence describing the siblings by their size. Each sibling pair should appear only once in the output, and siblings should be listed in alphabetical order (e.g. \"barack plus clinton...\" instead of \"clinton plus barack...\"), as follows: Hint: First, create a helper table containing each pair of siblings. This will make comparing the sizes of siblings when constructing the main table easier. Hint: If you join a table with itself, use AS within the FROM clause to give each table an alias. Hint: In order to concatenate two strings into one, use the || operator. After finishing Q5, this one should be much easier. CREATE TABLE sentences AS SELECT \"The two siblings, \" || dogone || \" plus \" || dogtwo || \" have the same size: \" || dogonesize FROM siblings WHERE dogonesize = dogtwosize AND dogone \u003c dogtwo; ","date":"2022-03-02","objectID":"/hw10-of-cs61a-of-ucb/:2:3","tags":["Course","BNF","Mysql"],"title":"Hw10 of CS61A of UCB(2021-Fall)","uri":"/hw10-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"the simple solutions for lab12 of CS61A of UCB","date":"2022-03-02","objectID":"/lab12-ca61a-of-ucb/","tags":["Course","Python"],"title":"Lab12 CS61A of UCB(2021-Fall)","uri":"/lab12-ca61a-of-ucb/"},{"categories":["Course"],"content":"Regular Expressions ","date":"2022-03-02","objectID":"/lab12-ca61a-of-ucb/:1:0","tags":["Course","Python"],"title":"Lab12 CS61A of UCB(2021-Fall)","uri":"/lab12-ca61a-of-ucb/"},{"categories":["Course"],"content":"Q1: Calculator Ops Write a regular expression that parses strings written in the 61A Calculator language and returns any expressions which have two numeric operands, leaving out the parentheses around them. We need to write a regular expression to match a pattern - (operand operator1 operator2). The operands consist of +, -, *, /. We can use [] here. Don‚Äôt forget to put a \\ in front of - to escape it. def calculator_ops(calc_str): \"\"\" Finds expressions from the Calculator language that have two numeric operands and returns the expression without the parentheses. \"\"\" return re.findall(r'[+\\-*/] \\d+ \\d+', calc_str) ","date":"2022-03-02","objectID":"/lab12-ca61a-of-ucb/:1:1","tags":["Course","Python"],"title":"Lab12 CS61A of UCB(2021-Fall)","uri":"/lab12-ca61a-of-ucb/"},{"categories":["Course"],"content":"BNF ","date":"2022-03-02","objectID":"/lab12-ca61a-of-ucb/:2:0","tags":["Course","Python"],"title":"Lab12 CS61A of UCB(2021-Fall)","uri":"/lab12-ca61a-of-ucb/"},{"categories":["Course"],"content":"Q3: Linked List BNF In this problem, we‚Äôre going to define a BNF that parses integer Linked Lists created in Python. We won‚Äôt be handling Link.empty. For reference, here are some examples of Linked Lists: Your implementation should be able to handle nested Linked Lists, such as the third example below. Link(2) Link(12, Link(2)) Link(5, Link(7, Link(Link(8, Link(9))))) The idea: The beginning of the linked list must be Link(, and then we can divide the linked list into link_first and link_rest parts, which are either numbers or another linked list(nested). The link_rest can be empty ! link: \"Link(\" link_first \")\" | \"Link(\" link_first \",\" link_rest \")\" ?link_first: NUMBER | link ?link_rest: NUMBER | link %ignore /\\s+/ %import common.NUMBER ","date":"2022-03-02","objectID":"/lab12-ca61a-of-ucb/:2:1","tags":["Course","Python"],"title":"Lab12 CS61A of UCB(2021-Fall)","uri":"/lab12-ca61a-of-ucb/"},{"categories":["Course"],"content":"Q4: Tree BNF Now, we will define a BNF to parse Trees with integer leaves created in Python. Here are some examples of Trees: Your implementation should be able to handle Trees with no branches and one or more branches. Tree(2) Tree(6, [Tree(1), Tree(3, [Tree(1), Tree(2)])]) The BNF of a tree: tree_node: It can a tree with only one node, or a tree with nodes and branches. The number of the branches can by [0, ‚àû), so we can use the * in the regular expression. ?label: NUMBER branches: It can be only one node, or there are multiple nodes (in this case, we need to match the , signs) tree_node: \"Tree(\" label \")\" | \"Tree(\" label \",\" branches* \")\" ?label: NUMBER branches: \"[\" tree_node \"]\" | \"[\" tree_node \",\" tree_node+ \"]\" %ignore /\\s+/ %import common.NUMBER ","date":"2022-03-02","objectID":"/lab12-ca61a-of-ucb/:2:2","tags":["Course","Python"],"title":"Lab12 CS61A of UCB(2021-Fall)","uri":"/lab12-ca61a-of-ucb/"},{"categories":["Course"],"content":"The simple solutions of hw09 of CS61A of UCB","date":"2022-03-01","objectID":"/hw09-of-cs61a-of-ucb/","tags":["Course","Python"],"title":"Hw09 of CS61A of UCB(2021-Fall)","uri":"/hw09-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q2: Roman Numerals Write a regular expression that finds any string of letters that resemble a Roman numeral and aren‚Äôt part of another word. A Roman numeral is made up of the letters I, V, X, L, C, D, M and is at least one letter long. For the purposes of this problem, don‚Äôt worry about whether or not a Roman numeral is valid. For example, ‚ÄúVIIIII‚Äù is not a Roman numeral, but it is fine if your regex matches it. The details: The letters contain I, V, X, L, C, D, M. We can use [] to represent the logical OR The roman NUmerals is at least one letter long. We can use + to match 1 or more repetitions. The roman NUmerals can not be a part of another word. After checking the documentation, I found \\b is quite useful, which means matching the empty string, but only at the beginning or end of a word. That‚Äôs exactly what we want. def roman_numerals(text): \"\"\" Finds any string of letters that could be a Roman numeral (made up of the letters I, V, X, L, C, D, M). \"\"\" return re.findall(r'\\b[IVXLCDM]+\\b', text) ","date":"2022-03-01","objectID":"/hw09-of-cs61a-of-ucb/:0:1","tags":["Course","Python"],"title":"Hw09 of CS61A of UCB(2021-Fall)","uri":"/hw09-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q3: CS Classes On reddit.com, there is an /r/berkeley subreddit for discussions about everything UC Berkeley. However, there is such a large amount of CS-related posts that those posts are auto-tagged so that readers can choose to ignore them or read only them. Write a regular expression that finds strings that resemble a CS class- starting with ‚ÄúCS‚Äù, followed by a number, and then optionally followed by ‚ÄúA‚Äù, ‚ÄúB‚Äù, or ‚ÄúC‚Äù. Your search should be case insensitive, so both ‚ÄúCS61A‚Äù and ‚Äúcs61a‚Äù would match. The details: Either the CS or the ABC is case insensitive. The former can be solved by |, and the latter can be solved by [] The whitespace may exist between CS and the digits def cs_classes(post): \"\"\" Returns strings that look like a Berkeley CS class, starting with \"CS\", followed by a number, optionally ending with A, B, or C and potentially with a space between \"CS\" and the number. Case insensitive. \"\"\" return bool(re.search(r'cs|CS ?\\d+[ABCabc]?', post)) ","date":"2022-03-01","objectID":"/hw09-of-cs61a-of-ucb/:0:2","tags":["Course","Python"],"title":"Hw09 of CS61A of UCB(2021-Fall)","uri":"/hw09-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q4: Time for Times You‚Äôre given a body of text and told that within it are some times. Write a regular expression which, for a few examples, would match the following: ['05:24', '7:23', '23:59', '12:22', '00:00'] but would not match these invalid ‚Äútimes‚Äù ['05:64', '70:23'] You may find non-capturing groups helpful to use for this question. The legal range of the time: 00:00 ~ 23:59 The details: The first digit and the second digit: The leading 0 may exist. When the first digit is 2, the second digit should be in the range of 0 ~ 3. (2?:?? ~ 23:59) The third digit and the 4th digit: 00 ~ 59. [0-5][0-9] It is a little complicated for a new beginner like me :( The hint shows the (?:) may be helpful, so I have a look at this and suddenly know how to make the regex work üëç. It means matching but not capturing. def match_time(text): return re.findall(r'(?:[01]?\\d|2[0-3]):[0-5][0-9](?:AM)?', text) ","date":"2022-03-01","objectID":"/hw09-of-cs61a-of-ucb/:0:3","tags":["Course","Python"],"title":"Hw09 of CS61A of UCB(2021-Fall)","uri":"/hw09-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q5: Most Common Area Code Write a function which takes in a body of text and finds the most common area code. Area codes must be part of a valid phone number. To solve this problem, we will first write a regular expression which finds valid phone numbers and captures the area code. See the docstring of area_codes for specifics on what qualifies as a valid phone number. We know the area code may appear in the front of a phone number. The task is to find the most common area code. First, we need to implement a function called area_codes to parse a string to get all potential area codes and return. After that, we use list.count to find the most common one. The details. A valid phone number should be 10-digit. The length of the area code is 3. Sometimes, it may have parentheses around. The hyphens and spaces may appear after the third and sixth digits How to match a potential () ? By (?:)? ü§ó def area_codes(text): \"\"\" Finds all phone numbers in text and captures the area code. Phone numbers have 10 digits total and may have parentheses around the area code, and hyphens or spaces after the third and sixth digits. \"\"\" return re.findall(r'(?:\\()?(\\d{3})(?:\\)?)(?: |-)?\\d{3}(?: |-)?\\d{4}\\b', text) def most_common_code(text): \"\"\" Takes in an input string which contains at least one phone number (and may contain more) and returns the most common area code among all phone numbers in the input. If there are multiple area codes with the same frequency, return the first one that appears in the input text. \"\"\" area_codes_list = area_codes(text) cnts = [area_codes_list.count(e) for e in area_codes_list] # count every area_code max_cnt_idx = cnts.index(max(cnts)) # get the index of the max value return area_codes_list[max_cnt_idx] ","date":"2022-03-01","objectID":"/hw09-of-cs61a-of-ucb/:0:4","tags":["Course","Python"],"title":"Hw09 of CS61A of UCB(2021-Fall)","uri":"/hw09-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"the simple solutions for lab11 of CS61A of UCB","date":"2022-03-01","objectID":"/lab11-cs61a-of-ucb/","tags":["Course","Python"],"title":"Lab11 CS61A of UCB(2021-Fall)","uri":"/lab11-cs61a-of-ucb/"},{"categories":["Course"],"content":"Context ","date":"2022-03-01","objectID":"/lab11-cs61a-of-ucb/:1:0","tags":["Course","Python"],"title":"Lab11 CS61A of UCB(2021-Fall)","uri":"/lab11-cs61a-of-ucb/"},{"categories":["Course"],"content":"Problem 1 Important: Your code for this part should go in buffer.py. Your job in this part is to implement the current and pop_first methods of the Buffer class. current should return the current token of the current line we‚Äôre on in the Buffer instance without removing it. If there are no more tokens in the current line, then current should move onto the next valid line, and return the first token of this line. If there are no more tokens left to return from the entire source (we‚Äôve reached the end of all input lines), then current should return None (this logic is already provided for you in the except StopIteration block). If we call current multiple times in a row, we should get the same result since calls to current won‚Äôt change what token we‚Äôre returning. You may find self.index helpful while implementing these functions, but you are not required to reference it in your solution. Hint: What instance attribute can we use to keep track of where we are in the current line? Hint: If we‚Äôve reached the end of the current line, then self.more_on_line() will return False. In that case, how do we ‚Äúreset‚Äù our position to the beginning of the next line? pop_first should return the current token of the Buffer instance, and move onto the next potential token (to be returned on the next call to pop_first). If there are no more tokens left to return from the entire source (we‚Äôve reached the end of all input lines), then pop_first should return None. Hint: Do we need to update anything to move onto the next potential token? We need to implement two functions in this problem: current and pop_first The requirements are listed in the description class Buffer: \"\"\"A Buffer provides a way of accessing a sequence of tokens across lines. Its constructor takes an iterator, called \"the source\", that returns the next line of tokens as a list each time it is queried, or None to indicate the end of data. The Buffer in effect concatenates the sequences returned from its source and then supplies the items from them one at a time through its pop_first() method, calling the source for more sequences of items only when needed. In addition, Buffer provides a current method to look at the next item to be supplied, without sequencing past it. The __str__ method prints all tokens read so far, up to the end of the current line, and marks the current token with \u003e\u003e. \"\"\" def __init__(self, source): self.index = 0 self.source = source self.current_line = () self.current() def pop_first(self): \"\"\"Remove the next item from self and return it. If self has exhausted its source, returns None.\"\"\" current = self.current() self.index += 1 return current def current(self): \"\"\"Return the current element, or None if none exists.\"\"\" # if there are any token in current line we don't return while not self.more_on_line(): self.index = 0 try: self.current_line = next(self.source) except StopIteration: self.current_line = () return None return self.current_line[self.index] def more_on_line(self): return self.index \u003c len(self.current_line) ","date":"2022-03-01","objectID":"/lab11-cs61a-of-ucb/:1:1","tags":["Course","Python"],"title":"Lab11 CS61A of UCB(2021-Fall)","uri":"/lab11-cs61a-of-ucb/"},{"categories":["Course"],"content":"Internal Representations ","date":"2022-03-01","objectID":"/lab11-cs61a-of-ucb/:2:0","tags":["Course","Python"],"title":"Lab11 CS61A of UCB(2021-Fall)","uri":"/lab11-cs61a-of-ucb/"},{"categories":["Course"],"content":"Problem 2 Important: Your code for this part should go in scheme_reader.py. Your job in this part is to write the parsing functionality, which consists of two mutually recursive functions:scheme_read and read_tail. Each function takes in a single src parameter, which is a Buffer instance. scheme_read removes enough tokens from src to form a single expression and returns that expression in the correct internal representation. read_tail expects to read the rest of a list or Pair, assuming the open parenthesis of that list or Pair has already been removed by scheme_read. It will read expressions (and thus remove tokens) until the matching closing parenthesis ) is seen. This list of expressions is returned as a linked list of Pair instances. In short, scheme_read returns the next single complete expression in the buffer and read_tail returns the rest of a list or Pair in the buffer. Both functions mutate the buffer, removing the tokens that have already been processed. The behavior of both functions depends on the first token currently in src. They should be implemented as follows: scheme_read: If the current token is the string \"nil\", return the nil object. If the current token is (, the expression is a pair or list. Call read_tail on the rest of src and return its result. If the current token is ', the rest of the buffer should be processed as a quote expression. You will implement this portion in the next problem. If the next token is not a delimiter, then it must be a primitive expression (i.e. a number, boolean). Return it. Provided If none of the above cases apply, raise an error. Provided read_tail: If there are no more tokens, then the list is missing a close parenthesis and we should raise an error. Provided If the token is ), then we‚Äôve reached the end of the list or pair. Remove this token from the buffer and return the nil object. If none of the above cases apply, the next token is the operator in a combination. For example, src could contain + 2 3). To parse this: scheme_read the next complete expression in the buffer. Call read_tail to read the rest of the combination until the matching closing parenthesis. Return the results as a Pair instance, where the first element is the next complete expression from (1) and the second element is the rest of the combination from (2). The code for this question is put together with the next question :) ","date":"2022-03-01","objectID":"/lab11-cs61a-of-ucb/:2:1","tags":["Course","Python"],"title":"Lab11 CS61A of UCB(2021-Fall)","uri":"/lab11-cs61a-of-ucb/"},{"categories":["Course"],"content":"Problem 3 Important: Your code for this part should go in scheme_reader.py. Your task in this problem is to complete the implementation of scheme_read by allowing the function to now be able to handle quoted expressions. In Scheme, quoted expressions such as '\u003cexpr\u003e are equivalent to (quote \u003cexpr\u003e). That means that we need to wrap the expression following ' (which you can get by recursively calling scheme_read) into the quote special form, which is a Scheme list (as with all special forms). In our representation, a Pair represents a Scheme list. You should therefore wrap the expression following ' in a Pair. For example, 'bagel, or [\"'\", \"bagel\"] after being tokenized, should be represented as Pair('quote', Pair('bagel', nil)). '(1 2) (or [\"'\", \"(\", 1, 2, \")\"]) should be represented as Pair('quote', Pair(Pair(1, Pair(2, nil)), nil)). We need to implement the ' in the scheme language. Actually, the description indicates the way to solve this problem: which you can get by recursively calling scheme_read. We need to make a new Pair, whose first element is quote, and recursively call scheme_reader to handle the expression. def scheme_read(src): \"\"\"Read the next expression from SRC, a Buffer of tokens. \"\"\" if src.current() is None: raise EOFError val = src.pop_first() # Get and remove the first token if val == 'nil': return nil elif val == '(': return read_tail(src) elif val == \"'\": return Pair('quote', Pair(scheme_read(src), nil)) elif val not in DELIMITERS: return val else: raise SyntaxError('unexpected token: {0}'.format(val)) def read_tail(src): \"\"\"Return the remainder of a list in SRC, starting before an element or ). \"\"\" try: if src.current() is None: raise SyntaxError('unexpected end of file') elif src.current() == ')': src.pop_first() return nil else: return Pair(scheme_read(src), read_tail(src)) except EOFError: raise SyntaxError('unexpected end of file') ","date":"2022-03-01","objectID":"/lab11-cs61a-of-ucb/:2:2","tags":["Course","Python"],"title":"Lab11 CS61A of UCB(2021-Fall)","uri":"/lab11-cs61a-of-ucb/"},{"categories":["Course"],"content":"The simple solutions of hw08 of CS61A of UCB","date":"2022-02-28","objectID":"/hw08-of-cs61a-of-ucb/","tags":["Course","Scheme"],"title":"Hw08 of CS61A of UCB(2021-Fall)","uri":"/hw08-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q1: My Filter Write a procedure my-filter, which takes a predicate func and a list lst, and returns a new list containing only elements of the list that satisfy the predicate. The output should contain the elements in the same order that they appeared in the original list. Note: Make sure that you are not just calling the built-in filter function in Scheme - we are asking you to re-implement this! We need to implement a function that contains elements which are qualified (func e) = #t in the list. The base case: an empty list. Otherwise, we check if (car lst) can be kept. (define (my-filter func lst) (cond ((null? lst) '()) ((func (car lst)) (cons (car lst) (my-filter func (cdr lst)))) (else (my-filter func (cdr lst)))) ) ","date":"2022-02-28","objectID":"/hw08-of-cs61a-of-ucb/:0:1","tags":["Course","Scheme"],"title":"Hw08 of CS61A of UCB(2021-Fall)","uri":"/hw08-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q2: Interleave Implement the function interleave, which takes a two lists s1 and s2 as arguments. interleave should return a new list that interleaves the elements of the two lists. (In other words, the resulting list should contain elements alternating between s1 and s2.) If one of the input lists to interleave is shorter than the other, then interleave should alternate elements from both lists until one list has no more elements, and then the remaining elements from the longer list should be added to the end of the new list. It can be solved recursively. The base case: both lists are empty. We need to return nil Notion: the first parameter of interleave - first_param, the second parameter of interleave - second_param We always add (car fist_param) to our result. And then we will recursively call (interleave second_param (cdr first_param)). Apparently, we will add the first element of second_param to our result. Repeat this procedure we will get the correct answer. What if the first list is empty? We call (interleave second_param first_param) instead ü§ó (define (interleave s1 s2) (cond ((and (null? s1) (null? s2)) nil) ; base case: return nil if both are empty ((null? s1) (interleave s2 s1)) ; change the positions of s1 and s2 (else (cons (car s1) (interleave s2 (cdr s1))))) ; we always insert (car s1) to the result :) ) ","date":"2022-02-28","objectID":"/hw08-of-cs61a-of-ucb/:0:2","tags":["Course","Scheme"],"title":"Hw08 of CS61A of UCB(2021-Fall)","uri":"/hw08-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q3: Accumulate Fill in the definition for the procedure accumulate, which merges the first n natural numbers (ie. 1 to n, inclusive) according to the following parameters: merger: a function of two arguments start: a number with which we start merging with n: the number of natural numbers to merge term: a function of one argument that computes the nth term of a sequence For example, we can find the product of all the numbers from 1 to 5 by using the multiplication operator as the merger, and starting our product at 1: We need to calculate the ‚Äúsum‚Äù of the first n natural numbers([1, n]). The definitin of ‚Äúsum‚Äù is defined by merger. We also have term to compute the ith term of a sequence. We can‚Äôt use while loop in scheme(If you don‚Äôt have implement this by yourself). So we need a recursive solution. The base case: n = 1, we merge 1 and start. Otherwise, we will call (accumulate merger start (- n 1) term) :) (define (accumulate merger start n term) (cond ((= n 1) (merger (term n) start)) ; base case: n = 1 (else (merger (term n) (accumulate merger start (- n 1) term)))) ) ","date":"2022-02-28","objectID":"/hw08-of-cs61a-of-ucb/:0:3","tags":["Course","Scheme"],"title":"Hw08 of CS61A of UCB(2021-Fall)","uri":"/hw08-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q4: No Repeats Implement no-repeats, which takes a list of numbers lst as input and returns a list that has all of the unique elements of lst in the order that they first appear, but no repeats. For example, (no-repeats (list 5 4 5 4 2 2))evaluates to (5 4 2). Hint: How can you make the first time you see an element in the input list be the first and only time you see the element in the resulting list you return? Hint: You may find it helpful to use the my-filter procedure with a helper lambda function to use as a filter. To test if two numbers are equal, use the = procedure. To test if two numbers are not equal, use the notprocedure in combination with =. The base case: an empty list. We will return nil. Otherwise, we need to delete all elements that are equal to (car lst) in (cdr lst), which can implemented by the my-filter procedure in Q1. (ps. I have been looking for bugs for a long time because of an extra set of parentheses. üò¢) (define (no-repeats lst) (cond ((null? lst) nil) (else (cons (car lst) (no-repeats ; choose the elements that are not equal to `car lst` (my-filter (lambda (x) (not (= x (car lst)))) (cdr lst)))))) ) ","date":"2022-02-28","objectID":"/hw08-of-cs61a-of-ucb/:0:4","tags":["Course","Scheme"],"title":"Hw08 of CS61A of UCB(2021-Fall)","uri":"/hw08-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"The simple solutions of hw07 of CS61A of UCB","date":"2022-02-27","objectID":"/hw07-of-cs61a-of-ucb/","tags":["Course","Scheme"],"title":"Hw07 of CS61A of UCB(2021-Fall)","uri":"/hw07-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q1: Thane of Cadr Define the procedures cadr and caddr, which return the second and third elements of a list, respectively. If you would like a quick refresher on scheme syntax consider looking at Lab 10 Scheme Refresher. We need to implement the function c???r. To have a better understanding of this notation, you should look from back to the front in ???. For example, the cadr function will call cdr then call car on the input. (define (cadr s) (car (cdr s)) ) (define (caddr s) (car (cdr (cdr s))) ) ","date":"2022-02-27","objectID":"/hw07-of-cs61a-of-ucb/:0:1","tags":["Course","Scheme"],"title":"Hw07 of CS61A of UCB(2021-Fall)","uri":"/hw07-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q2: Ordered Implement a procedure called ordered?, which takes a list of numbers and returns True if the numbers are in nondescending order, and False otherwise. Numbers are considered nondescending if each subsequent number is either larger or equal to the previous, that is: 1 2 3 3 4 Is nondescending, but: 1 2 3 3 2 Is not. Hint: The built-in null? function returns whether its argument is nil. We need to solve this problem recursively: base case: an empty list or a list with a size 1 Recursive decomposition: the current node is less than or equal to the first node of the sub-linked list, and the sub-linked list must also be in non-descending order (define (ordered? s) (cond ( (null? s) #t) ( (null? (cdr s)) #t) ( else (and (\u003c= (car s) (cadr s)) (ordered? (cdr s))))) ) ","date":"2022-02-27","objectID":"/hw07-of-cs61a-of-ucb/:0:2","tags":["Course","Scheme"],"title":"Hw07 of CS61A of UCB(2021-Fall)","uri":"/hw07-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q3: Pow Implement a procedure pow for raising the number base to the power of a nonnegative integer exp for which the number of operations grows logarithmically, rather than linearly (the number of recursive calls should be much smaller than the input exp). For example, for (pow 2 32) should take 5 recursive calls rather than 32 recursive calls. Similarly, (pow 2 64) should take 6 recursive calls. Hint: Consider the following observations: $x^{2y} = (x^y)2$ $x^{2y+1} = x(x^y)2$ For example we see that 232 is (216)2, 216 is (28)2, etc. You may use the built-in predicates even? and odd?. Scheme doesn‚Äôt support iteration in the same manner as Python, so consider another way to solve this problem. The procedure of calculating this (pow base exp) has been provided in the description. (define (pow base exp) (cond ( (= exp 1) base ) ; base^1 = base ( (= exp 0) 1) ; base^0 = 1 ( (= 0 (modulo exp 2)) (begin (define tmp (pow base (quotient exp 2))) ; store the value temporarily (* tmp tmp) ) ) ( (= 1 (modulo exp 2)) (begin (define tmp (pow base (quotient exp 2))) ; store the value temporarily (* tmp tmp base) ) ) ) ) ","date":"2022-02-27","objectID":"/hw07-of-cs61a-of-ucb/:0:3","tags":["Course","Scheme"],"title":"Hw07 of CS61A of UCB(2021-Fall)","uri":"/hw07-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"The simple solutions of hw06 of CS61A of UCB","date":"2022-02-27","objectID":"/hw06-of-cs61a-of-ucb/","tags":["Course","Python"],"title":"Hw06 of CS61A of UCB(2021-Fall)","uri":"/hw06-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"OOP ","date":"2022-02-27","objectID":"/hw06-of-cs61a-of-ucb/:1:0","tags":["Course","Python"],"title":"Hw06 of CS61A of UCB(2021-Fall)","uri":"/hw06-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q1: Vending Machine In this question you‚Äôll create a vending machine that only outputs a single product and provides change when needed. Create a class called VendingMachine that represents a vending machine for some product. A Vending Machineobject returns strings describing its interactions. Remember to match exactly the strings in the doctests ‚Äì including punctuation and spacing! Fill in the VendingMachine class, adding attributes and methods as appropriate, such that its behavior matches the following doctests: According to the wiki, a vending machine is an automated machine that provides items to consumers after cash, or other forms of payment are inserted into the machine or otherwise made. To make this problem easier, the description indicates that the vending machine only has one product. Take care of the details: restock. The simplest function in Q1. add_funds Memorize the fund you add if it has stocks. Refund if there are no stocks at all vend Stocks available You can buy it if you have enough üí∞ It asks you to add more funds if your funds is not enough Don‚Äôt forget to decrease the stocks after you get the product. No stocks Restocks! class VendingMachine: \"\"\"A vending machine that vends some product for some price. \"\"\" def __init__(self, product, price): self.product = product self.price = price self.balance = 0 self.stocks = 0 def restock(self, num): \"\"\"Restock num items to our vending machine\"\"\" self.stocks += num return f\"Current {self.product} stock: {self.stocks}\" def add_funds(self, fund): \"\"\"Add funds to balance, return funds if no stocks\"\"\" if self.stocks != 0: self.balance += fund return f\"Current balance: ${self.balance}\" else: return f\"Nothing left to vend. Please restock. Here is your ${fund}.\" def vend(self): \"\"\"Vend a product\"\"\" if self.stocks == 0: return 'Nothing left to vend. Please restock.' else: if self.balance \u003c self.price: return f\"You must add ${self.price - self.balance} more funds.\" else: change = self.balance - self.price self.balance = 0 self.stocks -= 1 if change == 0: return f\"Here is your {self.product}.\" else: return f\"Here is your {self.product} and ${change} change.\" ","date":"2022-02-27","objectID":"/hw06-of-cs61a-of-ucb/:1:1","tags":["Course","Python"],"title":"Hw06 of CS61A of UCB(2021-Fall)","uri":"/hw06-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q2: Mint A mint is a place where coins are made. In this question, you‚Äôll implement a Mint class that can output a Coin with the correct year and worth. Each Mint instance has a year stamp. The update method sets the year stamp to the present_year class attribute of the Mint class. The create method takes a subclass of Coin and returns an instance of that class stamped with the mint‚Äôs year (which may be different from Mint.present_year if it has not been updated.) A Coin‚Äôs worth method returns the cents value of the coin plus one extra cent for each year of age beyond 50. A coin‚Äôs age can be determined by subtracting the coin‚Äôs year from the present_year class attribute of the Mint class. :) class Mint: \"\"\"A mint creates coins by stamping on years. \"\"\" present_year = 2021 def __init__(self): self.update() def create(self, kind): return kind(self.year) def update(self): self.year = Mint.present_year class Coin: def __init__(self, year): self.year = year def worth(self): age = Mint.present_year - self.year if age \u003e 50: return self.cents + (age - 50) else: return self.cents ","date":"2022-02-27","objectID":"/hw06-of-cs61a-of-ucb/:1:2","tags":["Course","Python"],"title":"Hw06 of CS61A of UCB(2021-Fall)","uri":"/hw06-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Linked Lists ","date":"2022-02-27","objectID":"/hw06-of-cs61a-of-ucb/:2:0","tags":["Course","Python"],"title":"Hw06 of CS61A of UCB(2021-Fall)","uri":"/hw06-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q3: Store Digits Write a function store_digits that takes in an integer n and returns a linked list where each element of the list is a digit of n. Important: Do not use any string manipulation functions like str and reversed We can solve this problem iteratively. By calculating n % 10, we can get the last digit of the number, then we make a new node and insert it to the front of the linked list. def store_digits(n): \"\"\"Stores the digits of a positive number n in a linked list. \"\"\" sentinel = Link(0) while n \u003e 0: all_but_last, last = n // 10, n % 10 # every time we insert node in the front of the linklist new_node = Link(n % 10, sentinel.rest) sentinel.rest = new_node n = all_but_last return sentinel.rest ","date":"2022-02-27","objectID":"/hw06-of-cs61a-of-ucb/:2:1","tags":["Course","Python"],"title":"Hw06 of CS61A of UCB(2021-Fall)","uri":"/hw06-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q4: Mutable Mapping Implement deep_map_mut(fn, link), which applies a function fn onto all elements in the given linked list link. If an element is itself a linked list, apply fn to each of its elements, and so on. Your implementation should mutate the original linked list. Do not create any new linked lists. Hint: The built-in isinstance function may be useful. \u003e\u003e\u003e s = Link(1, Link(2, Link(3, Link(4)))) \u003e\u003e\u003e isinstance(s, Link) True \u003e\u003e\u003e isinstance(s, int) False It is a recursive problem that needs to be solved recursively ü§ó. Check the comments below. def deep_map_mut(fn, link): \"\"\"Mutates a deep link by replacing each item found with the result of calling fn on the item. Does NOT create new Links (so no use of Link's constructor) \"\"\" # base case 1. do thing if it is empty if link is Link.empty: return # base case 2. if it is an integer if isinstance(link, int): link = fn(link) if isinstance(link.first, int): link.first = fn(link.first) else: deep_map_mut(fn, link.first) deep_map_mut(fn, link.rest) ","date":"2022-02-27","objectID":"/hw06-of-cs61a-of-ucb/:2:2","tags":["Course","Python"],"title":"Hw06 of CS61A of UCB(2021-Fall)","uri":"/hw06-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q5: Two List Implement a function two_list that takes in two lists and returns a linked list. The first list contains the values that we want to put in the linked list, and the second list contains the number of each corresponding value. Assume both lists are the same size and have a length of 1 or greater. Assume all elements in the second list are greater than 0. Unlike the previous problem(Q3), we insert the new node after the last node of the linked list. def two_list(vals, amounts): \"\"\" Returns a linked list according to the two lists that were passed in. Assume vals and amounts are the same size. Elements in vals represent the value, and the corresponding element in amounts represents the number of this value desired in the final linked list. Assume all elements in amounts are greater than 0. Assume both lists have at least one element. \"\"\" idx = 0 sentinel = Link(0) pos = sentinel while idx \u003c len(vals): val, amount = vals[idx], amounts[idx] for _ in range(amount): new_node = Link(val) pos.rest = new_node pos = pos.rest idx += 1 return sentinel.rest ","date":"2022-02-27","objectID":"/hw06-of-cs61a-of-ucb/:2:3","tags":["Course","Python"],"title":"Hw06 of CS61A of UCB(2021-Fall)","uri":"/hw06-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Extra Questions ","date":"2022-02-27","objectID":"/hw06-of-cs61a-of-ucb/:3:0","tags":["Course","Python"],"title":"Hw06 of CS61A of UCB(2021-Fall)","uri":"/hw06-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q6: Next Virahanka Fibonacci Object Implement the next method of the VirFib class. For this class, the value attribute is a Fibonacci number. The next method returns a VirFib instance whose value is the next Fibonacci number. The next method should take only constant time. Note that in the doctests, nothing is being printed out. Rather, each call to .next() returns a VirFib instance. The way each VirFib instance is displayed is determined by the return value of its __repr__ method. Hint: Keep track of the previous number by setting a new instance attribute inside next. You can create new instance attributes for objects at any point, even outside the __init__ method. :) class VirFib(): \"\"\"A Virahanka Fibonacci number. \"\"\" def __init__(self, value=0): self.value = value self.prev = 1 def next(self): new_value = self.value + self.prev next_fin = VirFib(new_value) next_fin.prev = self.value return next_fin def __repr__(self): return \"VirFib object, value \" + str(self.value) ","date":"2022-02-27","objectID":"/hw06-of-cs61a-of-ucb/:3:1","tags":["Course","Python"],"title":"Hw06 of CS61A of UCB(2021-Fall)","uri":"/hw06-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q7: Is BST Write a function is_bst, which takes a Tree t and returns True if, and only if, t is a valid binary search tree, which means that: Each node has at most two children (a leaf is automatically a valid binary search tree) The children are valid binary search trees For every node, the entries in that node‚Äôs left child are less than or equal to the label of the node For every node, the entries in that node‚Äôs right child are greater than the label of the node An example of a BST is: Note that, if a node has only one child, that child could be considered either the left or right child. You should take this into consideration. Hint: It may be helpful to write helper functions bst_min and bst_max that return the minimum and maximum, respectively, of a Tree if it is a valid binary search tree. Notable details: the minimal value of the left child should be \u003c= the value of the current node rather than \u003c. If a node has only one child, it can be considered either the left or right child. def is_bst(t): \"\"\"Returns True if the Tree t has the structure of a valid BST. \"\"\" def bst_min(t): \"\"\"Return the min value of the tree t\"\"\" if t.is_leaf(): return t.label sub_branch_min = min([bst_min(b) for b in t.branches]) return min(t.label, sub_branch_min) def bst_max(t): \"\"\"Return the max value of the tree t\"\"\" if t.is_leaf(): return t.label sub_branch_max = max([bst_max(b) for b in t.branches]) return max(t.label, sub_branch_max) # base case 1. a leaf node is a BST if t.is_leaf(): return True # base case 2. each node has at most 2 children if len(t.branches) \u003e 2: return False # base case 3. a node with a single child # it can be considered either the left or the right if len(t.branches) == 1: return (bst_max(t.branches[0]) \u003c t.label or bst_min(t.branches[0]) \u003e t.label) \\ and is_bst(t.branches[0]) left_max = bst_max(t.branches[0]) right_min = bst_min(t.branches[1]) return left_max \u003c= t.label \u003c right_min and is_bst(t.branches[0]) and is_bst(t.branches[1]) ","date":"2022-02-27","objectID":"/hw06-of-cs61a-of-ucb/:3:2","tags":["Course","Python"],"title":"Hw06 of CS61A of UCB(2021-Fall)","uri":"/hw06-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"the simple solutions for lab10 of CS61A of UCB","date":"2022-02-27","objectID":"/lab10-cs61a-of-ucb/","tags":["Course","Scheme"],"title":"Lab10 CS61A of UCB(2021-Fall)","uri":"/lab10-cs61a-of-ucb/"},{"categories":["Course"],"content":"Coding Questions ","date":"2022-02-27","objectID":"/lab10-cs61a-of-ucb/:1:0","tags":["Course","Scheme"],"title":"Lab10 CS61A of UCB(2021-Fall)","uri":"/lab10-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q2: Over or Under Define a procedure over-or-under which takes in a number num1 and a number num2 and returns the following: -1 if num1 is less than num2 0 if num1 is equal to num2 1 if num1 is greater than num2 Challenge: Implement this in 2 different ways using if and cond! (define (over-or-under num1 num2) 'YOUR-CODE-HERE ) The problem itself is not difficult. We just need to get used to the grammar of the scheme language. If we want to indicate the conditional branches, we may use: (if \u003cpredicate\u003e \u003cconsequent\u003e \u003calternative\u003e) (cond (\u003ccondition\u003e \u003cconsequent\u003e) ...) (define (over-or-under num1 num2) (if (\u003c num1 num2) (print -1)) (if (= num1 num2) (print 0)) (if (\u003e num1 num2) (print 1)) ) (define (over-or-under num1 num2) (cond ( (\u003c num1 num2) (print -1) ) ( (= num1 num2) (print 0) ) ( (\u003e num1 num2) (print 1) )) ) ","date":"2022-02-27","objectID":"/lab10-cs61a-of-ucb/:1:1","tags":["Course","Scheme"],"title":"Lab10 CS61A of UCB(2021-Fall)","uri":"/lab10-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q3: Make Adder Write the procedure make-adder which takes in an initial number, num, and then returns a procedure. This returned procedure takes in a number inc and returns the result of num + inc. Hint: To return a procedure, you can either return a lambda expression or define another nested procedure. Remember that Scheme will automatically return the last clause in your procedure. You can find documentation on the syntax of lambda expressions in the 61A scheme specification! We once saw make-adder written in python in the course. Now we have to translate it to the scheme language. I will use the lambda function to implement the high-order function. (define (make-adder num) (lambda (inc) (+ num inc)) ) ","date":"2022-02-27","objectID":"/lab10-cs61a-of-ucb/:1:2","tags":["Course","Scheme"],"title":"Lab10 CS61A of UCB(2021-Fall)","uri":"/lab10-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q4: Compose Write the procedure composed, which takes in procedures f and g and outputs a new procedure. This new procedure takes in a number x and outputs the result of calling f on g of x. Is is similar to Q3. (define (composed f g) (lambda (x) (f (g x) ) ) ) ","date":"2022-02-27","objectID":"/lab10-cs61a-of-ucb/:1:3","tags":["Course","Scheme"],"title":"Lab10 CS61A of UCB(2021-Fall)","uri":"/lab10-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q5: Make a List In this problem you will create the list with the following box-and-pointer diagram: Challenge: try to create this list in multiple ways, and using multiple list constructors!Ë¶ÅÊ±Ç This problem asks us to make a list depending on the structure provided. We can implement this in many different ways: cons, the basic way to define a list in scheme. I felt a little dizzy after finishing this üò¢ list, the code is shorter. Notice that every time we call (list ...), it is equivalent to making a sublist in the list(a new direction) (define lst (cons (cons 1 nil) (cons 2 (cons (cons 3 (cons 4 nil)) (cons 5 nil)))) ) (define lst (list (list 1) 2 (list 3 4) 5) ) ","date":"2022-02-27","objectID":"/lab10-cs61a-of-ucb/:1:4","tags":["Course","Scheme"],"title":"Lab10 CS61A of UCB(2021-Fall)","uri":"/lab10-cs61a-of-ucb/"},{"categories":["Course"],"content":"Optional Questions ","date":"2022-02-27","objectID":"/lab10-cs61a-of-ucb/:2:0","tags":["Course","Scheme"],"title":"Lab10 CS61A of UCB(2021-Fall)","uri":"/lab10-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q6: Remove Implement a procedure remove that takes in a list and returns a new list with all instances of item removed from lst. You may assume the list will only consist of numbers and will not have nested lists. Hint: You might find the built-in filter procedure useful (though it is definitely possible to complete this question without it). You can find information about how to use filter in the 61A Scheme builtin specification! In face, the list of the scheme language is a linklist. So the problem is removing elements whose value are equal to item. Apparently, We can solve this problem recursively. The assumption that there are no nested lists in Q6 makes the problem easier. The base case is a empty list, we will return '(). Otherwise, The value of current node = item, exclude it and process sublist recursively. The value of current node != item, include it and process sublist recursively. (define (remove item lst) (cond ( (null? lst) '() ) ; base case ( (= item (car lst)) (remove item (cdr lst))) ; exclude item ( else (cons (car lst) (remove item (cdr lst))))) ; include item ) ","date":"2022-02-27","objectID":"/lab10-cs61a-of-ucb/:2:1","tags":["Course","Scheme"],"title":"Lab10 CS61A of UCB(2021-Fall)","uri":"/lab10-cs61a-of-ucb/"},{"categories":["Course"],"content":"the simple solutions for lab09 of CS61A of UCB","date":"2022-02-26","objectID":"/lab09-cs61a-of-ucb/","tags":["Course","Python"],"title":"Lab09 CS61A of UCB(2021-Fall)","uri":"/lab09-cs61a-of-ucb/"},{"categories":["Course"],"content":"Recursion and Tree Recursion ","date":"2022-02-26","objectID":"/lab09-cs61a-of-ucb/:1:0","tags":["Course","Python"],"title":"Lab09 CS61A of UCB(2021-Fall)","uri":"/lab09-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q1: Subsequences A subsequence of a sequence S is a subset of elements from S, in the same order they appear in S. Consider the list [1, 2, 3]. Here are a few of it‚Äôs subsequences [], [1, 3], [2], and [1, 2, 3]. Write a function that takes in a list and returns all possible subsequences of that list. The subsequences should be returned as a list of lists, where each nested list is a subsequence of the original input. In order to accomplish this, you might first want to write a function insert_into_all that takes an item and a list of lists, adds the item to the beginning of each nested list, and returns the resulting list. This problem requires us to write a function which can return all possible subsequences of its input. The hint says that we need to implement the insert_into_all function first. We can do this by a simple list comprehension. def insert_into_all(item, nested_list): \"\"\"Return a new list consisting of all the lists in nested_list, but with item added to the front of each. You can assume that nested_list is a list of lists. \"\"\" return [[item] + l for l in nested_list] The insert_into_all function indicates the way to solve this problem. We need to ask ourself what we can do with this function? We can slove it recursively. The input can be broken down into 2 parts: the first element and the subsequences of the rest part of input(tmp). We need to add the first element in tmp, which can be done with the insert_into_all function. Finally, what is the base case? It is an empty list or a list with a size 1. def subseqs(s): \"\"\"Return a nested list (a list of lists) of all subsequences of S. The subsequences can appear in any order. You can assume S is a list. \"\"\" if len(s) \u003c= 1: return [[], s] if s !=[] else [[]] else: tmp = subseqs(s[1:]) return insert_into_all(s[0], tmp) + tmp ","date":"2022-02-26","objectID":"/lab09-cs61a-of-ucb/:1:1","tags":["Course","Python"],"title":"Lab09 CS61A of UCB(2021-Fall)","uri":"/lab09-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q2: Non-Decreasing Subsequences Just like the last question, we want to write a function that takes a list and returns a list of lists, where each individual list is a subsequence of the original input. This time we have another condition: we only want the subsequences for which consecutive elements are nondecreasing. For example, [1, 3, 2] is a subsequence of [1, 3, 2, 4], but since 2 \u003c 3, this subsequence would not be included in our result. Fill in the blanks to complete the implementation of the non_decrease_subseqs function. You may assume that the input list contains no negative elements. You may use the provided helper function insert_into_all, which takes in an item and a list of lists and inserts the item to the front of each list. In Q1, we have written the function which can return all the possible subsequences. However, we also require the subsequence should be non-decreasing. The hint says that we need to implement a subseq_helper function, which has an additional parameter - prev. Because we now have requirements on the subsequences, then we need the prev to tell us if we could insert the first element into all subsequences. def non_decrease_subseqs(s): \"\"\"Assuming that S is a list, return a nested list of all subsequences of S (a list of lists) for which the elements of the subsequence are strictly nondecreasing. The subsequences can appear in any order. \"\"\" def subseq_helper(s, prev): if not s: return [[]] elif s[0] \u003c prev: return subseq_helper(s[1:], prev) else: a = subseq_helper(s[1:], s[0]) # include s[0] b = subseq_helper(s[1:], prev) # exclude s[0] return insert_into_all(s[0], a) + b return subseq_helper(s, 0) ","date":"2022-02-26","objectID":"/lab09-cs61a-of-ucb/:1:2","tags":["Course","Python"],"title":"Lab09 CS61A of UCB(2021-Fall)","uri":"/lab09-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q3: Number of Trees A full binary tree is a tree where each node has either 2 branches or 0 branches, but never 1 branch. Write a function which returns the number of unique full binary tree structures that have exactly n leaves. For those interested in combinatorics, this problem does have a closed form solution): The answer is the Catalan number. So we need to write a function to calculate the ith Catalan number. As for why it is a catalan number, I can barely understand this. I found the simple explanation: the subtrees of a full binary tree must also be full binary trees. Assuming that we have 1 leaf node in the left subtree, then we have n - 1 leaf nodes in the right subtree. Then there are f(1) * f(n - 1) possibilities. Similarly, we need to calculate f(2) * f(n - 2) ‚Ä¶ ps: The definition of a full binary tree here is not strict. Actually, it means all the degrees of nodes in the tree should be either 0 or 2. def num_trees(n): \"\"\"Returns the number of unique full binary trees with exactly n leaves. E.g., \"\"\" if n == 1 or n == 2: return 1 # catalan number ans = 0 for i in range(1, n): ans += num_trees(i) * num_trees(n - i) return ans ","date":"2022-02-26","objectID":"/lab09-cs61a-of-ucb/:1:3","tags":["Course","Python"],"title":"Lab09 CS61A of UCB(2021-Fall)","uri":"/lab09-cs61a-of-ucb/"},{"categories":["Course"],"content":"Generators ","date":"2022-02-26","objectID":"/lab09-cs61a-of-ucb/:2:0","tags":["Course","Python"],"title":"Lab09 CS61A of UCB(2021-Fall)","uri":"/lab09-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q4: Merge Implement merge(incr_a, incr_b), which takes two iterables incr_a and incr_b whose elements are ordered. merge yields elements from incr_a and incr_b in sorted order, eliminating repetition. You may assume incr_aand incr_b themselves do not contain repeats, and that none of the elements of either are None. You may notassume that the iterables are finite; either may produce an infinite stream of results. You will probably find it helpful to use the two-argument version of the built-in next function: next(incr, v) is the same as next(incr), except that instead of raising StopIteration when incr runs out of elements, it returns v. See the doctest for examples of behavior. What the merge do is merging two iterable objects. It can be assumed that the two iterable objects have no duplicate elements individually, and none of the elements is None. Because we can‚Äôt assume that the two iterable objects are finite, we can‚Äôt solve this in a brute-force way(Merge them and sort and use set to move duplicates). The procedure is: If both of the two iterable objects are non-empty Compare the first element each to compare They are equivalent: yield one, and move the two iterators backward. yield the smaller element, move its iterator Repeat until one of the two iterable objects is empty. Then we only need to iterate the non-empty one instead. def merge(incr_a, incr_b): \"\"\"Yield the elements of strictly increasing iterables incr_a and incr_b, removing repeats. Assume that incr_a and incr_b have no repeats. incr_a or incr_b may or may not be infinite sequences. \"\"\" iter_a, iter_b = iter(incr_a), iter(incr_b) next_a, next_b = next(iter_a, None), next(iter_b, None) # both are non-empty while next_a is not None and next_b is not None: val_a, val_b = next_a, next_b if val_a == val_b: yield next_a next_a, next_b = next(iter_a, None), next(iter_b, None) elif val_a \u003c val_b: yield next_a next_a = next(iter_a, None) else: yield next_b next_b = next(iter_b, None) # incr_a is not empty while next_a: yield next_a next_a = next(iter_a, None) # incr_b is not empty while next_b: yield next_b next_b = next(iter_b, None) ","date":"2022-02-26","objectID":"/lab09-cs61a-of-ucb/:2:1","tags":["Course","Python"],"title":"Lab09 CS61A of UCB(2021-Fall)","uri":"/lab09-cs61a-of-ucb/"},{"categories":["Course"],"content":"Objects ","date":"2022-02-26","objectID":"/lab09-cs61a-of-ucb/:3:0","tags":["Course","Python"],"title":"Lab09 CS61A of UCB(2021-Fall)","uri":"/lab09-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q5: Bank Account Implement the class Account, which acts as a a Bank Account. Account should allow the account holder to deposit money into the account, withdraw money from the account, and view their transaction history. The Bank Account should also prevents a user from withdrawing more than the current balance. Transaction history should be stored as a list of tuples, where each tuple contains the type of transaction and the transaction amount. For example a withdrawal of 500 should be stored as (‚Äòwithdraw‚Äô, 500) Hint: You can call the str function on an integer to get a string representation of the integer. You might find this function useful when implementing the __repr__ and __str__ methods. Hint: You can alternatively use fstrings to implement the __repr__ and __str__ methods cleanly. The Account should be able to: deposit withdraw check the history of what we have done. Looking into the __repr__ method, we know we need to know the number of times the deposits and the withdrawals. So we can define two variables to memorize them. class Account: \"\"\"A bank account that allows deposits and withdrawals. It tracks the current account balance and a transaction history of deposits and withdrawals. \"\"\" interest = 0.02 def __init__(self, account_holder): self.balance = 0 self.holder = account_holder self.transactions = [] self.withdraw_cnt = 0 self.deposit_cnt = 0 def deposit(self, amount): \"\"\"Increase the account balance by amount, add the deposit to the transaction history, and return the new balance. \"\"\" self.balance += amount self.transactions.append(('deposit', amount)) self.deposit_cnt += 1 return self.balance def withdraw(self, amount): \"\"\"Decrease the account balance by amount, add the withdraw to the transaction history, and return the new balance. \"\"\" if self.balance \u003e amount: self.balance -= amount self.transactions.append(('withdraw', amount)) self.withdraw_cnt += 1 return self.balance # prevent illegal withdraw return self.balance def __str__(self): return f\"{self.holder}'s Balance: ${self.balance}\" def __repr__(self): return f\"Accountholder: {self.holder}, Deposits: {self.deposit_cnt}, Withdraws: {self.withdraw_cnt}\" ","date":"2022-02-26","objectID":"/lab09-cs61a-of-ucb/:3:1","tags":["Course","Python"],"title":"Lab09 CS61A of UCB(2021-Fall)","uri":"/lab09-cs61a-of-ucb/"},{"categories":["Course"],"content":"Mutable Lists ","date":"2022-02-26","objectID":"/lab09-cs61a-of-ucb/:4:0","tags":["Course","Python"],"title":"Lab09 CS61A of UCB(2021-Fall)","uri":"/lab09-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q6: Trade In the integer market, each participant has a list of positive integers to trade. When two participants meet, they trade the smallest non-empty prefix of their list of integers. A prefix is a slice that starts at index 0. Write a function trade that exchanges the first m elements of list first with the first n elements of list second, such that the sums of those elements are equal, and the sum is as small as possible. If no such prefix exists, return the string 'No deal!' and do not change either list. Otherwise change both lists and return 'Deal!'. A partial implementation is provided. Hint: You can mutate a slice of a list using slice assignment. To do so, specify a slice of the list [i:j] on the left-hand side of an assignment statement and another list on the right-hand side of the assignment statement. The operation will replace the entire given slice of the list from i inclusive to j exclusive with the elements from the given list. The slice and the given list need not be the same length. \u003e\u003e\u003e a = [1, 2, 3, 4, 5, 6] \u003e\u003e\u003e b = a \u003e\u003e\u003e a[2:5] = [10, 11, 12, 13] \u003e\u003e\u003e a [1, 2, 10, 11, 12, 13, 6] \u003e\u003e\u003e b [1, 2, 10, 11, 12, 13, 6] Additionally, recall that the starting and ending indices for a slice can be left out and Python will use a default value. lst[i:] is the same as lst[i:len(lst)], and lst[:j] is the same as lst[0:j]. It has provided us with some code that can exchange elements. All we have to do is to make m and n stop in right place. We need to make sure that the m and n are leal indices. def trade(first, second): \"\"\"Exchange the smallest prefixes of first and second that have equal sum. \"\"\" m, n = 1, 1 equal_prefix = lambda: sum(first[:m]) == sum(second[:n]) while m \u003c= len(first) and n \u003c= len(second) and not equal_prefix(): if sum(first[:m]) \u003c sum(second[:n]): m += 1 else: n += 1 if equal_prefix(): first[:m], second[:n] = second[:n], first[:m] return 'Deal!' else: return 'No deal!' ","date":"2022-02-26","objectID":"/lab09-cs61a-of-ucb/:4:1","tags":["Course","Python"],"title":"Lab09 CS61A of UCB(2021-Fall)","uri":"/lab09-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q7: Shuffle Define a function shuffle that takes a sequence with an even number of elements (cards) and creates a new list that interleaves the elements of the first half with the elements of the second half. To interleave two sequences s0 and s1 is to create a new sequence such that the new sequence contains (in this order) the first element of s0, the first element of s1, the second element of s0, the second element of s1, and so on. If the two lists are not the same length, then the leftover elements of the longer list should still appear at the end. Note: If you‚Äôre running into an issue where the special heart / diamond / spades / clubs symbols are erroring in the doctests, feel free to copy paste the below doctests into your file as these don‚Äôt use the special characters and should not give an ‚Äúillegal multibyte sequence‚Äù error. This problem requires us to implement the shuffle function. For example, [0, 1, 2, 3, 4, 5] = [0, 3, 1, 4, 2, 5]. The key: the relationship between the indices - [0, 1, ..., len(cards) // 2, len(cards) // 2 + 1, ...]. You can find that the indices of the elements in the corresponding positions of the first half and the second half differ by len(cards) // 2 def shuffle(cards): \"\"\"Return a shuffled list that interleaves the two halves of cards. \"\"\" assert len(cards) % 2 == 0, 'len(cards) must be even' half = len(cards) // 2 shuffled = [] for i in range(half): shuffled.append(cards[i]) shuffled.append(cards[i + half]) return shuffled ","date":"2022-02-26","objectID":"/lab09-cs61a-of-ucb/:4:2","tags":["Course","Python"],"title":"Lab09 CS61A of UCB(2021-Fall)","uri":"/lab09-cs61a-of-ucb/"},{"categories":["Course"],"content":"Linked Lists ","date":"2022-02-26","objectID":"/lab09-cs61a-of-ucb/:5:0","tags":["Course","Python"],"title":"Lab09 CS61A of UCB(2021-Fall)","uri":"/lab09-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q8: Insert Implement a function insert that takes a Link, a value, and an index, and inserts the value into the Link at the given index. You can assume the linked list already has at least one element. Do not return anything ‚Äì insert should mutate the linked list. Note: If the index is out of bounds, you should raise an IndexError with: raise IndexError('Out of bounds!') It is strange that if we insert a new node(the index = 0), we won‚Äôt pass the link is other_link test(because we have changed the head of the link). So I change my way to insert: I make a copy of the current node and then change the value of the origin node. def insert(link, value, index): \"\"\"Insert a value into a Link at the given index. \"\"\" pos = link current_index = 0 while pos is not Link.empty: if current_index == index: # make a copy of current node, and modify the current node's value \\ # which is equal to insert a new node :) current_copy = Link(pos.first, pos.rest) origin_next = pos.rest pos.first = value pos.rest = current_copy #print(f\"link: {link.first}\") return pos = pos.rest current_index += 1 raise IndexError('Out of bounds!') ","date":"2022-02-26","objectID":"/lab09-cs61a-of-ucb/:5:1","tags":["Course","Python"],"title":"Lab09 CS61A of UCB(2021-Fall)","uri":"/lab09-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q9: Deep Linked List Length A linked list that contains one or more linked lists as elements is called a deep linked list. Write a function deep_len that takes in a (possibly deep) linked list and returns the deep length of that linked list. The deep length of a linked list is the total number of non-link elements in the list, as well as the total number of elements contained in all contained lists. See the function‚Äôs doctests for examples of the deep length of linked lists. Hint: Use isinstance to check if something is an instance of an object. Deep Linked List Length is a nested list. We need to calculate how many nodes are in it. To solve the problem of the nested linklist, we can solve it recursively. The base case is an empty linklist or it is not a linklist. Otherwise, we will check the lnk.first(it may be a linklist) and the lnk.rest def deep_len(lnk): \"\"\" Returns the deep length of a possibly deep linked list. \"\"\" # base case 1. an empty node if lnk is Link.empty: return 0 # base case 2. an integer elif isinstance(lnk, int): return 1 else: return deep_len(lnk.first) + deep_len(lnk.rest) ","date":"2022-02-26","objectID":"/lab09-cs61a-of-ucb/:5:2","tags":["Course","Python"],"title":"Lab09 CS61A of UCB(2021-Fall)","uri":"/lab09-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q10: Linked Lists as Strings Kevin and Jerry like different ways of displaying the linked list structure in Python. While Kevin likes box and pointer diagrams, Jerry prefers a more futuristic way. Write a function make_to_string that returns a function that converts the linked list to a string in their preferred style. Hint: You can convert numbers to strings using the str function, and you can combine strings together using +. \u003e\u003e\u003e str(4) '4' \u003e\u003e\u003e 'cs ' + str(61) + 'a' 'cs 61a' The format: front + the value of the current node + mid + the string of lnk.rest + back def make_to_string(front, mid, back, empty_repr): \"\"\" Returns a function that turns linked lists to strings. \"\"\" def printer(lnk): if lnk is Link.empty: return empty_repr else: return front + str(lnk.first) + mid + printer(lnk.rest) + back return printer ","date":"2022-02-26","objectID":"/lab09-cs61a-of-ucb/:5:3","tags":["Course","Python"],"title":"Lab09 CS61A of UCB(2021-Fall)","uri":"/lab09-cs61a-of-ucb/"},{"categories":["Course"],"content":"Trees ","date":"2022-02-26","objectID":"/lab09-cs61a-of-ucb/:6:0","tags":["Course","Python"],"title":"Lab09 CS61A of UCB(2021-Fall)","uri":"/lab09-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q11: Long Paths Implement long_paths, which returns a list of all paths in a tree with length at least n. A path in a tree is a list of node labels that starts with the root and ends at a leaf. Each subsequent element must be from a label of a branch of the previous value‚Äôs node. The length of a path is the number of edges in the path (i.e. one less than the number of nodes in the path). Paths are ordered in the output list from left to right in the tree. See the doctests for some examples. We need to return a nested list, each one of them represents a path with a length at least n. Notice that the path must end in a leaf node. Actually, it is a classical problem that can be solved by recursion and backtrace. The skeleton is like: def function_name(p): # base case ... dothing thing ... # recursively solve this problem undo what you have done We need to add the label of the current node in our current_path list when we are about to go deepr in the tree and undo what our modifications when we are about move up in the tree. def long_paths(t, n): \"\"\"Return a list of all paths in t with length at least n. \"\"\" path_list = [] def helper(t, current_path, length): nonlocal path_list if t.is_leaf(): current_path.append(t.label) if length \u003e= n: # warning: we need to pass a copy instead fo a ref path_list.append(current_path[:]) current_path.pop() return current_path.append(t.label) for b in t.branches: helper(b, current_path, length + 1) current_path.pop() helper(t, [], 0) return path_list ","date":"2022-02-26","objectID":"/lab09-cs61a-of-ucb/:6:1","tags":["Course","Python"],"title":"Lab09 CS61A of UCB(2021-Fall)","uri":"/lab09-cs61a-of-ucb/"},{"categories":["Course"],"content":"the simple solutions for lab08 of CS61A of UCB","date":"2022-02-24","objectID":"/lab08-cs61a-of-ucb/","tags":["Course","Python"],"title":"Lab08 CS61A of UCB(2021-Fall)","uri":"/lab08-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q2: Convert Link Write a function convert_link that takes in a linked list and returns the sequence as a Python list. You may assume that the input list is shallow; that is none of the elements is another linked list. Try to find both an iterative and recursive solution for this problem! It is easy to solve this problem iteratively. All we have to do is to make a list to store these nodes we have visited while we iterating this linklist. def convert_link(link): \"\"\"Takes a linked list and returns a Python list with the same elements. \"\"\" result = [] while link is not Link.empty: result.append(int(link.first)) link = link.rest return result The recursive algorithm is also easy. The base case is that when we encounter an empty node, an empty list will be returned. Otherwise, we will break down this problem: current node + the rest of tinkliest def convert_link(link): \"\"\"Takes a linked list and returns a Python list with the same elements. \"\"\" # recursive solution if link is Link.empty: return [] else: return [int(link.first)] + convert_link(link.rest) ","date":"2022-02-24","objectID":"/lab08-cs61a-of-ucb/:0:1","tags":["Course","Python"],"title":"Lab08 CS61A of UCB(2021-Fall)","uri":"/lab08-cs61a-of-ucb/"},{"categories":["Course"],"content":"Trees ","date":"2022-02-24","objectID":"/lab08-cs61a-of-ucb/:1:0","tags":["Course","Python"],"title":"Lab08 CS61A of UCB(2021-Fall)","uri":"/lab08-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q4: Square Write a function label_squarer that mutates a Tree with numerical labels so that each label is squared. def label_squarer(t): \"\"\"Mutates a Tree t by squaring all its elements. \"\"\" # base case if t.is_leaf(): t.label = t.label ** 2 # check every branch for b in t.branches: t.label = t.label ** 2 # change the current node's label label_squarer(b) # change branches ","date":"2022-02-24","objectID":"/lab08-cs61a-of-ucb/:1:1","tags":["Course","Python"],"title":"Lab08 CS61A of UCB(2021-Fall)","uri":"/lab08-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q5: Cumulative Mul Write a function cumulative_mul that mutates the Tree t so that each node‚Äôs label becomes the product of its label and all labels in the subtrees rooted at the node. The description indicates that we should make the label of the node equal to the product of its label and all labels in the subtrees in the tree. The base is the leaf node, which has no subtrees. We will return its label. Otherwise, we check every subtree of the current node. The procedure of changing is bottom-up ü§ó To make the code simple, I use math.prod here. If you also want to use this, you will need to import math at the beginning of the code. def cumulative_mul(t): \"\"\"Mutates t so that each node's label becomes the product of all labels in \"\"\" # base case if t.is_leaf(): return t.label # get all label value in subtree vals = [cumulative_mul(b) for b in t.branches] # calculate t.label *= math.prod(vals) ","date":"2022-02-24","objectID":"/lab08-cs61a-of-ucb/:1:2","tags":["Course","Python"],"title":"Lab08 CS61A of UCB(2021-Fall)","uri":"/lab08-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q6: Add Leaves Implement add_d_leaves, a function that takes in a Tree instance t and a number v. We define the depth of a node in t to be the number of edges from the root to that node. The depth of root is therefore 0. For each node in the tree, you should add d leaves to it, where d is the depth of the node. Every added leaf should have a label of v. If the node at this depth has existing branches, you should add these leaves to the end of that list of branches. For example, you should be adding 1 leaf with label v to each node at depth 1, 2 leaves to each node at depth 2, and so on. Here is an example of a tree t(shown on the left) and the result after add_d_leaves is applied with v as 5. We have to some details into account: How to get the height of the current node? We need to add leaves depending on the height, we can define a helper function with an additional parameter to represent height. Every time we go deeper in the tree, we will +1. How to solve it recursively? The base is the leaf node. We will add leaves to it and return here. Otherwise, we need to repeat the procedure to all its subtrees, and also determine whether the current node needs to add leaves. def add_d_leaves(t, v): \"\"\"Add d leaves containing v to each node at every depth d. \"\"\" def helper(t, v, depth): # base case if t.is_leaf(): for i in range(depth): t.branches.append(Tree(v)) return # check every branch for b in t.branches: helper(b, v, depth + 1) # check current node for i in range(depth): t.branches.append(Tree(v)) helper(t, v, 0) ","date":"2022-02-24","objectID":"/lab08-cs61a-of-ucb/:1:3","tags":["Course","Python"],"title":"Lab08 CS61A of UCB(2021-Fall)","uri":"/lab08-cs61a-of-ucb/"},{"categories":["Course"],"content":"Optional Questions ","date":"2022-02-24","objectID":"/lab08-cs61a-of-ucb/:2:0","tags":["Course","Python"],"title":"Lab08 CS61A of UCB(2021-Fall)","uri":"/lab08-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q7: Every Other Implement every_other, which takes a linked list s. It mutates s such that all of the odd-indexed elements (using 0-based indexing) are removed from the list. For example: \u003e\u003e\u003e s = Link('a', Link('b', Link('c', Link('d')))) \u003e\u003e\u003e every_other(s) \u003e\u003e\u003e s.first 'a' \u003e\u003e\u003e s.rest.first 'c' \u003e\u003e\u003e s.rest.rest is Link.empty True If s contains fewer than two elements, s remains unchanged. Do not return anything! every_other should mutate the original list. First, If the length of the linklist is less than 2, we will keep it unchanged. Otherwise, we will solve this problem iteratively. We maintain 2 pointers - last_pos and pos, which indicate the current position and the last position we visited. If the current node is odd-indexed, we let last_pos.rest = post.rest and add the pointers. def every_other(s): \"\"\"Mutates a linked list so that all the odd-indiced elements are removed \"\"\" # if it contains fewer than 2, do nothing if s is Link.empty or s.rest is Link.empty: return last_pos, pos = s, s.rest current_index = 1 # start from 2nd position while pos is not Link.empty: if current_index % 2 == 1: last_pos.rest = pos.rest last_pos = pos pos = pos.rest current_index += 1 ","date":"2022-02-24","objectID":"/lab08-cs61a-of-ucb/:2:1","tags":["Course","Python"],"title":"Lab08 CS61A of UCB(2021-Fall)","uri":"/lab08-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q8: Prune Small Complete the function prune_small that takes in a Tree t and a number n and prunes t mutatively. If t or any of its branches has more than n branches, the n branches with the smallest labels should be kept and any other branches should be pruned, or removed, from the tree. Before we start to write the code, we need to think about what is the fast way to prune? The bottom-up way or the up-down way? The latter is the answer. Because we don‚Äôt have to check the nodes in the subtrees we have pruned. You may figure out this by observing the template provided in the hint. ü§ó def prune_small(t, n): \"\"\"Prune the tree mutatively, keeping only the n branches of each node with the smallest label. \"\"\" while len(t.branches) \u003e n: largest = max(t.branches, key=lambda x: x.label) t.branches.remove(largest) for b in t.branches: prune_small(b, n) ","date":"2022-02-24","objectID":"/lab08-cs61a-of-ucb/:2:2","tags":["Course","Python"],"title":"Lab08 CS61A of UCB(2021-Fall)","uri":"/lab08-cs61a-of-ucb/"},{"categories":["Course"],"content":"the simple solutions for lab07 of CS61A of UCB","date":"2022-02-24","objectID":"/lab07-cs61a-of-ucb/","tags":["Course","Python"],"title":"Lab07 CS61A of UCB(2021-Fall)","uri":"/lab07-cs61a-of-ucb/"},{"categories":["Course"],"content":"Accounts ","date":"2022-02-24","objectID":"/lab07-cs61a-of-ucb/:1:0","tags":["Course","Python"],"title":"Lab07 CS61A of UCB(2021-Fall)","uri":"/lab07-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q2: Retirement Add a time_to_retire method to the Account class. This method takes in an amount and returns how many years the holder would need to wait in order for the current balance to grow to at least amount, assuming that the bank adds balance times the interest rate to the total balance at the end of every year. The description tells us that: We will add our balance every year, so when may we retire? Both the math and code are simple. def time_to_retire(self, amount): \"\"\"Return the number of years until balance would grow to amount.\"\"\" assert self.balance \u003e 0 and amount \u003e 0 and self.interest \u003e 0 year, curAmount = 0, self.balance while True: year += 1 curAmount *= (1 + self.interest) if curAmount \u003e amount: return year ","date":"2022-02-24","objectID":"/lab07-cs61a-of-ucb/:1:1","tags":["Course","Python"],"title":"Lab07 CS61A of UCB(2021-Fall)","uri":"/lab07-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q3: FreeChecking Implement the FreeChecking class, which is like the Account class from lecture except that it charges a withdraw fee after 2 withdrawals. If a withdrawal is unsuccessful, it still counts towards the number of free withdrawals remaining, but no fee for the withdrawal will be charged. We need to check an additional parameter(free_withdrawals) compare with withdraw, which indicates the number of times we can withdraw without being charged the fee. There are 2 points to note here: The number of free_wighdrawals will be reduced even if we fail to withdraw. The sum of the fee and the amount should be bigger than the balance so that we can withdraw successfully when we need to pay the fee. def withdraw(self, amount): if self.free_withdrawals \u003e 0: if amount \u003e self.balance: self.free_withdrawals -= 1 return \"Insufficient funds\" if amount \u003e self.max_withdrawal: self.free_withdrawals -= 1 return \"Can't withdraw that amount\" self.free_withdrawals -= 1 self.balance = self.balance - amount else: if amount + self.withdraw_fee \u003e self.balance: self.free_withdrawals -= 1 return \"Insufficient funds\" if amount + self.withdraw_fee \u003e self.max_withdrawal: self.free_withdrawals -= 1 return \"Can't withdraw that amount\" self.balance = self.balance - amount - self.withdraw_fee ","date":"2022-02-24","objectID":"/lab07-cs61a-of-ucb/:1:2","tags":["Course","Python"],"title":"Lab07 CS61A of UCB(2021-Fall)","uri":"/lab07-cs61a-of-ucb/"},{"categories":["Course"],"content":"Magic: the Lambda-ing ","date":"2022-02-24","objectID":"/lab07-cs61a-of-ucb/:2:0","tags":["Course","Python"],"title":"Lab07 CS61A of UCB(2021-Fall)","uri":"/lab07-cs61a-of-ucb/"},{"categories":["Course"],"content":"Description We will be implementing a card game in the lab. You can check the rules here ","date":"2022-02-24","objectID":"/lab07-cs61a-of-ucb/:2:1","tags":["Course","Python"],"title":"Lab07 CS61A of UCB(2021-Fall)","uri":"/lab07-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q4: Making Cards To play a card game, we‚Äôre going to need to have cards, so let‚Äôs make some! We‚Äôre gonna implement the basics of the Card class first. First, implement the Card class constructor in classes.py. This constructor takes three arguments: a string as the name of the card an integer as the attack value of the card an integer as the defense value of the card Each Card instance should keep track of these values using instance attributes called name, attack, and defense. You should also implement the power method in Card, which takes in another card as an input and calculates the current card‚Äôs power. Refer to the Rules of the Game if you‚Äôd like a refresher on how power is calculated. We need to implement the constructor and the power functions. class Card: cardtype = 'Staff' def __init__(self, name, attack, defense): \"\"\" Create a Card object with a name, attack, and defense. \"\"\" self.name = name self.attack = attack self.defense = defense def power(self, opponent_card): \"\"\" Calculate power as: (player card's attack) - (opponent card's defense)/2 \"\"\" return self.attack - opponent_card.defense / 2 ","date":"2022-02-24","objectID":"/lab07-cs61a-of-ucb/:2:2","tags":["Course","Python"],"title":"Lab07 CS61A of UCB(2021-Fall)","uri":"/lab07-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q5: Making a Player Now that we have cards, we can make a deck, but we still need players to actually use them. We‚Äôll now fill in the implementation of the Player class. A Player instance has three instance attributes: name is the player‚Äôs name. When you play the game, you can enter your name, which will be converted into a string to be passed to the constructor. deck is an instance of the Deck class. You can draw from it using its .draw() method. hand is a list of Card instances. Each player should start with 5 cards in their hand, drawn from their deck. Each card in the hand can be selected by its index in the list during the game. When a player draws a new card from the deck, it is added to the end of this list. Complete the implementation of the constructor for Player so that self.hand is set to a list of 5 cards drawn from the player‚Äôs deck. Next, implement the draw and play methods in the Player class. The draw method draws a card from the deck and adds it to the player‚Äôs hand. The play method removes and returns a card from the player‚Äôs hand at the given index. Call deck.draw() when implementing Player.__init__ and Player.draw. Don‚Äôt worry about how this function works - leave it all to the abstraction! The tasks are as follow: We have 5 cards at the beginning of the game. We need to implement these: the constructor. We need to draw 5 cards from the deck. For the simplicity, we can use list comprehension here. the draw function. Use deck.draw() is enough. the play function. We need to play card at the given index. You should distinguish between .remove() and .pop(). def __init__(self, deck, name): \"\"\"Initialize a Player object. \"\"\" self.deck = deck self.name = name self.hand = [deck.draw() for i in range(5)] def draw(self): \"\"\"Draw a card from the player's deck and add it to their hand. \"\"\" assert not self.deck.is_empty(), 'Deck is empty!' self.hand.append(self.deck.draw()) def play(self, card_index): \"\"\"Remove and return a card from the player's hand at the given index. \"\"\" card = self.hand[card_index] self.hand.pop(card_index) return card ","date":"2022-02-24","objectID":"/lab07-cs61a-of-ucb/:2:3","tags":["Course","Python"],"title":"Lab07 CS61A of UCB(2021-Fall)","uri":"/lab07-cs61a-of-ucb/"},{"categories":["Course"],"content":"Optional Questions ","date":"2022-02-24","objectID":"/lab07-cs61a-of-ucb/:3:0","tags":["Course","Python"],"title":"Lab07 CS61A of UCB(2021-Fall)","uri":"/lab07-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q6: AIs: Defenders Implement the effect method for AIs, which reduces the opponent card‚Äôs attack by the opponent card‚Äôs defense, and then doubles the opponent card‚Äôs defense. Note: The opponent card‚Äôs resulting attack value cannot be negative. Note that if the attack is less than zero, we need to set it to zero. def effect(self, opponent_card, player, opponent): \"\"\" Reduce the opponent's card's attack by its defense, then double its defense. \"\"\" opponent_card.attack -= opponent_card.defense if opponent_card.attack \u003c 0: opponent_card.attack = 0 opponent_card.defense *= 2 ","date":"2022-02-24","objectID":"/lab07-cs61a-of-ucb/:3:1","tags":["Course","Python"],"title":"Lab07 CS61A of UCB(2021-Fall)","uri":"/lab07-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q7: Tutors: Flummox Implement the effect method for TAs, which swaps the attack and defense of the opponent‚Äôs card. We should discard our cards without breaking the abstraction. So we can use .play and .draw methods here. def effect(self, opponent_card, player, opponent): \"\"\" Discard the first 3 cards in the opponent's hand and have them draw the same number of cards from their deck. \"\"\" # discard 3 cards for i in range(3): opponent.play(i) # draw 3 cards for i in range(3): opponent.draw() # You should add your implementation above this. print('{} discarded and re-drew 3 cards!'.format(opponent.name)) ","date":"2022-02-24","objectID":"/lab07-cs61a-of-ucb/:3:2","tags":["Course","Python"],"title":"Lab07 CS61A of UCB(2021-Fall)","uri":"/lab07-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q8: TAs: Shift Implement the effect method for TAs, which swaps the attack and defense of the opponent‚Äôs card. Just swap the attack and the defense def effect(self, opponent_card, player, opponent): \"\"\" Swap the attack and defense of an opponent's card. \"\"\" opponent_card.attack, opponent_card.defense = opponent_card.defense, opponent_card.attack ","date":"2022-02-24","objectID":"/lab07-cs61a-of-ucb/:3:3","tags":["Course","Python"],"title":"Lab07 CS61A of UCB(2021-Fall)","uri":"/lab07-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q9: The Instructor Arrives A new challenger has appeared! Implement the effect method for the Instructors, who add the opponent card‚Äôs attack and defense to all cards in the player‚Äôs deck and then removes all cards in the opponent‚Äôs deck that have the same attack or defense as the opponent‚Äôs card. Note: If you mutate a list while iterating through it, you may run into trouble. Try iterating through a copy of the list instead. You can use slicing to make a copy of a list: \u003e\u003e\u003e original = [1, 2, 3, 4] \u003e\u003e\u003e copy = original[:] \u003e\u003e\u003e copy [1, 2, 3, 4] \u003e\u003e\u003e copy is original False This one is a little more difficult compared with the other ones. The key of this question is how can we mutate the list while we iterate it. You may check this def effect(self, opponent_card, player, opponent): \"\"\" Adds the attack and defense of the opponent's card to all cards in the player's deck, then removes all cards in the opponent's deck that share an attack or defense stat with the opponent's card. \"\"\" orig_opponent_deck_length = len(opponent.deck.cards) # add the attack and defense of the opponent's card ... for card in player.deck.cards: card.attack += opponent_card.attack card.defense += opponent_card.defense # remove all cards in the opponent's deck that share ... for card in opponent.deck.cards[:]: if card.attack == opponent_card.attack and card.defense == opponent_card.defense: opponent.deck.cards.remove(card) # You should add your implementation above this. discarded = orig_opponent_deck_length - len(opponent.deck.cards) if discarded: print('{} cards were discarded from {}\\'s deck!'.format(discarded, opponent.name)) return ","date":"2022-02-24","objectID":"/lab07-cs61a-of-ucb/:3:4","tags":["Course","Python"],"title":"Lab07 CS61A of UCB(2021-Fall)","uri":"/lab07-cs61a-of-ucb/"},{"categories":["Course"],"content":"The simple solutions of hw05 of CS61A of UCB","date":"2022-02-22","objectID":"/hw05-of-cs61a-of-ucb/","tags":["Course","Python"],"title":"Hw05 of CS61A of UCB(2021-Fall)","uri":"/hw05-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q1: Generate Permutations Given a sequence of unique elements, a permutation of the sequence is a list containing the elements of the sequence in some arbitrary order. For example, [2, 1, 3], [1, 3, 2], and [3, 2, 1] are some of the permutations of the sequence [1, 2, 3]. Implement gen_perms, a generator function that takes in a sequence seq and returns a generator that yields all permutations of seq. For this question, assume that seq will not be empty. Permutations may be yielded in any order. Note that the doctests test whether you are yielding all possible permutations, but not in any particular order. The built-in sorted function takes in an iterable object and returns a list containing the elements of the iterable in non-decreasing order. Hint: If you had the permutations of all the elements in seq not including the first element, how could you use that to generate the permutations of the full seq? Hint: Remember, it‚Äôs possible to loop over generator objects because generators are iterators! This problem asks us to return a generator that will return all the permutations of the list. We can learn from the hint that we need to solve this problem recursively. It‚Äôs easy to figure out the base case of this problem: def gen_perms(seq): if len(seq) \u003c= 1: yield seq ... Now, the problem is how can we break down this problem into simpler ones? We can learn from the hint that we should recursively process elements other than the element in the first position. Try to think about a question like this: If we have already got the permutations of l[1:], what should we do with l[0]. The answer is quite intuitive: we insert l[0] to every possible position in the permutations of l[1:]. For example, we have [2, 3], whose permutations are [[2, 3], [3, 2]]. First, we insert 1 to [2, 3], which give us [1, 2, 3], [2, 1, 3], [2, 3, 1]. Then we repeat the procedure on [3, 2]. So we can write the following code: def gen_perms(seq): \"\"\"Generates all permutations of the given sequence. Each permutation is a list of the elements in SEQ in a different order. The permutations may be yielded in any order. \u003e\u003e\u003e perms = gen_perms([100]) \u003e\u003e\u003e type(perms) \u003cclass 'generator'\u003e \u003e\u003e\u003e next(perms) [100] \u003e\u003e\u003e try: #this piece of code prints \"No more permutations!\" if calling next would cause an error ... next(perms) ... except StopIteration: ... print('No more permutations!') No more permutations! \u003e\u003e\u003e sorted(gen_perms([1, 2, 3])) # Returns a sorted list containing elements of the generator [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] \u003e\u003e\u003e sorted(gen_perms((10, 20, 30))) [[10, 20, 30], [10, 30, 20], [20, 10, 30], [20, 30, 10], [30, 10, 20], [30, 20, 10]] \u003e\u003e\u003e sorted(gen_perms(\"ab\")) [['a', 'b'], ['b', 'a']] \"\"\" # This problem requires list type, see example above if type(seq) != list: seq = list(seq) # base case if len(seq) \u003c= 1: yield seq else: # iterate every permutation in the generator for perm in gen_perms(seq[1:]): # enumerate every position for insertation for i in range(len(seq)): yield perm[:i] + seq[:1] + perm[i:] ","date":"2022-02-22","objectID":"/hw05-of-cs61a-of-ucb/:0:1","tags":["Course","Python"],"title":"Hw05 of CS61A of UCB(2021-Fall)","uri":"/hw05-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q2: Yield Paths Define a generator function path_yielder which takes in a tree t, a value value, and returns a generator object which yields each path from the root of t to a node that has label value. Each path should be represented as a list of the labels along that path in the tree. You may yield the paths in any order. We have provided a skeleton for you. You do not need to use this skeleton, but if your implementation diverges significantly from it, you might want to think about how you can get it to fit the skeleton. The problem asks us to yield all possible path leads us to value. Pay a attention to the hint. The template of the code looks like this: def path_yielder(t, value): \"*** YOUR CODE HERE ***\" for _______________ in _________________: for _______________ in _________________: \"*** YOUR CODE HERE ***\" You can find it that the template is quite similar to the solution in Q1 if you observe it carefully. First, we should ask ourselves the most important question? - What is the base case? Well, apparently, we meet the base case when we encounter the node with the value label. It can be any branch of the current node, so we need to check each branch. When we find the sub-path, we return it and add the label of the current node. For example, check the example in the doctoring. We want all the paths to lead us to 3. First, we start from the root node(1). It has 2 branches - 2 and 5. In the first branch of 1, we can find 3, at this point we yield [3]. When we backtrack to 2, we get the sub-path - [2, 3]. Finally, we will get [1] + [2, 3] = [1, 2, 3] when we come back to the root node(1) The code shows as below: def path_yielder(t, value): \"\"\"Yields all possible paths from the root of t to a node with the label value as a list. \u003e\u003e\u003e t1 = tree(1, [tree(2, [tree(3), tree(4, [tree(6)]), tree(5)]), tree(5)]) \u003e\u003e\u003e print_tree(t1) 1 2 3 4 6 5 5 \u003e\u003e\u003e next(path_yielder(t1, 6)) [1, 2, 4, 6] \u003e\u003e\u003e path_to_5 = path_yielder(t1, 5) \u003e\u003e\u003e sorted(list(path_to_5)) [[1, 2, 5], [1, 5]] \u003e\u003e\u003e t2 = tree(0, [tree(2, [t1])]) \u003e\u003e\u003e print_tree(t2) 0 2 1 2 3 4 6 5 5 \u003e\u003e\u003e path_to_2 = path_yielder(t2, 2) \u003e\u003e\u003e sorted(list(path_to_2)) [[0, 2], [0, 2, 1, 2]] \"\"\" if label(t) == value: yield [label(t)] for b in branches(t): for path in path_yielder(b, value): yield [label(t)] + path ","date":"2022-02-22","objectID":"/hw05-of-cs61a-of-ucb/:0:2","tags":["Course","Python"],"title":"Hw05 of CS61A of UCB(2021-Fall)","uri":"/hw05-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q3: Preorder Define the function preorder, which takes in a tree as an argument and returns a list of all the entries in the tree in the order that print_tree would print them. The following diagram shows the order that the nodes would get printed, with the arrows representing function calls. Again, we need to solve the problem of the preorder traversal of the tree. We have to recursively visit all nodes of this tree, starting from the root node. Note that we first memorize the value of the root node and then look at its subtrees, and handle such problems recursively. def preorder(t): \"\"\"Return a list of the entries in this tree in the order that they would be visited by a preorder traversal (see problem description). \u003e\u003e\u003e numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])]) \u003e\u003e\u003e preorder(numbers) [1, 2, 3, 4, 5, 6, 7] \u003e\u003e\u003e preorder(tree(2, [tree(4, [tree(6)])])) [2, 4, 6] \"\"\" result = [] def helper(t): if t is not None: result.append(label(t)) for b in branches(t): helper(b) helper(t) return result ","date":"2022-02-22","objectID":"/hw05-of-cs61a-of-ucb/:0:3","tags":["Course","Python"],"title":"Hw05 of CS61A of UCB(2021-Fall)","uri":"/hw05-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q4: Generate Preorder Similarly to preorder in Question 3, define the function generate_preorder, which takes in a tree as an argument and now instead yields the entries in the tree in the order that print_tree would print them. Hint: How can you modify your implementation of preorder to yield from your recursive calls instead of returning them? The overall solution is very similar to Q3, but now we don‚Äôt need to use a result to store the traversed sequence, because what we want to return is a generator. However, the logic of this algorithm is still the same. If you want to have a deeper understanding of yield from, we can look at this person‚Äôs [this article](http://simeonvisser.com/posts/python-3-using-yield- from-in-generators-part-1.html) def generate_preorder(t): \"\"\"Yield the entries in this tree in the order that they would be visited by a preorder traversal (see problem description). \u003e\u003e\u003e numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])]) \u003e\u003e\u003e gen = generate_preorder(numbers) \u003e\u003e\u003e next(gen) 1 \u003e\u003e\u003e list(gen) [2, 3, 4, 5, 6, 7] \"\"\" yield label(t) for b in branches(t): yield from generate_preorder(b) ","date":"2022-02-22","objectID":"/hw05-of-cs61a-of-ucb/:0:4","tags":["Course","Python"],"title":"Hw05 of CS61A of UCB(2021-Fall)","uri":"/hw05-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q5: Remainder Generator Like functions, generators can also be higher-order. For this problem, we will be writing remainders_generator, which yields a series of generator objects. remainders_generator takes in an integer m, and yields m different generators. The first generator is a generator of multiples of m, i.e. numbers where the remainder is 0. The second is a generator of natural numbers with remainder 1 when divided by m. The last generator yields natural numbers with remainder m - 1 when divided by m. Hint: To create a generator of infinite natural numbers, you can call the naturals function that‚Äôs provided in the starter code. Hint: Consider defining an inner generator function. Each yielded generator varies only in that the elements of each generator have a particular remainder when divided by m. What does that tell you about the argument(s) that the inner function should take in? If you have no idea what is the generator in python, you will find it difficult to figure out the solution. I will recommend this article After reading the article aforementioned, we may start to try to solve this problem. What the problem wants are m generators, the ith yielded generator yields natural numbers whose remainder is i when divided by m. If we know how to get the first generator, then we know how to get all the generators. I believe that it is easy to write a function that returns natural numbers whose remainder is i when divided by m. With the help of yield, we don‚Äôt need a list to store the numbers(Just like what I did in Q3). def helper(i, m): num = 1 # loop variable while True: if num % m == i: yield num num += 1 # you can give it a test \u003e\u003e\u003e it = helper(2, 3) \u003e\u003e\u003e next(it) 2 # 2 % 3 == 2 \u003e\u003e\u003e next(it) 5 # 5 % 3 == 2 \u003e\u003e\u003e next(it) 8 # 8 % 3 == 2 Then how can we get a list of generators. for loop !ü§ó def remainders_generator(m): \"\"\" Yields m generators. The ith yielded generator yields natural numbers whose remainder is i when divided by m. \u003e\u003e\u003e import types \u003e\u003e\u003e [isinstance(gen, types.GeneratorType) for gen in remainders_generator(5)] [True, True, True, True, True] \u003e\u003e\u003e remainders_four = remainders_generator(4) \u003e\u003e\u003e for i in range(4): ... print(\"First 3 natural numbers with remainder {0} when divided by 4:\".format(i)) ... gen = next(remainders_four) ... for _ in range(3): ... print(next(gen)) First 3 natural numbers with remainder 0 when divided by 4: 4 8 12 First 3 natural numbers with remainder 1 when divided by 4: 1 5 9 First 3 natural numbers with remainder 2 when divided by 4: 2 6 10 First 3 natural numbers with remainder 3 when divided by 4: 3 7 11 \"\"\" def helper(i, m): num = 1 # loop variable while True: if num % m == i: yield num num += 1 for i in range(m): yield helper(i, m) ","date":"2022-02-22","objectID":"/hw05-of-cs61a-of-ucb/:0:5","tags":["Course","Python"],"title":"Hw05 of CS61A of UCB(2021-Fall)","uri":"/hw05-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"the simple solutions for lab06 of CS61A of UCB","date":"2022-02-20","objectID":"/lab06-cs61a-of-ucb/","tags":["Course","Python"],"title":"Lab06 CS61A of UCB(2021-Fall)","uri":"/lab06-cs61a-of-ucb/"},{"categories":["Course"],"content":"Mutability Write a function which takes in a list lst, an argument entry, and another argument elem. This function will check through each item in lst to see if it is equal to entry. Upon finding an item equal to entry, the function should modify the list by placing elem into lst right after the item. At the end of the function, the modified list should be returned. See the doctests for examples on how this function is utilized. Important: Use list mutation to modify the original list. No new lists should be created or returned. Note: If the values passed into entry and elem are equivalent, make sure you‚Äôre not creating an infinitely long list while iterating through it. If you find that your code is taking more than a few seconds to run, the function may be in a loop of inserting new values. Note that we can‚Äôt insert elements when we iterate using for loop. I remember I once saw this in Effective Python. You can find out by debugging yourself. Because the range of i is determined when we use for i in range(len (lst)). But when we insert new values inside the for loop, the list actually becomes longer (but the i is still in the original range). Therefore, elements that exceed the original length will not be accessed. Note that the code below is wrong üôÖ‚Äç‚ôÇÔ∏è def insert_items(lst, entry, elem): is_the_same = (entry == elem) while True: no_entry = True for i in range(len(lst)): if lst[i] == entry: if i == len(lst) - 1: lst.append(elem) else: lst.insert(i + 1, elem) no_entry = False # avoid infinite loop if is_the_same: i += 1 if no_entry: return lst The correct solution should be to use the while loop with the list.index(x[, start[, end]]) method, the code is as follows: def insert_items(lst, entry, elem): \"\"\"Inserts elem into lst after each occurence of entry and then returns lst. \u003e\u003e\u003e test_lst = [1, 5, 8, 5, 2, 3] \u003e\u003e\u003e new_lst = insert_items(test_lst, 5, 7) \u003e\u003e\u003e new_lst [1, 5, 7, 8, 5, 7, 2, 3] \u003e\u003e\u003e double_lst = [1, 2, 1, 2, 3, 3] \u003e\u003e\u003e double_lst = insert_items(double_lst, 3, 4) \u003e\u003e\u003e double_lst [1, 2, 1, 2, 3, 4, 3, 4] \u003e\u003e\u003e large_lst = [1, 4, 8] \u003e\u003e\u003e large_lst2 = insert_items(large_lst, 4, 4) \u003e\u003e\u003e large_lst2 [1, 4, 4, 8] \u003e\u003e\u003e large_lst3 = insert_items(large_lst2, 4, 6) \u003e\u003e\u003e large_lst3 [1, 4, 6, 4, 6, 8] \u003e\u003e\u003e large_lst3 is large_lst True \u003e\u003e\u003e # Ban creating new lists \u003e\u003e\u003e from construct_check import check \u003e\u003e\u003e check(HW_SOURCE_FILE, 'insert_items', ... ['List', 'ListComp', 'Slice']) True \"\"\" pos, cnt = 0, 0 for i in lst: if i == entry: cnt += 1 while cnt \u003e 0: idx = lst.index(entry, pos) pos = idx + 1 if idx == len(lst) - 1: lst.append(elem) else: lst.insert(idx + 1, elem) cnt -= 1 return lst ","date":"2022-02-20","objectID":"/lab06-cs61a-of-ucb/:1:0","tags":["Course","Python"],"title":"Lab06 CS61A of UCB(2021-Fall)","uri":"/lab06-cs61a-of-ucb/"},{"categories":["Course"],"content":"Iterators ","date":"2022-02-20","objectID":"/lab06-cs61a-of-ucb/:2:0","tags":["Course","Python"],"title":"Lab06 CS61A of UCB(2021-Fall)","uri":"/lab06-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q4: Count Occurrences Implement count_occurrences, which takes in an iterator t and returns the number of times the value x appears in the first n elements of t. A value appears in a sequence of elements if it is equal to an entry in the sequence. Note: You can assume that t will have at least n elements. This question is mainly to let us learn to use the two functions: iter and next. We can use while n \u003e 0 to control access to only the first n elements. We will iterate the range while counting occurrences. def count_occurrences(t, n, x): \"\"\"Return the number of times that x appears in the first n elements of iterator t. \u003e\u003e\u003e s = iter([10, 9, 10, 9, 9, 10, 8, 8, 8, 7]) \u003e\u003e\u003e count_occurrences(s, 10, 9) 3 \u003e\u003e\u003e s2 = iter([10, 9, 10, 9, 9, 10, 8, 8, 8, 7]) \u003e\u003e\u003e count_occurrences(s2, 3, 10) 2 \u003e\u003e\u003e s = iter([3, 2, 2, 2, 1, 2, 1, 4, 4, 5, 5, 5]) \u003e\u003e\u003e count_occurrences(s, 1, 3) 1 \u003e\u003e\u003e count_occurrences(s, 4, 2) 3 \u003e\u003e\u003e next(s) 2 \u003e\u003e\u003e s2 = iter([4, 1, 6, 6, 7, 7, 8, 8, 2, 2, 2, 5]) \u003e\u003e\u003e count_occurrences(s2, 6, 6) 2 \"\"\" it = iter(t) cnt = 0 while n \u003e 0: val = next(it) if val == x: cnt += 1 n -= 1 return cnt ","date":"2022-02-20","objectID":"/lab06-cs61a-of-ucb/:2:1","tags":["Course","Python"],"title":"Lab06 CS61A of UCB(2021-Fall)","uri":"/lab06-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q5: Repeated Implement repeated, which takes in an iterator t and returns the first value in t that appears k times in a row. Note: You can assume that the iterator t will have a value that appears at least k times in a row. If you are receiving a StopIteration, your repeated function is likely not identifying the correct value. Your implementation should iterate through the items in a way such that if the same iterator is passed into repeated twice, it should continue in the second call at the point it left off in the first. An example of this behavior is in the doctests. We address two important issues in this problem: How to find consecutive k values? We need to set last_val to remember what the previous value was, so that it can be compared with the current value(while we iterate the list). How to ensure that the next call will start from the point it left off in the first? If you have followed the course carefully, you may remember how to do it. We should use a higher-order function, define another function in repeated and bind the iterator to this nested function. This way we can guarantee that we can start from the previous position every time. If you forget, you can look at this [link](http://composingprograms.com/pages/24-mutable -data.html)(2.4.4 Local state) def repeated(t, k): \"\"\"Return the first value in iterator T that appears K times in a row. Iterate through the items such that if the same iterator is passed into the function twice, it continues in the second call at the point it left off in the first. \u003e\u003e\u003e s = iter([10, 9, 10, 9, 9, 10, 8, 8, 8, 7]) \u003e\u003e\u003e repeated(s, 2) 9 \u003e\u003e\u003e s2 = iter([10, 9, 10, 9, 9, 10, 8, 8, 8, 7]) \u003e\u003e\u003e repeated(s2, 3) 8 \u003e\u003e\u003e s = iter([3, 2, 2, 2, 1, 2, 1, 4, 4, 5, 5, 5]) \u003e\u003e\u003e repeated(s, 3) 2 \u003e\u003e\u003e repeated(s, 3) 5 \u003e\u003e\u003e s2 = iter([4, 1, 6, 6, 7, 7, 8, 8, 2, 2, 2, 5]) \u003e\u003e\u003e repeated(s2, 3) 2 \"\"\" assert k \u003e 1 last_val, it = None, iter(t) def helper(k): nonlocal last_val nonlocal it cnt = 0 while True: val = next(it) if last_val is None or val != last_val: last_val, cnt = val, 1 else: cnt += 1 if cnt == k: return val return helper(k) ","date":"2022-02-20","objectID":"/lab06-cs61a-of-ucb/:2:2","tags":["Course","Python"],"title":"Lab06 CS61A of UCB(2021-Fall)","uri":"/lab06-cs61a-of-ucb/"},{"categories":["Course"],"content":"The simple solutions of hw04 of CS61A of UCB","date":"2022-02-20","objectID":"/hw04-of-cs61a-of-ucb/","tags":["Course","Python"],"title":"Hw04 of CS61A of UCB(2021-Fall)","uri":"/hw04-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Mobiles ","date":"2022-02-20","objectID":"/hw04-of-cs61a-of-ucb/:1:0","tags":["Course","Python"],"title":"Hw04 of CS61A of UCB(2021-Fall)","uri":"/hw04-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q2: Weights Implement the planet data abstraction by completing the planet constructor and the size selector so that a planet is represented using a two-element list where the first element is the string 'planet' and the second element is its size. From the description, we can know what is planet. It is a ['planet', size]. Then we can take a look at the mobile function, the solution is quite similar. def planet(size): \"\"\"Construct a planet of some size.\"\"\" assert size \u003e 0 return ['planet', size] def size(w): \"\"\"Select the size of a planet.\"\"\" assert is_planet(w), 'must call size on a planet' return w[1] ","date":"2022-02-20","objectID":"/hw04-of-cs61a-of-ucb/:1:1","tags":["Course","Python"],"title":"Hw04 of CS61A of UCB(2021-Fall)","uri":"/hw04-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q3: Balanced Implement the balanced function, which returns whether m is a balanced mobile. A mobile is balanced if both of the following conditions are met: The torque applied by its left arm is equal to that applied by its right arm. The torque of the left arm is the length of the left rod multiplied by the total weight hanging from that rod. Likewise for the right. For example, if the left arm has a length of 5, and there is a mobile hanging at the end of the left arm of weight 10, the torque on the left side of our mobile is 50. Each of the mobiles hanging at the end of its arms is balanced. Planets themselves are balanced, as there is nothing hanging off of them. This problem is a little tricky. We need to solve this problem recursively. We can call a mobile is balanced if: It is a planet. THE BASE CASE!! It is a arm and the total_weight(left_arm) == total_weight(right_arm). And, the sub-mobile itself should be balanced The key: distinguish arm, planet, mobile these 3 concepts. üò¢ def balanced(m): \"\"\"Return whether m is balanced. \u003e\u003e\u003e t, u, v = examples() \u003e\u003e\u003e balanced(t) True \u003e\u003e\u003e balanced(v) True \u003e\u003e\u003e w = mobile(arm(3, t), arm(2, u)) \u003e\u003e\u003e balanced(w) False \u003e\u003e\u003e balanced(mobile(arm(1, v), arm(1, w))) False \u003e\u003e\u003e balanced(mobile(arm(1, w), arm(1, v))) False \u003e\u003e\u003e from construct_check import check \u003e\u003e\u003e # checking for abstraction barrier violations by banning indexing \u003e\u003e\u003e check(HW_SOURCE_FILE, 'balanced', ['Index']) True \"\"\" # planet is balanced if is_planet(m): return True left_arm, right_arm = left(m), right(m) # end(...arm) will is a mobile or a planet left_val = length(left_arm) * total_weight(end(left_arm)) right_val = length(right_arm) * total_weight(end(right_arm)) return left_val == right_val and balanced(end(left_arm)) and balanced(end(right_arm)) ","date":"2022-02-20","objectID":"/hw04-of-cs61a-of-ucb/:1:2","tags":["Course","Python"],"title":"Hw04 of CS61A of UCB(2021-Fall)","uri":"/hw04-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q4: Totals Implement totals_tree, which takes in a mobile or planet and returns a tree whose root is the total weight of the input. For a planet, totals_tree should return a leaf. For a mobile, totals_tree should return a tree whose label is that mobile‚Äôs total weight, and whose branches are totals_trees for the ends of its arms. As a reminder, the description of the tree data abstraction can be found here. What we want to do is convert the mobile into a tree. The base case is to make a leaf when we encounter the planet, otherwise, we make a sub-tree instead. def totals_tree(m): \"\"\"Return a tree representing the mobile with its total weight at the root. \u003e\u003e\u003e t, u, v = examples() \u003e\u003e\u003e print_tree(totals_tree(t)) 3 2 1 \u003e\u003e\u003e print_tree(totals_tree(u)) 6 1 5 3 2 \u003e\u003e\u003e print_tree(totals_tree(v)) 9 3 2 1 6 1 5 3 2 \u003e\u003e\u003e from construct_check import check \u003e\u003e\u003e # checking for abstraction barrier violations by banning indexing \u003e\u003e\u003e check(HW_SOURCE_FILE, 'totals_tree', ['Index']) True \"\"\" if is_planet(m): return tree(size(m)) return tree(total_weight(m), [totals_tree(i) for i in [end(left(m)), end(right(m))]]) ","date":"2022-02-20","objectID":"/hw04-of-cs61a-of-ucb/:1:3","tags":["Course","Python"],"title":"Hw04 of CS61A of UCB(2021-Fall)","uri":"/hw04-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"More trees ","date":"2022-02-20","objectID":"/hw04-of-cs61a-of-ucb/:2:0","tags":["Course","Python"],"title":"Hw04 of CS61A of UCB(2021-Fall)","uri":"/hw04-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q5: Replace Loki at Leaf Define replace_loki_at_leaf, which takes a tree t and a value lokis_replacement. replace_loki_at_leaf returns a new tree that‚Äôs the same as t except that every leaf label equal to \"loki\" has been replaced with lokis_replacement. If you want to learn about the Norse mythology referenced in this problem, you can read about it here. The base case is the leaf node. We need to check if its label is equal to ‚Äôloki‚Äô. If it is the truth, we will make a new leaf, otherwise, we will just return the original leaf. def replace_loki_at_leaf(t, lokis_replacement): \"\"\"Returns a new tree where every leaf value equal to \"loki\" has been replaced with lokis_replacement. \u003e\u003e\u003e yggdrasil = tree('odin', ... [tree('balder', ... [tree('loki'), ... tree('freya')]), ... tree('frigg', ... [tree('loki')]), ... tree('loki', ... [tree('sif'), ... tree('loki')]), ... tree('loki')]) \u003e\u003e\u003e laerad = copy_tree(yggdrasil) # copy yggdrasil for testing purposes \u003e\u003e\u003e print_tree(replace_loki_at_leaf(yggdrasil, 'freya')) odin balder freya freya frigg freya loki sif freya freya \u003e\u003e\u003e laerad == yggdrasil # Make sure original tree is unmodified True \"\"\" if is_leaf(t): if label(t) == 'loki': return tree(lokis_replacement) return t return tree(label(t), [replace_loki_at_leaf(b, lokis_replacement) for b in branches(t)]) ","date":"2022-02-20","objectID":"/hw04-of-cs61a-of-ucb/:2:1","tags":["Course","Python"],"title":"Hw04 of CS61A of UCB(2021-Fall)","uri":"/hw04-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q6: Has Path Write a function has_path that takes in a tree t and a string word. It returns True if there is a path that starts from the root where the entries along the path spell out the word, and False otherwise. (This data structure is called a trie, and it has a lot of cool applications, such as autocomplete). You may assume that every node‚Äôs labelis exactly one character. What is the base case ? We need to memorize the current word along the path. For example, we got label(t) when we start from the root of the tree(h). When we pay a visit to the tree('i')(the first branch), the current word will be h + i = hi. So we need to define a helper function. The base case is either the current word is equal to the target(word) or the current word is not in target(word), which means we don‚Äôt need to go deeper into this tree How to break down the current problem into simpler ones ? We use any in python to check if any of the branches contain the word we want. def has_path(t, word): \"\"\"Return whether there is a path in a tree where the entries along the path spell out a particular word. \u003e\u003e\u003e greetings = tree('h', [tree('i'), ... tree('e', [tree('l', [tree('l', [tree('o')])]), ... tree('y')])]) \u003e\u003e\u003e print_tree(greetings) h i e l l o y \u003e\u003e\u003e has_path(greetings, 'h') True \u003e\u003e\u003e has_path(greetings, 'i') False \u003e\u003e\u003e has_path(greetings, 'hi') True \u003e\u003e\u003e has_path(greetings, 'hello') True \u003e\u003e\u003e has_path(greetings, 'hey') True \u003e\u003e\u003e has_path(greetings, 'bye') False \u003e\u003e\u003e has_path(greetings, 'hint') False \"\"\" assert len(word) \u003e 0, 'no path for empty word.' def helper(t, cur): if cur == word: return True if cur not in word: return False return any([helper(b, cur + label(b)) for b in branches(t)]) return helper(t, label(t)) ","date":"2022-02-20","objectID":"/hw04-of-cs61a-of-ucb/:2:2","tags":["Course","Python"],"title":"Hw04 of CS61A of UCB(2021-Fall)","uri":"/hw04-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Trees ","date":"2022-02-20","objectID":"/hw04-of-cs61a-of-ucb/:3:0","tags":["Course","Python"],"title":"Hw04 of CS61A of UCB(2021-Fall)","uri":"/hw04-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q7: Preorder Define the function preorder, which takes in a tree as an argument and returns a list of all the entries in the tree in the order that print_tree would print them. The following diagram shows the order that the nodes would get printed, with the arrows representing function calls. The preorder function is one of the basic methods when we want to visit every node in a tree. We need to memorize the label of the root before we visit its sub-tree. def preorder(t): \"\"\"Return a list of the entries in this tree in the order that they would be visited by a preorder traversal (see problem description). \u003e\u003e\u003e numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])]) \u003e\u003e\u003e preorder(numbers) [1, 2, 3, 4, 5, 6, 7] \u003e\u003e\u003e preorder(tree(2, [tree(4, [tree(6)])])) [2, 4, 6] \"\"\" result = [] def helper(t): if t is not None: result.append(label(t)) for b in branches(t): helper(b) helper(t) return result ","date":"2022-02-20","objectID":"/hw04-of-cs61a-of-ucb/:3:1","tags":["Course","Python"],"title":"Hw04 of CS61A of UCB(2021-Fall)","uri":"/hw04-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Data Abstraction ","date":"2022-02-20","objectID":"/hw04-of-cs61a-of-ucb/:4:0","tags":["Course","Python"],"title":"Hw04 of CS61A of UCB(2021-Fall)","uri":"/hw04-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q8: Interval Abstraction Acknowledgements. This interval arithmetic example is based on a classic problem from Structure and Interpretation of Computer Programs, Section 2.1.4. Introduction. Alyssa P. Hacker is designing a system to help people solve engineering problems. One feature she wants to provide in her system is the ability to manipulate inexact quantities (such as measurements from physical devices) with known precision, so that when computations are done with such approximate quantities the results will be numbers of known precision. For example, if a measured quantity x lies between two numbers a and b, Alyssa would like her system to use this range in computations involving x. Alyssa‚Äôs idea is to implement interval arithmetic as a set of arithmetic operations for combining ‚Äúintervals‚Äù (objects that represent the range of possible values of an inexact quantity). The result of adding, subracting, multiplying, or dividing two intervals is also an interval, one that represents the range of the result. Alyssa suggests the existence of an abstraction called an ‚Äúinterval‚Äù that has two endpoints: a lower bound and an upper bound. She also presumes that, given the endpoints of an interval, she can create the interval using data abstraction. Using this constructor and the appropriate selectors, she defines the following operations: Alyssa‚Äôs program is incomplete because she has not specified the implementation of the interval abstraction. She has implemented the constructor for you; fill in the implementation of the selectors. The calculation system of this question is actually used to calculate the resistance. We know that there will be tolerance in the resistor (such as $\\pm5%$), so the real resistance value should be in an interval. This is the interval indicates. The interval is just a list with size 2. To get the lower bound and the upper bound. We just need to return x[0] or x[1] def interval(a, b): \"\"\"Construct an interval from a to b.\"\"\" assert a \u003c= b, 'Lower bound cannot be greater than upper bound' return [a, b] def lower_bound(x): \"\"\"Return the lower bound of interval x.\"\"\" return x[0] def upper_bound(x): \"\"\"Return the upper bound of interval x.\"\"\" return x[1] ","date":"2022-02-20","objectID":"/hw04-of-cs61a-of-ucb/:4:1","tags":["Course","Python"],"title":"Hw04 of CS61A of UCB(2021-Fall)","uri":"/hw04-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q9: Interval Arithmetic After implementing the abstraction, Alyssa decided to implement a few interval arithmetic functions. This is her current implementation for interval multiplication. Unfortunately there are some data abstraction violations, so your task is to fix this code before someone sets it on fire. def mul_interval(x, y): \"\"\"Return the interval that contains the product of any value in x and any value in y.\"\"\" p1 = x[0] * y[0] p2 = x[0] * y[1] p3 = x[1] * y[0] p4 = x[1] * y[1] return [min(p1, p2, p3, p4), max(p1, p2, p3, p4)] There are many data abstraction violations in mul_interval. We can‚Äôt use x[0] or x[1] to get the lower bound and the upper bound. We should use the function lower_bound() and the upper_bound() instead. In addition, we can‚Äôt use [...] to make an interval. That‚Äôs a violation too! def mul_interval(x, y): \"\"\"Return the interval that contains the product of any value in x and any value in y.\"\"\" p1 = lower_bound(x) * lower_bound(y) p2 = lower_bound(x) * upper_bound(y) p3 = upper_bound(x) * lower_bound(y) p4 = upper_bound(x) * upper_bound(y) return interval(min(p1, p2, p3, p4), max(p1, p2, p3, p4)) Interval Subtraction Using a similar approach as mul_interval and add_interval, define a subtraction function for intervals. If you find yourself repeating code, see if you can reuse functions that have already been implemented. This solution is almost identical to the mul_interval. If you are using vim as your editor, you just need to copy the content of mul_interval and use visual mode to select * then press r- to substitute them. def sub_interval(x, y): \"\"\"Return the interval that contains the difference between any value in x and any value in y.\"\"\" p1 = lower_bound(x) - lower_bound(y) p2 = lower_bound(x) - upper_bound(y) p3 = upper_bound(x) - lower_bound(y) p4 = upper_bound(x) - upper_bound(y) return interval(min(p1, p2, p3, p4), max(p1, p2, p3, p4)) Interval Division Alyssa implements division below by multiplying by the reciprocal of y. A systems programmer looks over Alyssa‚Äôs shoulder and comments that it is not clear what it means to divide by an interval that spans zero. Add an assertstatement to Alyssa‚Äôs code to ensure that no such interval is used as a divisor: To avoid the divisor span zero, all we have to do is check if lower_bound(y) \u003e 0 ü§ó def div_interval(x, y): \"\"\"Return the interval that contains the quotient of any value in x divided by any value in y. Division is implemented as the multiplication of x by the reciprocal of y.\"\"\" assert lower_bound(y) \u003e 0, \"AssertionError!\" reciprocal_y = interval(1 / upper_bound(y), 1 / lower_bound(y)) return mul_interval(x, reciprocal_y) ","date":"2022-02-20","objectID":"/hw04-of-cs61a-of-ucb/:4:2","tags":["Course","Python"],"title":"Hw04 of CS61A of UCB(2021-Fall)","uri":"/hw04-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q10: Par Diff After considerable work, Alyssa P. Hacker delivers her finished system. Several years later, after she has forgotten all about it, she gets a frenzied call from an irate user, Lem E. Tweakit. It seems that Lem has noticed that theformula for parallel resistors can be written in two algebraically equivalent ways: par1(r1, r2) = (r1 * r2) / (r1 + r2) or par2(r1, r2) = 1 / (1/r1 + 1/r2) He has written the following two programs, each of which computes the parallel_resistors formula differently: def par2(r1, r2): one = interval(1, 1) rep_r1 = div_interval(one, r1) rep_r2 = div_interval(one, r2) return div_interval(one, add_interval(rep_r1, rep_r2)) Lem points out that Alyssa‚Äôs program gives different answers for the two ways of computing. Find two intervals r1 and r2 that demonstrate the difference in behavior between par1 and par2 when passed into each of the two functions. Demonstrate that Lem is right. Investigate the behavior of the system on a variety of arithmetic expressions. Make some intervals r1 and r2, and show that par1 and par2 can give different results. If you want to understand the mechanism why this happens, you may check this link def check_par(): \"\"\"Return two intervals that give different results for parallel resistors. \u003e\u003e\u003e r1, r2 = check_par() \u003e\u003e\u003e x = par1(r1, r2) \u003e\u003e\u003e y = par2(r1, r2) \u003e\u003e\u003e lower_bound(x) != lower_bound(y) or upper_bound(x) != upper_bound(y) True \"\"\" r1 = interval(5, 7) r2 = interval(5, 7) return r1, r2 ","date":"2022-02-20","objectID":"/hw04-of-cs61a-of-ucb/:4:3","tags":["Course","Python"],"title":"Hw04 of CS61A of UCB(2021-Fall)","uri":"/hw04-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"the simple solutions for lab05 of CS61A of UCB","date":"2022-02-19","objectID":"/lab05-cs61a-of-ucb/","tags":["Course","Python"],"title":"Lab05 CS61A of UCB(2021-Fall)","uri":"/lab05-cs61a-of-ucb/"},{"categories":["Course"],"content":"Lists ","date":"2022-02-19","objectID":"/lab05-cs61a-of-ucb/:1:0","tags":["Course","Python"],"title":"Lab05 CS61A of UCB(2021-Fall)","uri":"/lab05-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q1: Factors List Write factors_list, which takes a number n and returns a list of its factors in ascending order. We can know such a basic mathematical fact: the factor of a number can only be up to half of it (when the number is even). So we use for i in range(1, n // 2 + 1) def factors_list(n): \"\"\"Return a list containing all the numbers that divide `n` evenly, except for the number itself. Make sure the list is in ascending order. \u003e\u003e\u003e factors_list(6) [1, 2, 3] \u003e\u003e\u003e factors_list(8) [1, 2, 4] \u003e\u003e\u003e factors_list(28) [1, 2, 4, 7, 14] \"\"\" all_factors = [] # the biggest number which can divide `n` evenly will be `n // 2` for i in range(1, n // 2 + 1): if n % i == 0: all_factors.append(i) return all_factors ","date":"2022-02-19","objectID":"/lab05-cs61a-of-ucb/:1:1","tags":["Course","Python"],"title":"Lab05 CS61A of UCB(2021-Fall)","uri":"/lab05-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q2: Flatten Write a function flatten that takes a list and ‚Äúflattens‚Äù it. The list could be a deep list, meaning that there could be a multiple layers of nesting within the list. For example, one use case of flatten could be the following: \u003e\u003e\u003e lst = [1, [[2], 3], 4, [5, 6]] \u003e\u003e\u003e flatten(lst) [1, 2, 3, 4, 5, 6] Make sure your solution does not mutate the input list. Apparently, we can solve this probelm recursively. For nested list, we need to recursively decompose it. What is the base case ? If we get a empty list then we return [] How to break down the current problem into simpler ones ? That is how we can reduce the size of the problem, we can try to process the element in the first position of the nested list each time, depending on whether they are list type, which can break down this probelm into 2 cases. Finally, the code will be like: def flatten(s): \"\"\"Returns a flattened version of list s. \u003e\u003e\u003e flatten([1, 2, 3]) # normal list [1, 2, 3] \u003e\u003e\u003e x = [1, [2, 3], 4] # deep list \u003e\u003e\u003e flatten(x) [1, 2, 3, 4] \u003e\u003e\u003e x # Ensure x is not mutated [1, [2, 3], 4] \u003e\u003e\u003e x = [[1, [1, 1]], 1, [1, 1]] # deep list \u003e\u003e\u003e flatten(x) [1, 1, 1, 1, 1, 1] \u003e\u003e\u003e x [[1, [1, 1]], 1, [1, 1]] \"\"\" if s == []: return [] elif type(s[0]) == list: return flatten(s[0]) + flatten(s[1:]) else: return s[:1] + flatten(s[1:]) ","date":"2022-02-19","objectID":"/lab05-cs61a-of-ucb/:1:2","tags":["Course","Python"],"title":"Lab05 CS61A of UCB(2021-Fall)","uri":"/lab05-cs61a-of-ucb/"},{"categories":["Course"],"content":"Data Abstraction ","date":"2022-02-19","objectID":"/lab05-cs61a-of-ucb/:2:0","tags":["Course","Python"],"title":"Lab05 CS61A of UCB(2021-Fall)","uri":"/lab05-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q3: Distance We will now implement the function distance, which computes the distance between two city objects. Recall that the distance between two coordinate pairs (x1, y1) and (x2, y2) can be found by calculating the sqrt of (x1 - x2)**2 + (y1 - y2)**2. We have already imported sqrt for your convenience. Use the latitude and longitude of a city as its coordinates; you‚Äôll need to use the selectors to access this info! We just need to call get_lat and get_lon on the arguments to get the value and then calculate it ü§ó def distance(city_a, city_b): \"\"\" \u003e\u003e\u003e city_a = make_city('city_a', 0, 1) \u003e\u003e\u003e city_b = make_city('city_b', 0, 2) \u003e\u003e\u003e distance(city_a, city_b) 1.0 \u003e\u003e\u003e city_c = make_city('city_c', 6.5, 12) \u003e\u003e\u003e city_d = make_city('city_d', 2.5, 15) \u003e\u003e\u003e distance(city_c, city_d) 5.0 \"\"\" x = (get_lat(city_a) - get_lat(city_b)) ** 2 y = (get_lon(city_a) - get_lon(city_b)) ** 2 return sqrt(x + y) ","date":"2022-02-19","objectID":"/lab05-cs61a-of-ucb/:2:1","tags":["Course","Python"],"title":"Lab05 CS61A of UCB(2021-Fall)","uri":"/lab05-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q4: Closer city Next, implement closer_city, a function that takes a latitude, longitude, and two cities, and returns the name of the city that is relatively closer to the provided latitude and longitude. You may only use the selectors and constructors introduced above and the distance function you just defined for this question. Hint: How can you use your distance function to find the distance between the given location and each of the given cities? According to the Hint and our distance function wrote in Q3, we know that we should build a virtual city based on lat and lon, and then use the distance function to calculate and compare the distance. This saves you from writing a lot of repetitive code. def closer_city(lat, lon, city_a, city_b): \"\"\" Returns the name of either city_a or city_b, whichever is closest to coordinate (lat, lon). If the two cities are the same distance away from the coordinate, consider city_b to be the closer city. \u003e\u003e\u003e berkeley = make_city('Berkeley', 37.87, 112.26) \u003e\u003e\u003e stanford = make_city('Stanford', 34.05, 118.25) \u003e\u003e\u003e closer_city(38.33, 121.44, berkeley, stanford) 'Stanford' \u003e\u003e\u003e bucharest = make_city('Bucharest', 44.43, 26.10) \u003e\u003e\u003e vienna = make_city('Vienna', 48.20, 16.37) \u003e\u003e\u003e closer_city(41.29, 174.78, bucharest, vienna) 'Bucharest' \"\"\" tmp = make_city('tmp', lat, lon) if distance(tmp, city_a) \u003c distance(tmp, city_b): return get_name(city_a) else: return get_name(city_b) ","date":"2022-02-19","objectID":"/lab05-cs61a-of-ucb/:2:2","tags":["Course","Python"],"title":"Lab05 CS61A of UCB(2021-Fall)","uri":"/lab05-cs61a-of-ucb/"},{"categories":["Course"],"content":"Trees ","date":"2022-02-19","objectID":"/lab05-cs61a-of-ucb/:3:0","tags":["Course","Python"],"title":"Lab05 CS61A of UCB(2021-Fall)","uri":"/lab05-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q6: Finding Berries! The squirrels on campus need your help! There are a lot of trees on campus and the squirrels would like to know which ones contain berries. Define the function berry_finder, which takes in a tree and returns True if the tree contains a node with the value 'berry' and False otherwise. Hint: To iterate through each of the branches of a particular tree, you can consider using a for loop to get each branch. This is a very classic tree recursion problem. We need to find the node whose label is berry in all nodes. The recursive idea is as follows: What is the base case ? Apparently, we come to the base case when we come to the leaf node. All we have to do here is to check the label of it. How to break down the current problem into simpler ones ? It is easy to figure out that we only need to have berry in a node of any branch, or the label of our current branch(root node in this branch) is berry. def berry_finder(t): \"\"\"Returns True if t contains a node with the value 'berry' and False otherwise. \u003e\u003e\u003e scrat = tree('berry') \u003e\u003e\u003e berry_finder(scrat) True \u003e\u003e\u003e sproul = tree('roots', [tree('branch1', [tree('leaf'), tree('berry')]), tree('branch2')]) \u003e\u003e\u003e berry_finder(sproul) True \u003e\u003e\u003e numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])]) \u003e\u003e\u003e berry_finder(numbers) False \u003e\u003e\u003e t = tree(1, [tree('berry',[tree('not berry')])]) \u003e\u003e\u003e berry_finder(t) True \"\"\" if is_leaf(t): return label(t) == 'berry' return any([berry_finder(b) for b in branches(t)]) or label(t) == 'berry' ","date":"2022-02-19","objectID":"/lab05-cs61a-of-ucb/:3:1","tags":["Course","Python"],"title":"Lab05 CS61A of UCB(2021-Fall)","uri":"/lab05-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q7: Sprout leaves Define a function sprout_leaves that takes in a tree, t, and a list of leaves, leaves. It produces a new tree that is identical to t, but where each old leaf node has new branches, one for each leaf in leaves. For example, say we have the tree t = tree(1, [tree(2), tree(3, [tree(4)])]): 1 / \\ 2 3 | 4 If we call sprout_leaves(t, [5, 6]), the result is the following tree: 1 / \\ 2 3 / \\ | 5 6 4 / \\ 5 6 This is also a problem can be solved recursively. Obviously, the base case is the leaf node again. When we encounter a leaf node, we need to add leaves. If it is a branch, then we have to check each of its subtrees. def sprout_leaves(t, leaves): \"\"\"Sprout new leaves containing the data in leaves at each leaf in the original tree t and return the resulting tree. \u003e\u003e\u003e t1 = tree(1, [tree(2), tree(3)]) \u003e\u003e\u003e print_tree(t1) 1 2 3 \u003e\u003e\u003e new1 = sprout_leaves(t1, [4, 5]) \u003e\u003e\u003e print_tree(new1) 1 2 4 5 3 4 5 \u003e\u003e\u003e t2 = tree(1, [tree(2, [tree(3)])]) \u003e\u003e\u003e print_tree(t2) 1 2 3 \u003e\u003e\u003e new2 = sprout_leaves(t2, [6, 1, 2]) \u003e\u003e\u003e print_tree(new2) 1 2 3 6 1 2 \"\"\" if is_leaf(t): return tree(label(t), [tree(leaf) for leaf in leaves]) return tree(label(t), [sprout_leaves(b, leaves) for b in branches(t)]) ","date":"2022-02-19","objectID":"/lab05-cs61a-of-ucb/:3:2","tags":["Course","Python"],"title":"Lab05 CS61A of UCB(2021-Fall)","uri":"/lab05-cs61a-of-ucb/"},{"categories":["Course"],"content":"the simple solutions for lab04 of CS61A of UCB","date":"2022-02-03","objectID":"/lab04-cs61a-of-ucb/","tags":["Course","Python"],"title":"Lab04 CS61A of UCB(2021-Fall)","uri":"/lab04-cs61a-of-ucb/"},{"categories":["Course"],"content":"Intro I find it really interesting to solve recursive problems. I like this way of solving problems, the code is concise and intuitive, which is why I wrote this blog. üìí How to solve a recursive problem ? What is the base case ? How to break down the current problem into simpler ones ? Later, I will follow this idea to solve the recursion problem in this lab. ","date":"2022-02-03","objectID":"/lab04-cs61a-of-ucb/:1:0","tags":["Course","Python"],"title":"Lab04 CS61A of UCB(2021-Fall)","uri":"/lab04-cs61a-of-ucb/"},{"categories":["Course"],"content":"Recursion ","date":"2022-02-03","objectID":"/lab04-cs61a-of-ucb/:2:0","tags":["Course","Python"],"title":"Lab04 CS61A of UCB(2021-Fall)","uri":"/lab04-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q2: Summation Write a recursive implementation of summation, which takes a positive integer n and a function term. It applies term to every number from 1 to n including n and returns the sum. Important: Use recursion; the tests will fail if you use any loops (for, while). What is the base case ? This is easy to think, because we have to calculate from 1 to n. Apparently, n = 1 is the base case, which returns term(n) How to break down the current problem into simpler ones ? We call summation(n - 1) to make this problem simpler. def summation(n, term): \"\"\"Return the sum of numbers 1 through n (including n) w√≠th term applied to each number. Implement using recursion! \u003e\u003e\u003e summation(5, lambda x: x * x * x) # 1^3 + 2^3 + 3^3 + 4^3 + 5^3 225 \u003e\u003e\u003e summation(9, lambda x: x + 1) # 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 54 \u003e\u003e\u003e summation(5, lambda x: 2**x) # 2^1 + 2^2 + 2^3 + 2^4 + 2^5 62 \u003e\u003e\u003e # Do not use while/for loops! \u003e\u003e\u003e from construct_check import check \u003e\u003e\u003e # ban iteration \u003e\u003e\u003e check(HW_SOURCE_FILE, 'summation', ... ['While', 'For']) True \"\"\" assert n \u003e= 1 # base case: n = 1 if n == 1: return term(n) else: return term(n) + summation(n - 1, term) ","date":"2022-02-03","objectID":"/lab04-cs61a-of-ucb/:2:1","tags":["Course","Python"],"title":"Lab04 CS61A of UCB(2021-Fall)","uri":"/lab04-cs61a-of-ucb/"},{"categories":["Course"],"content":"Tree Recursion ","date":"2022-02-03","objectID":"/lab04-cs61a-of-ucb/:3:0","tags":["Course","Python"],"title":"Lab04 CS61A of UCB(2021-Fall)","uri":"/lab04-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q3: Pascal‚Äôs Triangle Here‚Äôs a part of the Pascal‚Äôs trangle: 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 Every number in Pascal‚Äôs triangle is defined as the sum of the item above it and the item above and to the left of it. Use 0 if the item does not exist. Define the procedure pascal(row, column) which takes a row and a column, and finds the value of the item at that position in Pascal‚Äôs triangle. Rows and columns are zero-indexed; that is, the first row is row 0 instead of 1 and the first column is column 0 instead of column 1. For example, the item at row 2, column 1 in Pascal‚Äôs triangle is 2. This probelm is a classical Problem. According to the definition, we know Pascal(i, j) = Pascal(i - 1, j) + Pascal(i - 1, j - 1). Apparently, the definition gives us a way to make this recursive problem easier. Then we have to ask us what is the base case ? By looking closely at Pascal‚Äôs triangle above, we will find it is always 1 when j = 0 and i == j. Remember that we have to take care of empty entry. ü§î def pascal(row, column): \"\"\"returns the value of the item in pascal's triangle whose position is specified by row and column. \u003e\u003e\u003e pascal(0, 0) 1 \u003e\u003e\u003e pascal(0, 5) # empty entry; outside of pascal's triangle 0 \u003e\u003e\u003e pascal(3, 2) # row 3 (1 3 3 1), column 2 3 \u003e\u003e\u003e pascal(4, 2) # row 4 (1 4 6 4 1), column 2 6 \"\"\" # in pascal's triangle, \\ # pascal(i, j) = pascal(i - 1, j - 1) + pascal(i - 1, j) # base case 1. empty entry if column \u003e row: return 0 # base case 2. pascal(i, 0) if column == 0: return 1 # base case 3. pascal(i, i) elif row == column: return 1 return pascal(row - 1, column) + pascal(row - 1, column - 1) ","date":"2022-02-03","objectID":"/lab04-cs61a-of-ucb/:3:1","tags":["Course","Python"],"title":"Lab04 CS61A of UCB(2021-Fall)","uri":"/lab04-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q4: Insect Combinatorics Consider an insect in an M by N grid. The insect starts at the bottom left corner, (0, 0), and wants to end up at the top right corner, (M-1, N-1). The insect is only capable of moving right or up. Write a function paths that takes a grid length and width and returns the number of different paths the insect can take from the start to the goal. (There is a closed-form solution to this problem, but try to answer it procedurally using recursion.) For example, the 2 by 2 grid has a total of two ways for the insect to move from the start to the goal. For the 3 by 3 grid, the insect has 6 diferent paths (only 3 are shown above). Hint: What happens if we hit the top or rightmost edge? From the description, we know that we can only move right or up. Suppose we are in paths(i, j), we know we can only come from the left or the bottom. So we can draw a conclusion: path(i, j - 1) + path(i - 1, j). (the bottom left = (0, 0)). Then, what is the base case ?„Äç, see the table below: 1 1 1 1 1 According to the above formula, we can know that the complete table should be like this: 1 3 6 1 2 3 1 1 1 To make this problem easier, we let the index start at 1 ü§ó def paths(m, n): \"\"\"Return the number of paths from one corner of an M by N grid to the opposite corner. \u003e\u003e\u003e paths(2, 2) 2 \u003e\u003e\u003e paths(5, 7) 210 \u003e\u003e\u003e paths(117, 1) 1 \u003e\u003e\u003e paths(1, 157) 1 \"\"\" # base case path(i, 0) or path(0, i) if m == 1 or n == 1: return 1 return paths(m, n - 1) + paths(m - 1, n) ","date":"2022-02-03","objectID":"/lab04-cs61a-of-ucb/:3:2","tags":["Course","Python"],"title":"Lab04 CS61A of UCB(2021-Fall)","uri":"/lab04-cs61a-of-ucb/"},{"categories":["Course"],"content":"List Comprehensions ","date":"2022-02-03","objectID":"/lab04-cs61a-of-ucb/:4:0","tags":["Course","Python"],"title":"Lab04 CS61A of UCB(2021-Fall)","uri":"/lab04-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q5: Couple Implement the function couple, which takes in two lists and returns a list that contains lists with i-th elements of two sequences coupled together. You can assume the lengths of two sequences are the same. Try using a list comprehension. Hint: You may find the built in range function helpful. This is a simple question, because the two lists are the same length. We just need to use the same index to fetch numbers from the two lists. def couple(s, t): \"\"\"Return a list of two-element lists in which the i-th element is [s[i], t[i]]. \u003e\u003e\u003e a = [1, 2, 3] \u003e\u003e\u003e b = [4, 5, 6] \u003e\u003e\u003e couple(a, b) [[1, 4], [2, 5], [3, 6]] \u003e\u003e\u003e c = ['c', 6] \u003e\u003e\u003e d = ['s', '1'] \u003e\u003e\u003e couple(c, d) [['c', 's'], [6, '1']] \"\"\" assert len(s) == len(t) return [[s[i], t[i]] for i in range(len(s))] ","date":"2022-02-03","objectID":"/lab04-cs61a-of-ucb/:4:1","tags":["Course","Python"],"title":"Lab04 CS61A of UCB(2021-Fall)","uri":"/lab04-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q6: Coordinates Implement a function coords that takes a function fn, a sequence seq, and a lower and upper bound on the output of the function. coords then returns a list of coordinate pairs (lists) such that: Each (x, y) pair is represented as [x, fn(x)] The x-coordinates are elements in the sequence The result contains only pairs whose y-coordinate is within the upper and lower bounds (inclusive) See the doctest for examples. Note: your answer can only be one line long. You should make use of list comprehensions! We need to add an if statement to filter out the results that do not meet the conditions. def coords(fn, seq, lower, upper): \"\"\" \u003e\u003e\u003e seq = [-4, -2, 0, 1, 3] \u003e\u003e\u003e fn = lambda x: x**2 \u003e\u003e\u003e coords(fn, seq, 1, 9) [[-2, 4], [1, 1], [3, 9]] \"\"\" \"*** YOUR CODE HERE ***\" return [[i, fn(i)] for i in seq if lower \u003c= fn(i) \u003c= upper] ","date":"2022-02-03","objectID":"/lab04-cs61a-of-ucb/:4:2","tags":["Course","Python"],"title":"Lab04 CS61A of UCB(2021-Fall)","uri":"/lab04-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q7: Riffle Shuffle A common way of shuffling cards is known as the riffle shuffle. The shuffle produces a new configuration of cards in which the top card is followed by the middle card, then by the second card, then the card after the middle, and so forth. Write a list comprehension that riffle shuffles a sequence of items. You can assume the sequence contains an even number of items. Hint: There are two ways you can write this as a single list comprension: 1) You may find the expression k%2, which evaluates to 0 on even numbers and 1 on odd numbers, to be alternatively access the beginning and middle of the deck. 2) You can utilize an if expression in your comprehension for the odd and even numbers respectively. This problem will be a little more difficult. We are actually trying to find a way to get the correct index in List Comprehensions. Obviously, the situation is different when the index is odd and even. We can look at the following table to guess the rules‚¨áÔ∏è: Origin index 0 1 2 3 Real index for deck[‚Ä¶] 0 2 1 3 Guess ? (M = 2) 0 M 2 // 2 ? M + 1 = M + 3 // 2 ? odd: 0, 1, 2, ‚Ä¶ -\u003e i // 2 even: M+0, M+1, M+2, ‚Ä¶ -\u003e M + i // 2 def riffle(deck): \"\"\"Produces a single, perfect riffle shuffle of DECK, consisting of DECK[0], DECK[M], DECK[1], DECK[M+1], ... where M is position of the second half of the deck. Assume that len(DECK) is even. \u003e\u003e\u003e riffle([3, 4, 5, 6]) [3, 5, 4, 6] \u003e\u003e\u003e riffle(range(20)) [0, 10, 1, 11, 2, 12, 3, 13, 4, 14, 5, 15, 6, 16, 7, 17, 8, 18, 9, 19] \"\"\" return [deck[i // 2 + (i % 2) * (len(deck) // 2)] for i in range(len(deck))] ","date":"2022-02-03","objectID":"/lab04-cs61a-of-ucb/:4:3","tags":["Course","Python"],"title":"Lab04 CS61A of UCB(2021-Fall)","uri":"/lab04-cs61a-of-ucb/"},{"categories":["Course"],"content":"The simple solutions of hw03 of CS61A of UCB","date":"2022-01-24","objectID":"/hw03-of-cs61a-of-ucb/","tags":["Course","Python"],"title":"Hw03 of CS61A of UCB(2021-Fall)","uri":"/hw03-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"hw03. Recursion, Tree Recursion ","date":"2022-01-24","objectID":"/hw03-of-cs61a-of-ucb/:1:0","tags":["Course","Python"],"title":"Hw03 of CS61A of UCB(2021-Fall)","uri":"/hw03-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q1: Num eights Write a recursive function num_eights that takes a positive integer pos and returns the number of times the digit 8 appears in pos. Important: Use recursion; the tests will fail if you use any assignment statements. (You can however use function definitions if you so wish.) It is easy to think of the answer to this question, for we have seen a similar one in lecture. We can split the pos into all_bust_last and last. When we arrive at the base case, we just need to check if it is equals to 8. Because we can not use = in this problem, we need to use function instead. def is_single_digit(digits): return digits // 10 == 0 def is_eight(digit): return int(digit == 8) def num_eights(pos): \"\"\"Returns the number of times 8 appears as a digit of pos. \u003e\u003e\u003e num_eights(3) 0 \u003e\u003e\u003e num_eights(8) 1 \u003e\u003e\u003e num_eights(88888888) 8 \u003e\u003e\u003e num_eights(2638) 1 \u003e\u003e\u003e num_eights(86380) 2 \u003e\u003e\u003e num_eights(12345) 0 \u003e\u003e\u003e from construct_check import check \u003e\u003e\u003e # ban all assignment statements \u003e\u003e\u003e check(HW_SOURCE_FILE, 'num_eights', ... ['Assign', 'AnnAssign', 'AugAssign', 'NamedExpr']) True \"\"\" # base case: if pos is a single digit, check if it == 8 if is_single_digit(pos): return is_eight(pos) else: return is_eight(pos % 10) + num_eights(pos // 10) ","date":"2022-01-24","objectID":"/hw03-of-cs61a-of-ucb/:1:1","tags":["Course","Python"],"title":"Hw03 of CS61A of UCB(2021-Fall)","uri":"/hw03-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q2: Ping-pong The ping-pong sequence counts up starting from 1 and is always either counting up or counting down. At element k, the direction switches if k is a multiple of 8 or contains the digit 8. The first 30 elements of the ping-pong sequence are listed below, with direction swaps marked using brackets at the 8th, 16th, 18th, 24th, and 28th elements: Index 1 2 3 4 5 6 7 [8] 9 10 11 12 13 14 15 [16] 17 [18] 19 20 21 22 23 PingPong Value 1 2 3 4 5 6 7 [8] 7 6 5 4 3 2 1 [0] 1 [2] 1 0 -1 -2 -3 Index (cont.) [24] 25 26 27 [28] 29 30 PingPong Value [-4] -3 -2 -1 [0] -1 -2 Implement a function pingpong that returns the nth element of the ping-pong sequence without using any assignment statements. (You are allowed to use function definitions.) You may use the function num_eights, which you defined in the previous question. Important: Use recursion; the tests will fail if you use any assignment statements. (You can however use function definitions if you so wish.) At first, we need to define what is the base case in this problem. Let‚Äôs solve this problem from scratch. The iterative solutioin is quite easy and intuitive. We need to track these things‚¨áÔ∏è index(i), we need to count it to n. value(val), we need to keep track of this state. When we count i to n, this is the expected output. direction, this is a variable that is either equal to -1 or 1. We maintain this variable to indicate counting up or counting down. If it is a multiple of 8 or contains the digit 8, we need to change its value. def pingpong(n): i, direction = 0, 1 val = 0 while i \u003c n: val += direction i += 1 if num_eights(i) \u003e 0 or i % 8 == 0: direction = -direction return val The problem is how to convert this iterative solution to recursive solution. The parameters of this function should be these variables which changes in while loop. The next problem is: what is the base case? Apparently, the base case can be defined as index \u003c 8, then return index. Because in this range, index = value. Then, how can we know what the direction is? If we define direction(n) as the direction when the index = n, we can reason its value from direction(n-1). The base case are quite similar. Finally, the recursive solution will be like: def pingpong(n): \"\"\"Return the nth element of the ping-pong sequence. \u003e\u003e\u003e pingpong(8) 8 \u003e\u003e\u003e pingpong(10) 6 \u003e\u003e\u003e pingpong(15) 1 \u003e\u003e\u003e pingpong(21) -1 \u003e\u003e\u003e pingpong(22) -2 \u003e\u003e\u003e pingpong(30) -2 \u003e\u003e\u003e pingpong(68) 0 \u003e\u003e\u003e pingpong(69) -1 \u003e\u003e\u003e pingpong(80) 0 \u003e\u003e\u003e pingpong(81) 1 \u003e\u003e\u003e pingpong(82) 0 \u003e\u003e\u003e pingpong(100) -6 \u003e\u003e\u003e from construct_check import check \u003e\u003e\u003e # ban assignment statements \u003e\u003e\u003e check(HW_SOURCE_FILE, 'pingpong', ... ['Assign', 'AnnAssign', 'AugAssign', 'NamedExpr']) True \"\"\" def direction(n): # the base case if n \u003c 8: return 1 elif num_eights(n - 1) \u003e 0 or (n - 1) % 8 == 0: return -1 * direction(n - 1) return direction(n - 1) # the base case if n \u003c 8: return n else: return pingpong(n - 1) + direction(n) ","date":"2022-01-24","objectID":"/hw03-of-cs61a-of-ucb/:1:2","tags":["Course","Python"],"title":"Hw03 of CS61A of UCB(2021-Fall)","uri":"/hw03-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q3: Missing Digits Write the recursive function missing_digits that takes a number n that is sorted in non-decreasing order (for example, 12289 is valid but 15362 and 98764 are not). It returns the number of missing digits in n. A missing digit is a number between the first and last digit of n of a that is not in n. The solution of this problem is quite similiar to Q1: split this problem by n % 100 and n // 10. The procudure is(take 1248 for an example)‚¨áÔ∏è split 1248 into 12 and 48 check missing digits of 48 and 12 recursively. The reason why we split this problem by n % 100 and n // 10 rather than n % 10 and n // 10 is that we need to process 2 adjacent digits each time. n % 100 will give us last 2 digits. def missing_digits(n): \"\"\"Given a number a that is in sorted, non-decreasing order, return the number of missing digits in n. A missing digit is a number between the first and last digit of a that is not in n. \u003e\u003e\u003e missing_digits(1248) # 3, 5, 6, 7 4 \u003e\u003e\u003e missing_digits(19) # 2, 3, 4, 5, 6, 7, 8 7 \u003e\u003e\u003e missing_digits(1122) # No missing numbers 0 \u003e\u003e\u003e missing_digits(123456) # No missing numbers 0 \u003e\u003e\u003e missing_digits(3558) # 4, 6, 7 3 \u003e\u003e\u003e missing_digits(35578) # 4, 6 2 \u003e\u003e\u003e missing_digits(12456) # 3 1 \u003e\u003e\u003e missing_digits(16789) # 2, 3, 4, 5 4 \u003e\u003e\u003e missing_digits(4) # No missing numbers between 4 and 4 0 \u003e\u003e\u003e from construct_check import check \u003e\u003e\u003e # ban while or for loops \u003e\u003e\u003e check(HW_SOURCE_FILE, 'missing_digits', ['While', 'For']) True \"\"\" if n \u003c 10: return 0 elif n \u003c 100: if n // 10 == n % 10: return 0 else: return n % 10 - n // 10 - 1 return missing_digits(n // 10) + missing_digits(n % 100) ","date":"2022-01-24","objectID":"/hw03-of-cs61a-of-ucb/:1:3","tags":["Course","Python"],"title":"Hw03 of CS61A of UCB(2021-Fall)","uri":"/hw03-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q4: Count coins Given a positive integer change, a set of coins makes change for change if the sum of the values of the coins is change. Here we will use standard US Coin values: 1, 5, 10, 25. For example, the following sets make change for 15: 15 1-cent coins 10 1-cent, 1 5-cent coins 5 1-cent, 2 5-cent coins 5 1-cent, 1 10-cent coins 3 5-cent coins 1 5-cent, 1 10-cent coin Thus, there are 6 ways to make change for 15. Write a recursive function count_coins that takes a positive integer change and returns the number of ways to make change for change using coins. You can use either of the functions given to you: ascending_coin will return the next larger coin denomination from the input, i.e. ascending_coin(5) is 10. descending_coin will return the next smaller coin denomination from the input, i.e. descending_coin(5) is 1. There are two main ways in which you can approach this problem. One way uses ascending_coin, and another uses descending_coin. Important: Use recursion; the tests will fail if you use loops. Hint: Refer the implementation of count_partitions for an example of how to count the ways to sum up to a final value with smaller parts. If you need to keep track of more than one value across recursive calls, consider writing a helper function. Similiar to this implementation, we can slove this problem use tree-recursive function. For every coin value, we can pick or drop. So we can write code like this‚¨áÔ∏è def count_coins(change): \"\"\"Return the number of ways to make change using coins of value of 1, 5, 10, 25. \u003e\u003e\u003e count_coins(15) 6 \u003e\u003e\u003e count_coins(10) 4 \u003e\u003e\u003e count_coins(20) 9 \u003e\u003e\u003e count_coins(100) # How many ways to make change for a dollar? 242 \u003e\u003e\u003e count_coins(200) 1463 \u003e\u003e\u003e from construct_check import check \u003e\u003e\u003e # ban iteration \u003e\u003e\u003e check(HW_SOURCE_FILE, 'count_coins', ['While', 'For']) True \"\"\" def helper(coin, n): if not coin: return 0 if coin == n: # 1 coin for n return 1 if coin \u003e n: # the coin value is too large return 0 pickcoin = helper(coin, n - coin) dropcoin = helper(ascending_coin(coin), n) return pickcoin + dropcoin return helper(1, change) ","date":"2022-01-24","objectID":"/hw03-of-cs61a-of-ucb/:1:4","tags":["Course","Python"],"title":"Hw03 of CS61A of UCB(2021-Fall)","uri":"/hw03-of-cs61a-of-ucb/"},{"categories":["Tool"],"content":"Explain how to use hammerspoon to manage windows","date":"2022-01-21","objectID":"/how-to-manage-windows-using-hammerspoon/","tags":["Tool"],"title":"How to Manage Windows Using Hammerspoon","uri":"/how-to-manage-windows-using-hammerspoon/"},{"categories":["Tool"],"content":"Intro I found that the windows management built in macOS is difficult to use. As a result, I always using my mouse to move and resize my window, which is less efficient. We should keep our hands on the keyboard as much as possible. After finishing the MIT-Missing-Semester, I came across the hammerspoon tool. I really like this one :) ","date":"2022-01-21","objectID":"/how-to-manage-windows-using-hammerspoon/:1:0","tags":["Tool"],"title":"How to Manage Windows Using Hammerspoon","uri":"/how-to-manage-windows-using-hammerspoon/"},{"categories":["Tool"],"content":"What is hammerspoon ? According to the official site‚Äôs introduction, hammerspoon is a tool for powerful automation of OS X, which is just a bridge between the operating system and a Lua scripting engine. The windows management is kind of automation. To be honest, I once heard the Lua language but I don‚Äôt know anything about it. I follow Learn Lua in Y minutes to have a basic understanding of this language. ","date":"2022-01-21","objectID":"/how-to-manage-windows-using-hammerspoon/:2:0","tags":["Tool"],"title":"How to Manage Windows Using Hammerspoon","uri":"/how-to-manage-windows-using-hammerspoon/"},{"categories":["Tool"],"content":"How to manage windows ? I would like to have the following features: Move and resize my window to the left/right of screen. The full screen mode Move and resize my window to the top-left/top-right/bottom-left/bottom-right of screen Move current window to the center of screen My solution consists of 3 *.lua file(I have put this in my dotfiles) üëâconfig.lua MACBOOK_MONITOR = 'Built-in Retina Display' -- disable animations, default value = 0.2 hs.window.animationDuration = 0 üëâinit.lua require('config') require('window') üëâwindow.lua This is the main part of windows management. -- half of screen -- {frame.x, frame.y, window.w, window.h} -- First two elements: we decide the position of frame -- Last two elements: we decide the size of frame hs.hotkey.bind({'alt', 'cmd'}, 'left', function() hs.window.focusedWindow():moveToUnit({0, 0, 0.5, 1}) end) hs.hotkey.bind({'alt', 'cmd'}, 'right', function() hs.window.focusedWindow():moveToUnit({0.5, 0, 0.5, 1}) end) hs.hotkey.bind({'alt', 'cmd'}, 'up', function() hs.window.focusedWindow():moveToUnit({0, 0, 1, 0.5}) end) hs.hotkey.bind({'alt', 'cmd'}, 'down', function() hs.window.focusedWindow():moveToUnit({0, 0.5, 1, 0.5}) end) -- quarter of screen --[[ u i j k --]] hs.hotkey.bind({'ctrl', 'alt', 'cmd'}, 'u', function() hs.window.focusedWindow():moveToUnit({0, 0, 0.5, 0.5}) end) hs.hotkey.bind({'ctrl', 'alt', 'cmd'}, 'k', function() hs.window.focusedWindow():moveToUnit({0.5, 0.5, 0.5, 0.5}) end) hs.hotkey.bind({'ctrl', 'alt', 'cmd'}, 'i', function() hs.window.focusedWindow():moveToUnit({0.5, 0, 0.5, 0.5}) end) hs.hotkey.bind({'ctrl', 'alt', 'cmd'}, 'j', function() hs.window.focusedWindow():moveToUnit({0, 0.5, 0.5, 0.5}) end) -- full screen hs.hotkey.bind({'alt', 'cmd'}, 'f', function() hs.window.focusedWindow():moveToUnit({0, 0, 1, 1}) end) -- center screen hs.hotkey.bind({'alt', 'cmd'}, 'c', function() hs.window.focusedWindow():centerOnScreen() end) You shoule put these files in ~/.hammerspoon/ and then click on Reload config ü§ó ","date":"2022-01-21","objectID":"/how-to-manage-windows-using-hammerspoon/:3:0","tags":["Tool"],"title":"How to Manage Windows Using Hammerspoon","uri":"/how-to-manage-windows-using-hammerspoon/"},{"categories":["Tool"],"content":"Code Explained hs.hotkey.bind(mods, key, pressedfn) This is a simple function to create a new hotkey and bind it to pressedfn. We press and hold mods and use key to enable pressedfn. For example, If we want to make a window full screen. We first press and hold alt(option) and cmd, then we press f. pressedfn This is an anonymous function in Lua. The key of this function is hs.window.focusedWindow():moveToUnit({...}). Its job is get the focused window and make some changes of position and size. The parameters are a table in Lua. You may combine the previous comments in window.lua and the image below to understand this. ","date":"2022-01-21","objectID":"/how-to-manage-windows-using-hammerspoon/:4:0","tags":["Tool"],"title":"How to Manage Windows Using Hammerspoon","uri":"/how-to-manage-windows-using-hammerspoon/"},{"categories":["Tool"],"content":"Ref Anish‚Äôs Hammerspoon config ","date":"2022-01-21","objectID":"/how-to-manage-windows-using-hammerspoon/:5:0","tags":["Tool"],"title":"How to Manage Windows Using Hammerspoon","uri":"/how-to-manage-windows-using-hammerspoon/"},{"categories":["Course"],"content":"The simple solutions of hw02 of CS61A of UCB","date":"2022-01-20","objectID":"/hw02-of-cs61a-of-ucb/","tags":["Course","Python"],"title":"Hw02 of CS61A of UCB(2021-Fall)","uri":"/hw02-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"hw02. Higher Order Functions ","date":"2022-01-20","objectID":"/hw02-of-cs61a-of-ucb/:1:0","tags":["Course","Python"],"title":"Hw02 of CS61A of UCB(2021-Fall)","uri":"/hw02-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q1: Product The summation(n, term) function from the higher-order functions lecture adds up term(1) + ... + term(n). Write a similar function called product that returns term(1) * ... * term(n). This problem is quite easy, we just need to use * instead of +. The logic is similar to summation(n, term) function in the lecture. Remember to set ans = 1 at first, after all, 0 * any numbers is always equal to 0 ü§ó def product(n, term): \"\"\"Return the product of the first n terms in a sequence. n: a positive integer term: a function that takes one argument to produce the term \u003e\u003e\u003e product(3, identity) # 1 * 2 * 3 6 \u003e\u003e\u003e product(5, identity) # 1 * 2 * 3 * 4 * 5 120 \u003e\u003e\u003e product(3, square) # 1^2 * 2^2 * 3^2 36 \u003e\u003e\u003e product(5, square) # 1^2 * 2^2 * 3^2 * 4^2 * 5^2 14400 \u003e\u003e\u003e product(3, increment) # (1+1) * (2+1) * (3+1) 24 \u003e\u003e\u003e product(3, triple) # 1*3 * 2*3 * 3*3 162 \"\"\" i, ans = 1, 1 while i \u003c= n: ans *= term(i) i += 1 return ans ","date":"2022-01-20","objectID":"/hw02-of-cs61a-of-ucb/:1:1","tags":["Course","Python"],"title":"Hw02 of CS61A of UCB(2021-Fall)","uri":"/hw02-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q2: Accumulate Let‚Äôs take a look at how summation and product are instances of a more general function called accumulate, which we would like to implement: If you compare the code mentioned above with the following code, you may find that they are quite similar. The accumulate is a generalized version of prodcut def accumulate(merger, base, n, term): \"\"\"Return the result of merging the first n terms in a sequence and base. The terms to be merged are term(1), term(2), ..., term(n). merger is a two-argument commutative function. \u003e\u003e\u003e accumulate(add, 0, 5, identity) # 0 + 1 + 2 + 3 + 4 + 5 15 \u003e\u003e\u003e accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5 26 \u003e\u003e\u003e accumulate(add, 11, 0, identity) # 11 11 \u003e\u003e\u003e accumulate(add, 11, 3, square) # 11 + 1^2 + 2^2 + 3^2 25 \u003e\u003e\u003e accumulate(mul, 2, 3, square) # 2 * 1^2 * 2^2 * 3^2 72 \u003e\u003e\u003e # 2 + (1^2 + 1) + (2^2 + 1) + (3^2 + 1) \u003e\u003e\u003e accumulate(lambda x, y: x + y + 1, 2, 3, square) 19 \u003e\u003e\u003e # ((2 * 1^2 * 2) * 2^2 * 2) * 3^2 * 2 \u003e\u003e\u003e accumulate(lambda x, y: 2 * x * y, 2, 3, square) 576 \u003e\u003e\u003e accumulate(lambda x, y: (x + y) % 17, 19, 20, square) 16 \"\"\" i, ans = 1, base while i \u003c= n: ans = merger(ans, term(i)) i += 1 return ans def summation_using_accumulate(n, term): \"\"\"Returns the sum: term(1) + ... + term(n), using accumulate. \u003e\u003e\u003e summation_using_accumulate(5, square) 55 \u003e\u003e\u003e summation_using_accumulate(5, triple) 45 \"\"\" return accumulate(add, 0, n, term) def product_using_accumulate(n, term): \"\"\"Returns the product: term(1) * ... * term(n), using accumulate. \u003e\u003e\u003e product_using_accumulate(4, square) 576 \u003e\u003e\u003e product_using_accumulate(6, triple) 524880 \"\"\" return accumulate(mul, 1, n, term) ","date":"2022-01-20","objectID":"/hw02-of-cs61a-of-ucb/:1:2","tags":["Course","Python"],"title":"Hw02 of CS61A of UCB(2021-Fall)","uri":"/hw02-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"The simple solutions of hw01 of CS61A of UCB","date":"2022-01-18","objectID":"/hw01-of-cs61a-of-ucb/","tags":["Course","Python"],"title":"Hw01 of CS61A of UCB(2021-Fall)","uri":"/hw01-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"hw01. Control ","date":"2022-01-18","objectID":"/hw01-of-cs61a-of-ucb/:1:0","tags":["Course","Python"],"title":"Hw01 of CS61A of UCB(2021-Fall)","uri":"/hw01-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q1. Welcome Forms Skip :) ","date":"2022-01-18","objectID":"/hw01-of-cs61a-of-ucb/:1:1","tags":["Course","Python"],"title":"Hw01 of CS61A of UCB(2021-Fall)","uri":"/hw01-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q2. A Plus Abs B Fill in the blanks in the following function for adding a to the absolute value of b, without calling abs. You may not modify any of the provided code other than the two blanks. This problem is easy if we know that we can bind names to functions. In this problem: When b \u003c 0, a + abs(b) = a - b, so we should use sub When b \u003e 0, a + abs(b) = a + b, so we should use add def a_plus_abs_b(a, b): \"\"\"Return a+abs(b), but without calling abs. \u003e\u003e\u003e a_plus_abs_b(2, 3) 5 \u003e\u003e\u003e a_plus_abs_b(2, -3) 5 \"\"\" if b \u003c 0: f = sub # b \u003c 0 -\u003e a+abs(b) = a - b, using sub else: f = add # b \u003e 0 -\u003e a+abs(b) = a + b, using add return f(a, b) ","date":"2022-01-18","objectID":"/hw01-of-cs61a-of-ucb/:1:2","tags":["Course","Python"],"title":"Hw01 of CS61A of UCB(2021-Fall)","uri":"/hw01-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q3. Two of Three Write a function that takes three positive numbers as arguments and returns the sum of the squares of the two smallest numbers. Use only a single line for the body of the function. The hint shows that we may need max or min in this problem. At first, I tried to enumerate all possibilities. The smallest numbers may be x and y, or x and z, or y and z. We can just code like this: return min(x**2 + y**2, x**2 + z**2, y**2 + z**2). We can also think about the problem from another angle ‚¨áÔ∏è def two_of_three(x, y, z): \"\"\"Return a*a + b*b, where a and b are the two smallest members of the positive numbers x, y, and z. \u003e\u003e\u003e two_of_three(1, 2, 3) 5 \u003e\u003e\u003e two_of_three(5, 3, 1) 10 \u003e\u003e\u003e two_of_three(10, 2, 8) 68 \u003e\u003e\u003e two_of_three(5, 5, 5) 50 \"\"\" # by substracting largest-number * largest-number return x**2 + y**2 + z**2 - max(x, y, z)**2 ","date":"2022-01-18","objectID":"/hw01-of-cs61a-of-ucb/:1:3","tags":["Course","Python"],"title":"Hw01 of CS61A of UCB(2021-Fall)","uri":"/hw01-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q4. Largest Factor Write a function that takes an integer n that is greater than 1 and returns the largest integer that is smaller than n and evenly divides n. With some basic knowledge of math, we can decompose this problem into two cases if n is an even number, the answer is n // 2 if n is an odd number, the answer can be found by check n % factor == 0. the range of factor is 1 ~ n // 2 def largest_factor(n): \"\"\"Return the largest factor of n that is smaller than n. \u003e\u003e\u003e largest_factor(15) # factors are 1, 3, 5 5 \u003e\u003e\u003e largest_factor(80) # factors are 1, 2, 4, 5, 8, 10, 16, 20, 40 40 \u003e\u003e\u003e largest_factor(13) # factor is 1 since 13 is prime 1 \"\"\" if n % 2 == 0: return n // 2 else: factors = [i for i in range(n//2, 0, -1) if n % i == 0] # get all factors return factors[0] # the biggest one is the largest one ","date":"2022-01-18","objectID":"/hw01-of-cs61a-of-ucb/:1:4","tags":["Course","Python"],"title":"Hw01 of CS61A of UCB(2021-Fall)","uri":"/hw01-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q5. If Function Refactor In this problem, we should refactor out code to avoid ZeroDivisionError The ZeroDivisionError happens when we call function expression. Python will try to evaluate the whole expression recursively. Although the hw01 says Your second job is to edit invert_short and change_short so that they have the same behavior as invert and change but still have just one line each. You will also need to edit limited. You don‚Äôt need to use and or or orif in invert; just pay attention to when the division takes place., I tried to solve this problem without editing limited functio and use if üòø def limited(x, z, limit): \"\"\"Logic that is common to invert and change.\"\"\" if x != 0: return min(z, limit) else: return limit def invert_short(x, limit): \"\"\"Return 1/x, but with a limit. \u003e\u003e\u003e x = 0.2 \u003e\u003e\u003e 1/x 5.0 \u003e\u003e\u003e invert_short(x, 100) 5.0 \u003e\u003e\u003e invert_short(x, 2) # 2 is smaller than 5 2 \u003e\u003e\u003e x = 0 \u003e\u003e\u003e invert_short(x, 100) # No error, even though 1/x divides by 0! 100 \"\"\" # the ZeroDivisionError happens here when we call limited function return limited(x, 1 / x, limit) if x != 0 else limited(x, 0, limit) def change_short(x, y, limit): \"\"\"Return abs(y - x) as a fraction of x, but with a limit. \u003e\u003e\u003e x, y = 2, 5 \u003e\u003e\u003e abs(y - x) / x 1.5 \u003e\u003e\u003e change_short(x, y, 100) 1.5 \u003e\u003e\u003e change_short(x, y, 1) # 1 is smaller than 1.5 1 \u003e\u003e\u003e x = 0 \u003e\u003e\u003e change_short(x, y, 100) # No error, even though abs(y - x) / x divides by 0! 100 \"\"\" # the ZeroDivisionError happens here when we call limited function return limited(x, abs(y - x) / x, limit) if x != 0 else limited(x, 0, limit) ","date":"2022-01-18","objectID":"/hw01-of-cs61a-of-ucb/:1:5","tags":["Course","Python"],"title":"Hw01 of CS61A of UCB(2021-Fall)","uri":"/hw01-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"Q6.Hailstone Douglas Hofstadter‚Äôs Pulitzer-prize-winning book, G√∂del, Escher, Bach, poses the following mathematical puzzle. Pick a positive integer n as the start. If n is even, divide it by 2. If n is odd, multiply it by 3 and add 1. Continue this process until n is 1. The number n will travel up and down but eventually end at 1 (at least for all numbers that have ever been tried ‚Äì nobody has ever proved that the sequence will terminate). Analogously, a hailstone travels up and down in the atmosphere before eventually landing on earth. This sequence of values of n is often called a Hailstone sequence. Write a function that takes a single argument with formal parameter name n, prints out the hailstone sequence starting at n, and returns the number of steps in the sequence: This problem is easy. We just follow the 4 steps and count. def hailstone(n): \"\"\"Print the hailstone sequence starting at n and return its length. \u003e\u003e\u003e a = hailstone(10) 10 5 16 8 4 2 1 \u003e\u003e\u003e a 7 \"\"\" cnt = 0 while n != 1: print(n) if n % 2 == 0: n //= 2 else: n = n * 3 + 1 cnt += 1 print(n) # print 1 return cnt + 1 # +1 for `n=1` ","date":"2022-01-18","objectID":"/hw01-of-cs61a-of-ucb/:1:6","tags":["Course","Python"],"title":"Hw01 of CS61A of UCB(2021-Fall)","uri":"/hw01-of-cs61a-of-ucb/"},{"categories":["Course"],"content":"the simple solutions for exercise09 of Missingsemester 2020","date":"2022-01-10","objectID":"/exercise09-missingsemester-2020/","tags":["Course"],"title":"the solutions for exercise09 of Missingsemester(2020)","uri":"/exercise09-missingsemester-2020/"},{"categories":["Course"],"content":"Lecture 09. Security and Cryptography ","date":"2022-01-10","objectID":"/exercise09-missingsemester-2020/:1:0","tags":["Course"],"title":"the solutions for exercise09 of Missingsemester(2020)","uri":"/exercise09-missingsemester-2020/"},{"categories":["Course"],"content":"Entropy Suppose a password is chosen as a concatenation of four lower-case dictionary words, where each word is selected uniformly at random from a dictionary of size 100,000. An example of such a password is correcthorsebatterystaple. How many bits of entropy does this have? In order to calculate the bits of entropy, we need to know how many possibilites there. We can easily know the combinations count are $100000^4$ and the bits of entropy are $log_2 (100000^4)\\approx 66\\ bit$ ü§ó Consider an alternative scheme where a password is chosen as a sequence of 8 random alphanumeric characters (including both lower-case and upper-case letters). An example is rg8Ql34g. How many bits of entropy does this have? We can calcaulte the bits of entropy are $log_2(62^8)\\approx 47\\ bit$ ü§ó Which is the stronger password? Apprarenty, correcthorsebatterystaple is the stronger one(its entropy is higher), which is kind of counter-intuitive. From a human perspective, rg8Ql34g is harder to memorize ü§î. Suppose an attacker can try guessing 10,000 passwords per second. On average, how long will it take to break each of the passwords? correcthorsebatterystaple: $100000^4/10000=10^{16}\\ seconds\\approx317097919\\ years$ ü§ß rg8Ql34g: $64^8/10000\\approx892\\ years$ ","date":"2022-01-10","objectID":"/exercise09-missingsemester-2020/:1:1","tags":["Course"],"title":"the solutions for exercise09 of Missingsemester(2020)","uri":"/exercise09-missingsemester-2020/"},{"categories":["Course"],"content":"Cryptographic hash functions Download a Debian image from a mirror(e.g. from this Argentinean mirror). Cross-check the hash (e.g. using the sha256sum command) with the hash retrieved from the official Debian site (e.g. this file hosted at debian.org, if you‚Äôve downloaded the linked file from the Argentinean mirror). \u003e shasum -a -256 debian-mac-11.2.0-amd64-netinst.iso # 011f6754601985f46fcc670ce02faabcc8b5b8aadf51bc3d3fcfa3185b96b1df debian-mac-11.2.0-amd64-netinst.iso # correct one # 011f6754601985f46fcc670ce02faabcc8b5b8aadf51bc3d3fcfa3185b96b1df debian-mac-11.2.0-amd64-netinst.iso # you can check them manually, or you do something like this \u003e diff \u003c(shasum -a 256 debian-mac-11.2.0-amd64-netinst.iso) \u003c(echo \"011f6754601985f46fcc670ce02faabcc8b5b8aadf51bc3d3fcfa3185b96b1df debian-mac-11.2.0-amd64-netinst.iso\") ","date":"2022-01-10","objectID":"/exercise09-missingsemester-2020/:1:2","tags":["Course"],"title":"the solutions for exercise09 of Missingsemester(2020)","uri":"/exercise09-missingsemester-2020/"},{"categories":["Course"],"content":"Symmetric cryptography Encrypt a file with AES encryption, usingOpenSSL: openssl aes-256-cbc -salt -in {input filename} -out {output filename}. Look at the contents using cat or hexdump. Decrypt it with openssl aes-256-cbc -d -in {input filename} -out {output filename} and confirm that the contents match the original using cmp \u003e echo \"Hello world\" \u003e\u003e sample.txt \u003e openssl aes-256-cbc -salt -in sample.txt -out sample.enc.txt # I use `password` as my password \u003e cat sample.enc.txt # Salted__nÔøΩÔøΩsiZÔøΩ\u003eo;w\u003eÔøΩÔøΩÔøΩÔøΩkÔøΩÔøΩ.% \u003e openssl aes-256-cbc -d --in sample.enc.txt --out recover.txt # Enter `password` \u003e cmp sample.txt recover.txt Set up SSH keys on a computer you have access to (not Athena, because Kerberos interacts weirdly with SSH keys). Make sure your private key is encrypted with a passphrase, so it is protected at rest. Set up GPG Send Anish an encrypted email (public key). Sign a Git commit with git commit -S or create a signed Git tag withgit tag -s. Verify the signature on the commit with git show --show-signature or on the tag with git tag -v. I have tried this. Skip :) Skip :) Skip :) ","date":"2022-01-10","objectID":"/exercise09-missingsemester-2020/:1:3","tags":["Course"],"title":"the solutions for exercise09 of Missingsemester(2020)","uri":"/exercise09-missingsemester-2020/"},{"categories":["Course"],"content":"the simple solutions for exercise08 of Missingsemester 2020","date":"2022-01-08","objectID":"/exercise08-missingsemester-2020/","tags":["Course","Makefile","Git"],"title":"the solutions for exercise08 of Missingsemester(2020)","uri":"/exercise08-missingsemester-2020/"},{"categories":["Course"],"content":"Lecture 08. Metaprogramming Most makefiles provide a target called clean. This isn‚Äôt intended to produce a file called clean, but instead to clean up any files that can be re-built by make. Think of it as a way to ‚Äúundo‚Äù all of the build steps. Implement a clean target for the paper.pdf Makefile above. You will have to make the target phony. You may find the git ls-filessubcommand useful. A number of other very common make targets are listed here. If you check the files in the folder after we run make, you will find that the new files are paper.aux, paper.log, paper.pdf and paper.png. These files are what we want to clean. In order to do this, we can modify Makefile like this ‚¨áÔ∏è paper.pdf: paper.tex plot-data.png pdflatex paper.tex plot-%.png: %.dat plot.py ./plot.py -i $*.dat -o $@ .PHONY: clean cleanall: cleanaux cleanlog cleanpdf cleanpng cleanaux: rm *.aux cleanlog: rm *.log cleanpdf: rm *.pdf cleanpng: rm *.png Take a look at the various ways to specify version requirements for dependencies in Rust‚Äôs build system. Most package repositories support similar syntax. For each one (caret, tilde, wildcard, comparison, and multiple), try to come up with a use-case in which that particular kind of requirement makes sense. Caret requirements: It is used to update minor version and patch version. Tilde requirements: It is used to match the most recent patch version by freezing major version and minor version. Wildcard requirements: It is used to specify major version and accept any minor version and patch version. Both of comparison requirements and multiple requirements are used to give more control over packages. We may used them to overcome conflicts. Git can act as a simple CI system all by itself. In .git/hooks inside any git repository, you will find (currently inactive) files that are run as scripts when a particular action happens. Write a pre-commit hook that runs make paper.pdf and refuses the commit if the make command fails. This should prevent any commit from having an unbuildable version of the paper. After reading this tutorial above, You will find how git hooks work. So the solution will be ‚¨áÔ∏è Write a pre-commit hook in whatever languages you like. Here is my scipt. #!/usr/bin/env bash if ! make paper.pdf; then echo \"==\u003e Running make command fail :(\" exit 1 else echo \"==\u003e Running make command successfully :)\" exit 0 fi Change the file mode of hook you just wrote, make it executable. Type chmod u+x pre-commit in your terminal. mv the hook to .git/hooks. Type mv pre-commit .git/hooks/pre-commit Now it time to test if your hook works as you expected ü§ó ‚¨áÔ∏è \u003e git add . \u003e git commit -m \"Try to commit\" Set up a simple auto-published page using GitHub Pages. Add a GitHub Action to the repository to run shellcheck on any shell files in that repository (here is one way to do it). Check that it works! This blog is host by Github Pagesü§ó First, create a yml file in your .github/workflows/. My yml file looks like: on: [push] name: 'Trigger: Push action' jobs: shellcheck: name: Shellcheck runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Run ShellCheck uses: ludeeus/action-shellcheck@master git add \u0026\u0026 git commit -m \"\" \u0026\u0026 git push. Add your workflow to your remote repo. Now we can create a simple .sh file. I deliberately didn‚Äôt add shebang in sh file. date If you run shellcheck in your local machine, you should get a warning says: SC2148 (error): Tips depend on target shell and yours is unknown. Add a shebang or a 'shell' directive. git add \u0026\u0026 git commit -m \"\" \u0026\u0026 git push. Check if your workflow works by clicking Actions in your repo. You will see it didn‚Äôt pass the test. The output is: Run ludeeus/action-shellcheck@master Run problem_matcher_file=\"/home/runner/work/_actions/ludeeus/action-shellcheck/master/.github/problem-matcher-gcc.json\" Run if [[ \"Linux\" == \"macOS\" ]]; then Run \"/home/runner/work/_actions/ludeeus/action-shellcheck/master/shellcheck\" --version ShellCheck - shell script analysis tool version: 0.8.0","date":"2022-01-08","objectID":"/exercise08-missingsemester-2020/:1:0","tags":["Course","Makefile","Git"],"title":"the solutions for exercise08 of Missingsemester(2020)","uri":"/exercise08-missingsemester-2020/"},{"categories":["Python"],"content":"A simple guide to use logging module in python","date":"2022-01-07","objectID":"/how-to-use-logging-in-python/","tags":["Python","Logging"],"title":"How to Use Logging in Python","uri":"/how-to-use-logging-in-python/"},{"categories":["Python"],"content":"Intro Recently I was fine-tuning my deep learning model, and I habitually started to use print to print some key information on the terminal. So my workflow is like: I type some hyperparameters to train my model. I manually opened an Excel to record the hyperparameters used and the model evaluation results. And I will go back to step 1. If I am not satisfied with results. Soon, I became bored with this workflow (In fact, I kept this for quite a long time.). However, I suddenly forgot to record key information manually. As a result, I had to navigate in the history output of the the terminal slowly. At this time, I think I should use logging. I don‚Äôt want to tortue myself anymoreüôÖ‚Äç‚ôÇÔ∏è. That‚Äôs why I wrote this blog postü§ó ","date":"2022-01-07","objectID":"/how-to-use-logging-in-python/:1:0","tags":["Python","Logging"],"title":"How to Use Logging in Python","uri":"/how-to-use-logging-in-python/"},{"categories":["Python"],"content":"Basic ","date":"2022-01-07","objectID":"/how-to-use-logging-in-python/:2:0","tags":["Python","Logging"],"title":"How to Use Logging in Python","uri":"/how-to-use-logging-in-python/"},{"categories":["Python"],"content":"logger level DEBUG When you want to debug your python file INFO Make sure everything goes as expected WARNING Something unexpected happened. It may cause some problems in the future ERROR Some function may fail CRITICAL The program may stop running The 5 levels actually mean different severity. By default, tbe logging module will only record WARNING level or above(ERROR + CRITICAL) ","date":"2022-01-07","objectID":"/how-to-use-logging-in-python/:2:1","tags":["Python","Logging"],"title":"How to Use Logging in Python","uri":"/how-to-use-logging-in-python/"},{"categories":["Python"],"content":"Best Practice ","date":"2022-01-07","objectID":"/how-to-use-logging-in-python/:3:0","tags":["Python","Logging"],"title":"How to Use Logging in Python","uri":"/how-to-use-logging-in-python/"},{"categories":["Python"],"content":"Step 1. Import logging module and define your customized logger Of course, you can use the default logger without configurations. See a qucik example ‚¨áÔ∏è import logging logging.warning(\"WARNING!!!\") # output # WARNING:root:WARNING!!! How to customized your logger Use logging.basicConfig(args). The logging module provides us some args to customize our own logger. For example: filename: the logfile filename level: it decides what type of level(or above)‚Äôs messages will be recorded format: the format of message filemode: By default, it is equal to a, which means append import logging logging.basicConfig(level=logging.INFO) logging.info(\"Everything is ok\") # output # INFO:root:Everything is ok ","date":"2022-01-07","objectID":"/how-to-use-logging-in-python/:3:1","tags":["Python","Logging"],"title":"How to Use Logging in Python","uri":"/how-to-use-logging-in-python/"},{"categories":["Python"],"content":"Step 2. Start logging messages You can logging whatever messages you like. The logging module provide us some LogRecord attributes. For example: %(asctime)s: Human-readable time %(levelname)s: Indicating the logginglevel %(message)s: logged message Usually, we will use these LogRecord attributes in aforementioned format arg. For example‚¨áÔ∏è import logging logging.basicConfig(level=logging.INFO, format=\"%(asctime)s ==\u003e %(message)s\") logging.info(\"Everything is ok\") # output # 2022-01-08 00:32:11,579 ==\u003e Everything is ok ","date":"2022-01-07","objectID":"/how-to-use-logging-in-python/:3:2","tags":["Python","Logging"],"title":"How to Use Logging in Python","uri":"/how-to-use-logging-in-python/"},{"categories":["Python"],"content":"Advanced The previous article talks about how to debug in python. In fact, learning to use logging is also a powerful way to help debugging. For example, we can use logging to record the report when the program crashed. See a simple example‚¨áÔ∏è import logging try: print(4 // 0) except Exception as e: logging.error(\"===\u003e Exception detected\", exc_info=True) # output: # ERROR:root:===\u003e Exception detected # Traceback (most recent call last): # File \"hello.py\", line 4, in \u003cmodule\u003e # print(4 // 0) # ZeroDivisionError: integer division or modulo by zero ","date":"2022-01-07","objectID":"/how-to-use-logging-in-python/:4:0","tags":["Python","Logging"],"title":"How to Use Logging in Python","uri":"/how-to-use-logging-in-python/"},{"categories":["Python"],"content":"Refs logging HOWTO logging docs ","date":"2022-01-07","objectID":"/how-to-use-logging-in-python/:5:0","tags":["Python","Logging"],"title":"How to Use Logging in Python","uri":"/how-to-use-logging-in-python/"},{"categories":["Course"],"content":"the simple solutions for exercise07 of Missingsemester 2020","date":"2022-01-03","objectID":"/exercise07-missingsemester-2020/","tags":["Course","Profiling"],"title":"the solutions for exercise07 of Missingsemester(2020)","uri":"/exercise07-missingsemester-2020/"},{"categories":["Course"],"content":"debugging Use journalctl on Linux or log show on macOS to get the super user accesses and commands in the last day. If there aren‚Äôt any you can execute some harmless commands such as sudo ls and check again. When I run log show --last 1d, it keeps running for along time. I don‚Äôt know how long it make take, so I will just execute harmless sudo ls to check the log. \u003e sudo ls \u003e log show --last 10s | grep -E \"sudo\" # you should see the last line of output says # you once run ls in super user access Do this hands on pdb tutorial to familiarize yourself with the commands. For a more in depth tutorial read this. I have finished this tutorial. Actually, I fork this repo and add chinese translation. Install shellcheck and try checking the following script. What is wrong with the code? Fix it. Install a linter plugin in your editor so you can get your warnings automatically. #!/bin/sh ## Example: a typical script with several problems for f in $(ls *.m3u) do grep -qi hq.*mp3 $f \\ \u0026\u0026 echo -e 'Playlist $f contains a HQ file in mp3 format' done ERROR SC2045. In line 3, it says Iterating over ls output is fragile. Use globs. WARNINGS SC2062. In line 5, it says Quote the grep pattern so the shell won‚Äôt interpret it. SC3037. In line 6, it says In POSIX sh, echo flags are undefined. I think we can use bash instead of sh INFO SC2016. In line 6, it says Expressions don‚Äôt expand in single quotes, use double quotes for that. SC2086. In line 5, it says Double quote to prevent globbing and word splitting. SC3010. After following the guide of SC2045, I added a line([[ -e $f ]] || break) below do. SC3010 says In POSIX sh, [ ] is undefined. Then I change shebang to #!/bin/bash So the final version of sh file is ‚¨áÔ∏è #!/bin/bash ## Example: a typical script with several problems for f in *.m3u do [[ -e \"$f\" ]] || break # handle the case of no *.m3u files grep -qi \"hq.*mp3\" \"$f\" \\ \u0026\u0026 echo -e \"Playlist $f contains a HQ file in mp3 format\" done (Advanced) Read about reversible debugging and get a simple example working using rr or RevPDB. PASS :) ","date":"2022-01-03","objectID":"/exercise07-missingsemester-2020/:0:1","tags":["Course","Profiling"],"title":"the solutions for exercise07 of Missingsemester(2020)","uri":"/exercise07-missingsemester-2020/"},{"categories":["Course"],"content":"Profiling Here are some sorting algorithm implementations. Use cProfile and line_profiler to compare the runtime of insertion sort and quicksort. What is the bottleneck of each algorithm? Use then memory_profiler to check the memory consumption, why is insertion sort better? Check now the inplace version of quicksort. Challenge: Use perf to look at the cycle counts and cache hits and misses of each algorithm. ü§îWe can type python -m cProfile -s tottime sorts.py 1000 in the terminal to get the runtime of insertion sort and quicksort. 1000 means that we will run this sorts.py 1000 times. Check documentations for more details. ncalls tottime percall cumtime percall filename:lineno(function) ... 1000 0.045 0.000 0.045 0.000 sorts.py:12(insertionsort) 33218/1000 0.044 0.000 0.068 0.000 sorts.py:25(quicksort) ... ü§îIf you want to use line_profiler to compare the runtime of insertion sort and quicksort, you need to add @profile decorator above insertion sort and quicksort(You should install line_profiler fist by pip install line_profiler). The code will be like ‚¨áÔ∏è @profile def insertionsort(array): ... @profile def quicksort(array): ... Then type kernprof -v -l sorts.py in your terminal. The output will look like: ‚¨áÔ∏è Wrote profile results to sorts.py.lprof Timer unit: 1e-06 s Total time: 0.382157 s File: sorts.py Function: insertionsort at line 11 Line # Hits Time Per Hit % Time Line Contents ============================================================== 11 @profile 12 def insertionsort(array): 13 14 25881 10925.0 0.4 2.9 for i in range(len(array)): 15 24881 10814.0 0.4 2.8 j = i-1 16 24881 11411.0 0.5 3.0 v = array[i] 17 221660 133321.0 0.6 34.9 while j \u003e= 0 and v \u003c array[j]: 18 196779 113095.0 0.6 29.6 array[j+1] = array[j] 19 196779 88824.0 0.5 23.2 j -= 1 20 24881 13333.0 0.5 3.5 array[j+1] = v 21 1000 434.0 0.4 0.1 return array Total time: 0.162542 s File: sorts.py Function: quicksort at line 24 Line # Hits Time Per Hit % Time Line Contents ============================================================== 24 @profile 25 def quicksort(array): 26 33150 24083.0 0.7 14.8 if len(array) \u003c= 1: 27 17075 9918.0 0.6 6.1 return array 28 16075 10775.0 0.7 6.6 pivot = array[0] 29 16075 46333.0 2.9 28.5 left = [i for i in array[1:] if i \u003c pivot] 30 16075 46896.0 2.9 28.9 right = [i for i in array[1:] if i \u003e= pivot] 31 16075 24537.0 1.5 15.1 return quicksort(left) + [pivot] + quicksort(right) So we can easily find that the bottleneck(rows which have high % Time). More details can be found on this ü§îNow we come to the memory_profiler part. If you haven‚Äôt installed it, you may run pip install -U memory_profiler. The usage of memory_profiler is quite similar to the line_profiler. Both of them need to add @profile first, then you can run ``. The output will be like ‚¨áÔ∏è Filename: sorts.py Line # Mem usage Increment Occurences Line Contents ============================================================ 11 38.176 MiB 38.176 MiB 1000 @profile 12 def insertionsort(array): 13 14 38.176 MiB 0.000 MiB 25694 for i in range(len(array)): 15 38.176 MiB 0.000 MiB 24694 j = i-1 16 38.176 MiB 0.000 MiB 24694 v = array[i] 17 38.176 MiB 0.000 MiB 223188 while j \u003e= 0 and v \u003c array[j]: 18 38.176 MiB 0.000 MiB 198494 array[j+1] = array[j] 19 38.176 MiB 0.000 MiB 198494 j -= 1 20 38.176 MiB 0.000 MiB 24694 array[j+1] = v 21 38.176 MiB 0.000 MiB 1000 return array Filename: sorts.py Line # Mem usage Increment Occurences Line Contents ============================================================ 24 38.172 MiB 38.148 MiB 33522 @profile 25 def quicksort(array): 26 38.172 MiB 0.000 MiB 33522 if len(array) \u003c= 1: 27 38.172 MiB 0.000 MiB 17261 return array 28 38.172 MiB 0.000 MiB 16261 pivot = array[0] 29 38.172 MiB 0.004 MiB 156337 left = [i for i in array[1:] if i \u003c pivot] 30 38.172 MiB 0.000 MiB 156337 right = [i for i in array[1:] if i \u003e= pivot] 31 38.172 MiB 0.020 MiB 16261 return quicksort(left) + [pivot] + quicksort(right) It is weird, insertion sort is no better than quicksort i","date":"2022-01-03","objectID":"/exercise07-missingsemester-2020/:0:2","tags":["Course","Profiling"],"title":"the solutions for exercise07 of Missingsemester(2020)","uri":"/exercise07-missingsemester-2020/"},{"categories":["Course"],"content":"the solutions for exercise05 \u0026\u0026 exercise06 of MIT. Missing-semester(2020)","date":"2021-12-27","objectID":"/exercise05-06-missingsemester-2020/","tags":["Course","Bash","Git"],"title":"the solutions for exercise 05\u002606 of MIT.Missing-semester(2020)","uri":"/exercise05-06-missingsemester-2020/"},{"categories":["Course"],"content":"Lecture05. Command-line Environment ","date":"2021-12-27","objectID":"/exercise05-06-missingsemester-2020/:1:0","tags":["Course","Bash","Git"],"title":"the solutions for exercise 05\u002606 of MIT.Missing-semester(2020)","uri":"/exercise05-06-missingsemester-2020/"},{"categories":["Course"],"content":"Job control From what we have seen, we can use some ps aux | grep commands to get our jobs‚Äô pids and then kill them, but there are better ways to do it. Start a sleep 10000 job in a terminal, background it with Ctrl-Z and continue its execution with bg. Now use pgrep to find its pid and pkill to kill it without ever typing the pid itself. (Hint: use the -af flags). \u003e sleep 10000 # press Ctril-Z # output: [1] + 29705 suspended sleep 10000 \u003e bg %1 # output: [1] + 29705 continued sleep 10000 \u003e pgrep -af \"sleep\" # output: 29705 \u003e pkill -af \"sleep\" # output: [1] + 29705 terminated sleep 10000 Apparently, pgrep and pkill are quite handy. We won‚Äôt be bothered to find out the pid ourselves. Say you don‚Äôt want to start a process until another completes. How would you go about it? In this exercise, our limiting process will always be sleep 60 \u0026. One way to achieve this is to use the wait command. Try launching the sleep command and having an ls wait until the background process finishes. However, this strategy will fail if we start in a different bash session, since wait only works for child processes. One feature we did not discuss in the notes is that the kill command‚Äôs exit status will be zero on success and nonzero otherwise. kill -0 does not send a signal but will give a nonzero exit status if the process does not exist. Write a bash function called pidwait that takes a pid and waits until the given process completes. You should use sleep to avoid wasting CPU unnecessarily. We can use wait \u003cpid\u003e to wait for a process to complete before proceeding. Then the question is what is exactly the pid of sleep 60 \u0026. In last exercise, we know we can use pgrep to get the pid by process name. So the basic solution will be: \u003e sleep 60 \u0026 \u003e pgrep \"sleep\" | wait \u0026\u0026 ls However, the wait command is session-dependent. So we need to use kill -0. The pidwait() in pidwait.sh is like ‚¨áÔ∏è #!/bin/bash pidwait() { while kill -0 $1 2\u003e/dev/null # catch stderr to /dev/null do sleep 1 done ls } You can test like this ‚¨áÔ∏è \u003e source pidwait.sh \u003e sleep 60 \u0026 \u003e pidwait $(pgrep \"sleep\") ","date":"2021-12-27","objectID":"/exercise05-06-missingsemester-2020/:1:1","tags":["Course","Bash","Git"],"title":"the solutions for exercise 05\u002606 of MIT.Missing-semester(2020)","uri":"/exercise05-06-missingsemester-2020/"},{"categories":["Course"],"content":"Terminal multiplexer Follow this tmux tutorial and then learn how to do some basic customizations following these steps Just follow the tutorial. ","date":"2021-12-27","objectID":"/exercise05-06-missingsemester-2020/:1:2","tags":["Course","Bash","Git"],"title":"the solutions for exercise 05\u002606 of MIT.Missing-semester(2020)","uri":"/exercise05-06-missingsemester-2020/"},{"categories":["Course"],"content":"Aliases Create an alias dc that resolves to cd for when you type it wrongly. \u003e alias dc=cd Run history | awk '{$1=\"\";print substr($0,2)}' | sort | uniq -c | sort -n | tail -n 10 to get your top 10 most used commands and consider writing shorter aliases for them. Note: this works for Bash; if you‚Äôre using ZSH, use history 1 instead of just history. \u003e alias top10=\"history 1| awk '{\\$1=\\\"\\\";print substr(\\$0,2)}' | sort | uniq -c | sort -n | tail -n 10\" ‚ö†Ô∏è WARNING: You need to use \\ to escape \" and $n ","date":"2021-12-27","objectID":"/exercise05-06-missingsemester-2020/:1:3","tags":["Course","Bash","Git"],"title":"the solutions for exercise 05\u002606 of MIT.Missing-semester(2020)","uri":"/exercise05-06-missingsemester-2020/"},{"categories":["Course"],"content":"Dotfiles Let‚Äôs get you up to speed with dotfiles. Create a folder for your dotfiles and set up version control. Add a configuration for at least one program, e.g. your shell, with some customization (to start off, it can be something as simple as customizing your shell prompt by setting $PS1). Set up a method to install your dotfiles quickly (and without manual effort) on a new machine. This can be as simple as a shell script that calls ln -sfor each file, or you could use a specialized utility. Test your installation script on a fresh virtual machine. Migrate all of your current tool configurations to your dotfiles repository. Publish your dotfiles on GitHub. It is weird. ü§î I created a folder and migrate all my configurations to it. And I also made soft links. However, it is just didn‚Äôt work. ","date":"2021-12-27","objectID":"/exercise05-06-missingsemester-2020/:1:4","tags":["Course","Bash","Git"],"title":"the solutions for exercise 05\u002606 of MIT.Missing-semester(2020)","uri":"/exercise05-06-missingsemester-2020/"},{"categories":["Course"],"content":"Remote machines Install a Linux virtual machine (or use an already existing one) for this exercise. If you are not familiar with virtual machines check out this tutorial for installing one. Go to ~/.ssh/ and check if you have a pair of SSH keys there. If not, generate them with ssh-keygen -o -a 100 -t ed25519. It is recommended that you use a password and use ssh-agent , more info here. Edit .ssh/config to have an entry as follows Host vm User username_goes_here HostName ip_goes_here IdentityFile ~/.ssh/id_ed25519 LocalForward 9999 localhost:8888 Use ssh-copy-id vm to copy your ssh key to the server. Start a webserver in your VM by executing python -m http.server 8888. Access the VM webserver by navigating to http://localhost:9999 in your machine. Edit your SSH server config by doing sudo vim /etc/ssh/sshd_configand disable password authentication by editing the value of PasswordAuthentication. Disable root login by editing the value of PermitRootLogin. Restart the ssh service with sudo service sshd restart. Try sshing in again. (Challenge) Install mosh in the VM and establish a connection. Then disconnect the network adapter of the server/VM. Can mosh properly recover from it? (Challenge) Look into what the -N and -f flags do in ssh and figure out a command to achieve background port forwarding. I don‚Äôt have enough disk space for a linux virtual machine :( ","date":"2021-12-27","objectID":"/exercise05-06-missingsemester-2020/:1:5","tags":["Course","Bash","Git"],"title":"the solutions for exercise 05\u002606 of MIT.Missing-semester(2020)","uri":"/exercise05-06-missingsemester-2020/"},{"categories":["Course"],"content":"Lecture 06. Version Control(git) If you don‚Äôt have any past experience with Git, either try reading the first couple chapters of Pro Git or go through a tutorial like Learn Git Branching. As you‚Äôre working through it, relate Git commands to the data model. :) Clone the repository for the class website Explore the version history by visualizing it as a graph. Who was the last person to modify README.md? (Hint: use git log with an argument). What was the commit message associated with the last modification to the collections: line of _config.yml? (Hint: use git blame and git show). \u003e git clone git@github.com:missing-semester/missing-semester.git \u003e cd missing-semester # step 1. \u003e git log --oneline --all --graph --color # step 2. \u003e git log -1 README.md # -1 means showing last related commit # then we know Anish Athalye is the last person modify README.md # step 3. \u003e git blame _config.yml | grep -E \"collections:\" # then we know the commit's sha-1 value is a88b4eac # we can use `git show` command to get commit message \u003e git show -q a88b4eac # -q means --quiet, it will suppress diff output One common mistake when learning Git is to commit large files that should not be managed by Git or adding sensitive information. Try adding a file to a repository, making some commits and then deleting that file from history (you may want to look at this). I made a new repo and made some commits. Finally I found the correct command to delete a file from all history ü§ó Ths command we are going to use is git filter-repo. If you haven‚Äôt installed it, you may just run brew install git filter-repo (for mac users). Then use this ‚Äúmagic‚Äù command do finish this exercise. \u003e git filter-repo --invert-paths --force --path \u003cfile\u003e The reason why I use --force is that git filter-repo refuses to overwrite my repo. It says my repo doesn‚Äôt look like a fresh clone. The mechanism behind this command is: --invert-paths will only select files matching none of options which we specify by --path. So it will keep everything except \u003cfile\u003e, and overwrite this commit history. Clone some repository from GitHub, and modify one of its existing files. What happens when you do git stash? What do you see when running git log --all --oneline? Run git stash pop to undo what you did with git stash. In what scenario might this be useful? I tried to modify README.md is the repo for the class website. Then I ran git stash. The output is: Saved working directory and index state WIP on master: c2f9535 Merge pull request #172 from chapmanjacobd/patch-1 * 96cca4b (refs/stash) WIP on master: c2f9535 Merge pull request #172 from chapmanjacobd/patch-1 |\\ | * a95c46f index on master: c2f9535 Merge pull request #172 from chapmanjacobd/patch-1 |/ * c2f9535 (HEAD -\u003e master, origin/master, origin/HEAD) Merge pull request #172 from chapmanjacobd/patch-1 Then I ran git stash pop. My modification has come back. The scenario of using git stash is that: For exmaple, say I have beening working on my project in master branch for quite a long time. Now I want to switch to another branch, but my working directory is in a mess. I don‚Äôt want to make a dirty commit to temporarily save my work. Here comes the git stash. I can use this command to temporarily save my half-finished work. ü§ó Like many command line tools, Git provides a configuration file (or dotfile) called ~/.gitconfig. Create an alias in ~/.gitconfig so that when you run git graph, you get the output of git log --all --graph --decorate --oneline. Information about git aliases can be found here. \u003e git config --global --add alias.graph 'log --all --graph --decorate --oneline' \u003e git graph You can define global ignore patterns in ~/.gitignore_global after running git config --global core.excludesfile ~/.gitignore_global. Do this, and set up your global gitignore file to ignore OS-specific or editor-specific temporary files, like .DS_Store. \u003e git config --global core.excludesfile ~/.gitignore_global \u003e echo \".DS_Store\" \u003e\u003e ~/.test Fork the repository for t","date":"2021-12-27","objectID":"/exercise05-06-missingsemester-2020/:2:0","tags":["Course","Bash","Git"],"title":"the solutions for exercise 05\u002606 of MIT.Missing-semester(2020)","uri":"/exercise05-06-missingsemester-2020/"},{"categories":["Course"],"content":"the solutions for exercise03 \u0026\u0026 exercise04 of MIT. Missing-semester(2020)","date":"2021-12-26","objectID":"/exercise03-04-missingsemester-2020/","tags":["Course","Vim"],"title":"the solutions for exercise 03\u002604 of MIT.Missing-semester(2020)","uri":"/exercise03-04-missingsemester-2020/"},{"categories":["Course"],"content":"Lecture 03. Editors (Vim) Complete vimtutor. Note: it looks best in a 80x24 (80 columns by 24 lines) terminal window. It is a tutorial for beginners of vim. I will just put some notes which are not mentioned in course here. U command: When we press u in normal mode, we can undo the last command. What U does is fixing a whole line. Ctrl + G: show your location in the file and the file status. Type the linenumber you want to go, then press G, then you are there. To search for a phrase in the backward direction, use ? instead of / . Type :! followed by an external command to execute that command. Select text to write Use visual mode to select text type :w \u003ctype_filename_here You can also type :!ls to verify this To insert the contents of a file, type :r FILENAME Furthermore, You can also read the output of an external command. For example, :r !ls reads the output of the ls command Type a capital R to replace more than one character. Download our basic vimrc and save it to ~/.vimrc. Read through the well-commented file (using Vim!), and observe how Vim looks and behaves slightly differently with the new config. I would recommend making your own configuration. Install and configure a plugin: ctrlp.vim Create the plugins directory with mkdir -p ~/.vim/pack/vendor/start Download the plugin: cd ~/.vim/pack/vendor/start; git clone https://github.com/ctrlpvim/ctrlp.vim Read the documentation for the plugin. Try using CtrlP to locate a file by navigating to a project directory, opening Vim, and using the Vim command-line to start :CtrlP. Customize CtrlP by adding configuration to your ~/.vimrc to open CtrlP by pressing Ctrl-P. PASS To practice using Vim, re-do the Demo from lecture on your own machine. PASS Use Vim for all your text editing for the next month. Whenever something seems inefficient, or when you think ‚Äúthere must be a better way‚Äù, try Googling it, there probably is. If you get stuck, come to office hours or send us an email. Configure your other tools to use Vim bindings (see instructions above). I have already enable vim mode in my Vscode and zsh. üí™ Further customize your ~/.vimrc and install more plugins. I have made my own configuration (Advanced) Convert XML to JSON (example file) using Vim macros. Try to do this on your own, but you can look at the macros section above if you get stuck. The steps: Press Gdd \u0026\u0026 ggdd to delete the first line and the last line Macro to format a single element (register e) Go to line with \u003cname\u003e qe^r\"f\u003es\": \"\u003cESC\u003ef\u003cC\"\u003cESC\u003eq Macro to format a person Go to line with \u003cperson\u003e qpS{\u003cESC\u003ej@eA,\u003cESC\u003ej@ejS},\u003cESC\u003eq Macro to format a person and go to the next person Go to line with \u003cperson\u003e qq@pjq Execute macro until end of file 999@q Manually remove last , and add [ and ] delimiters The solution above is provided by the official course site. ","date":"2021-12-26","objectID":"/exercise03-04-missingsemester-2020/:1:0","tags":["Course","Vim"],"title":"the solutions for exercise 03\u002604 of MIT.Missing-semester(2020)","uri":"/exercise03-04-missingsemester-2020/"},{"categories":["Course"],"content":"Lecture 04. Data Wrangling Take this short interactive regex tutorial. Just click this link to finish this regex tutorial. Find the number of words (in /usr/share/dict/words) that contain at least three as and don‚Äôt have a 's ending. What are the three most common last two letters of those words? sed‚Äôs y command, or the tr program, may help you with case insensitivity. How many of those two-letter combinations are there? And for a challenge: which combinations do not occur? The answers of questions in exercise are ‚¨áÔ∏è Q: Find the number of words (in /usr/share/dict/words) that contain at least three as and don‚Äôt have a 's ending. Answer: tr 'A-Z' 'a-z' \u003c /usr/share/dict/words | grep -E '.*a.*a.*a.*[^s]$' | wc -l, üëâ 5290 Use tr 'A-Z' 'a-z' \u003c /usr/share/dict/words to make text case-insensitive Use grep -E 'grep -E '.*a.*a.*a.*[^s]$' to find the words that contain at least three a and don‚Äôt have a 's ending The combination of .* means any character repeats any times. [s] will match the s character. We add a ^ in [], which mean we want to match any single character excepet s Use wc -l to count the number of lines in output. Q: What are the three most common last two letters of those words? A: tr 'A-Z' 'a-z' \u003c /usr/share/dict/words | grep -E '.*a.*a.*a.*[^s]$' | grep -E -o '.{2}$' | sort | uniq -c | sort | tail -n 1, üëâ 1039 al and 763 an and 637 ae Use grep -E -o '.{2}$' to get last 2 letters of these words -o means Prints only the matching part of the lines. In this case, what we want is the last 2 letters, so we type .{2}$ Use sort | uniq -c to get the two-letter combinations count This can ensure the combinations are uniq. Use sort | tail -n 3 to sort previous results according to their frequency counts Q: How many of those two-letter combinations are there? A: tr 'A-Z' 'a-z' \u003c /usr/share/dict/words | grep -E '.*a.*a.*a.*[^s]$' | grep -E -o '.{2}$' | sort | uniq -c | wc -l, üëâ 140 Q: And for a challenge: which combinations do not occur? diff \u003c(echo {a..z}{a..z} | tr \" \" \"\\n\") \\ \u003c(tr 'A-Z' 'a-z' \u003c /usr/share/dict/words | grep -E '.*a.*a.*a.*[^s]$' | grep -E -o '.{2}$' | sort | uniq -c | sort | awk '{print $2}' | sort) \\ | grep -E \"\u003c\" \\ | wc -l # output: 536 Use echo {a..z}{a..z} to get all two-letter combinations. However, in order to compare 2 sets of combinations(this one \u0026\u0026 Our previous results), we need to use \\n as delimiter of each combination. We can use tr \" \" \"\\n\". In the previous question, we can get every different combinations and their frequency counts. Each row looks like \u003cfrequency count\u003e combination. In order to get the combinations, we can use awk {print $2}, $2 means the second field in each row. After that, we need to Then we need a tool to compare the 2 sets of combinations. Here comes the diff command. diff will compare 2 files line by line. We also need Process substation to pass the 2 sets of combinations as arguments of diff To do in-place substitution it is quite tempting to do something like sed s/REGEX/SUBSTITUTION/ input.txt \u003e input.txt. However this is a bad idea, why? Is this particular to sed? Use man sed to find out how to accomplish this. This exercie remind me of the shellcheck tool. So I just type sed s/REGEX/SUBSTITUTION/ input.txt \u003e input.txt in a test.sh file and run shellcheck test.sh. Then I knew THIS IS A BAD IDEA. üìí We should not read and write the same file in the same pipeline. After checking man sed carefully, I found 2 flags helpful‚Äì-i and -I. Both of them can edit file in-place. More information, you may check Find your average, median, and max system boot time over the last ten boots. Use journalctl on Linux and log show on macOS, and look for log timestamps near the beginning and end of each boot. On Linux, they may look something like: Logs begin at ... and systemd[577]: Startup finished in ... On macOS, look for: === system boot: and Previous shutdown cause: 5 I am a macos user. I barely shutdown my Macbook Pro. So when I ran log show | grep -E \"log show | grep -E \"system boot\", it","date":"2021-12-26","objectID":"/exercise03-04-missingsemester-2020/:2:0","tags":["Course","Vim"],"title":"the solutions for exercise 03\u002604 of MIT.Missing-semester(2020)","uri":"/exercise03-04-missingsemester-2020/"},{"categories":["Course"],"content":"References Accessing last x characters of a string in Bash Process substitution ","date":"2021-12-26","objectID":"/exercise03-04-missingsemester-2020/:3:0","tags":["Course","Vim"],"title":"the solutions for exercise 03\u002604 of MIT.Missing-semester(2020)","uri":"/exercise03-04-missingsemester-2020/"},{"categories":["Python"],"content":"A simple guide of drawing relation graph in python","date":"2021-12-25","objectID":"/how-to-draw-a-simple-relation-graph-in-python/","tags":["Data-visualization","Python"],"title":"How to draw a simple relation graph in Python","uri":"/how-to-draw-a-simple-relation-graph-in-python/"},{"categories":["Python"],"content":"Intro The process of drawing a simple relation graph in python can be broken down into 2 steps. Define a graph. Draw a graph. ","date":"2021-12-25","objectID":"/how-to-draw-a-simple-relation-graph-in-python/:1:0","tags":["Data-visualization","Python"],"title":"How to draw a simple relation graph in Python","uri":"/how-to-draw-a-simple-relation-graph-in-python/"},{"categories":["Python"],"content":"Step 1. Define a graph In this step, we will use the networkx package. ","date":"2021-12-25","objectID":"/how-to-draw-a-simple-relation-graph-in-python/:2:0","tags":["Data-visualization","Python"],"title":"How to draw a simple relation graph in Python","uri":"/how-to-draw-a-simple-relation-graph-in-python/"},{"categories":["Python"],"content":"Install tutorial If you are using conda, you can just type conda install networkx If you are using pip, you can just type pip install networkx ","date":"2021-12-25","objectID":"/how-to-draw-a-simple-relation-graph-in-python/:2:1","tags":["Data-visualization","Python"],"title":"How to draw a simple relation graph in Python","uri":"/how-to-draw-a-simple-relation-graph-in-python/"},{"categories":["Python"],"content":"Nodes First of all, you need to create a graph. import networkx as nx G = nx.Graph() You can use different ways to add nodes. Add one node at a time. Add nodes from any iterable container Add nodes along with node attributes. In this way, you can define many attributes of a node, such as color, size, etc. Add nodes from another graph directly G.add_node(1) # method 1 G.add_nodes_from([2, 3, 4, 5]) # method 2 G.add_nodes_from([ # method 3 (6, {\"color\": \"red\"}), (7, {\"color\": \"blue\"}) ]) G2 = nx.Graph() # method 4 G2.add_nodes_from([8, 9, 10]) G.add_nodes_from(G2) # you can verify nodes by print(G.nodes) # NodeView((1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) ","date":"2021-12-25","objectID":"/how-to-draw-a-simple-relation-graph-in-python/:2:2","tags":["Data-visualization","Python"],"title":"How to draw a simple relation graph in Python","uri":"/how-to-draw-a-simple-relation-graph-in-python/"},{"categories":["Python"],"content":"Edges Also, networkx has many ways to add edges, which is quite similar to add nodes. Let‚Äôs just jump to the codeü§ó G.add_edge(1, 2) # method 1 G.add_edges_from([(1, 3), (1, 4)]) # method 2 G2.add_edge(8, 9) # method 3 G2.add_edge(8, 10) # WARNING: you can't just use G2 instead of G2.edges G.add_edges_from(G2.edges) # method 4 ","date":"2021-12-25","objectID":"/how-to-draw-a-simple-relation-graph-in-python/:2:3","tags":["Data-visualization","Python"],"title":"How to draw a simple relation graph in Python","uri":"/how-to-draw-a-simple-relation-graph-in-python/"},{"categories":["Python"],"content":"Get some information about a graph Usually, we want to know some information about a graph. For example, we may want to know the number of nodes and edges, the degree of a node, etc. Of course, networkx implements this for us.‚¨áÔ∏è # nodes information print(list(G.nodes)) # output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print(G.number_of_nodes()) # output: 10 # edges information print(list(G.edges)) # output: [(1, 2), (1, 3), (1, 4), (8, 9), (8, 10)] print(G.number_of_edges()) # output: 5 # neighbors of a node print(list(G.neighbors(1))) # output: [2, 3, 4] # degree information print(G.degree(1)) # output: 3, because we have edges: (1, 2), (1, 3), (1, 4) ","date":"2021-12-25","objectID":"/how-to-draw-a-simple-relation-graph-in-python/:2:4","tags":["Data-visualization","Python"],"title":"How to draw a simple relation graph in Python","uri":"/how-to-draw-a-simple-relation-graph-in-python/"},{"categories":["Python"],"content":"manipulate nodes \u0026\u0026 edges The operation of removing is the inverse process of the operation of adding. G.remove_node(5) G.remove_nodes_from(G2) # similar to remove_node \u0026\u0026 remove_nodes_from # you can add parameters you like # G.remove_edge() # G.remove_edges_from() ","date":"2021-12-25","objectID":"/how-to-draw-a-simple-relation-graph-in-python/:2:5","tags":["Data-visualization","Python"],"title":"How to draw a simple relation graph in Python","uri":"/how-to-draw-a-simple-relation-graph-in-python/"},{"categories":["Python"],"content":"ü§î üìí The node type doesn‚Äôt have to be an integer. It can also be a string. new_G = nx.Graph() # Let's define a new graph new_G.add_node(\"abcd\") # Add a string node new_G.add_nodes_from(\"abcd\") # this line is different, we treat the string as an iterable cotainer print(list(new_G.nodes)) # output: ['abcd', 'a', 'n', 'c', 'd'] ","date":"2021-12-25","objectID":"/how-to-draw-a-simple-relation-graph-in-python/:2:6","tags":["Data-visualization","Python"],"title":"How to draw a simple relation graph in Python","uri":"/how-to-draw-a-simple-relation-graph-in-python/"},{"categories":["Python"],"content":"Step 2. Draw a graph Although we can draw a graph defined by networkx in matplotlib.pyplot, the generated image is static and not pretty in my opinion. So I will just skip the tutorial of drawing in matplotlib.pyplot. I will use pyvis package instead. ","date":"2021-12-25","objectID":"/how-to-draw-a-simple-relation-graph-in-python/:3:0","tags":["Data-visualization","Python"],"title":"How to draw a simple relation graph in Python","uri":"/how-to-draw-a-simple-relation-graph-in-python/"},{"categories":["Python"],"content":"Install tutorial I didn‚Äôt find how to use conda to install pyvis, so you may just use pip install pyvis. I remember that we can use pip in conda environment, but we need to run conda install pip at first(Not quite sureüò®) ","date":"2021-12-25","objectID":"/how-to-draw-a-simple-relation-graph-in-python/:3:1","tags":["Data-visualization","Python"],"title":"How to draw a simple relation graph in Python","uri":"/how-to-draw-a-simple-relation-graph-in-python/"},{"categories":["Python"],"content":"How to use pyvis from pyvis.network import Network net = Network('500px', '500px') net.from_nx(G) # The G is defined in Step 1. net.show('net.html') Then you can open the net.html in your local machine to interact with it. It looks like this‚¨áÔ∏è I don‚Äôt know how to integrate my html file into this blog. You may check the result in this (If you follow my tutorial) ","date":"2021-12-25","objectID":"/how-to-draw-a-simple-relation-graph-in-python/:3:2","tags":["Data-visualization","Python"],"title":"How to draw a simple relation graph in Python","uri":"/how-to-draw-a-simple-relation-graph-in-python/"},{"categories":["Python"],"content":"ü§î üìí In pyvis, the valid node attributes are‚¨áÔ∏è. So when we use networkx to add nodes, we can directly use these attributes. In this way, the pyvis will translate them for us. ['size', 'value', 'title', 'x', 'y', 'label', 'color'] Similarly, if you want to customize your edges‚Äô attributes, you may check the docs Then you can use G.add_edge(a, b, attribute1=, attribute2, ...) ","date":"2021-12-25","objectID":"/how-to-draw-a-simple-relation-graph-in-python/:3:3","tags":["Data-visualization","Python"],"title":"How to draw a simple relation graph in Python","uri":"/how-to-draw-a-simple-relation-graph-in-python/"},{"categories":["Python"],"content":"References visjs docs pyvis docs networkx tutorial ","date":"2021-12-25","objectID":"/how-to-draw-a-simple-relation-graph-in-python/:4:0","tags":["Data-visualization","Python"],"title":"How to draw a simple relation graph in Python","uri":"/how-to-draw-a-simple-relation-graph-in-python/"},{"categories":["Course"],"content":"the solutions for exercise01 \u0026\u0026 exercise02 of MIT. Missing-semester(2020)","date":"2021-12-18","objectID":"/exercise01-02-missingsemester-2020/","tags":["Course","Bash"],"title":"the solutions for exercise 01\u002602 of MIT. Missing-semester(2020)","uri":"/exercise01-02-missingsemester-2020/"},{"categories":["Course"],"content":"Lecture 01. Shell Create a new directory called missing under /tmp \u003e mkdir -p /tmp/missing üìí -p means Create intermediate directories as required Use touch to create a new file called semester in missing. \u003e cd ~/tmp/missing \u003e touch semester Write the following into that file, one line at a time: #!/bin/sh curl --head --silent https://missing.csail.mit.edu ‚ö†Ô∏è Make sure you are in the tmp/missing directory start from now. \u003e echo \"#\\!/bin/sh\" \u003e\u003e semester \u003e echo \"curl --head --silent https://missing.csail.mit.edu\" \u003e\u003e semester ‚ö†Ô∏è WarningÔºö! has a special meaning even within double-quoted(\") strings, so when we use echo \"...\" to append a string to a file, remember to use \\ to escape ! Try to execute the file \u003e ./semeseter # ... permission denied \u003e ls -l # you can see the permission bits are -rw-r--r-- # It suggests that we don't have execute(x) permission ## Solution 1. # run command below to, u means user, x means execute \u003e chmod u+x semester \u003e ./semester # You should see the outputs like: # HTTP/2 200 # server: GitHub.com # ... ## Solution 2. \u003e sh ./semester üìí use chmod to change the file permission, see man chmod for more information. I will suggest the tldr tool, which is quite handy, you may check tldr chmod by yourselfü§ó Use | and \u003e to write the ‚Äúlast modified‚Äù date output by semester into a file called last-modified.txt in your home directory. # Solution 1. \u003e date -r semester \u003e last-modified.txt # Solution 2. \u003e ls -l semester | awk '{print $6,$7,$8}' \u003e last-modified.txt Write a command that reads out your laptop battery‚Äôs power level or your desktop machine‚Äôs CPU temperature from /sys I am a macOS user, so I will just skip this exercise:) ","date":"2021-12-18","objectID":"/exercise01-02-missingsemester-2020/:1:0","tags":["Course","Bash"],"title":"the solutions for exercise 01\u002602 of MIT. Missing-semester(2020)","uri":"/exercise01-02-missingsemester-2020/"},{"categories":["Course"],"content":"lecture 02. Shell Tools and Scripting write an ls command that lists files in the following manner Includes all files, including hidden files Sizes are listed in human readable format (e.g. 454M instead of 454279954) Files are ordered by recency Output is colorized A sample output would look like this -rw-r--r-- 1 user group 1.1M Jan 14 09:53 baz drwxr-xr-x 5 user group 160 Jan 14 09:53 . -rw-r--r-- 1 user group 514 Jan 14 06:42 bar -rw-r--r-- 1 user group 106M Jan 13 12:12 foo drwx------+ 47 user group 1.5K Jan 12 18:08 .. Interpretation Usually, the filename of hidden files are begin with ., we can use -a flag to include them. If you want to list sizes in human readable format, use -lh According to the man lsÔºå-t means the output are sort by descending time modified (most recently modified first) In order to enable colorized output, use -G So the solution is‚¨áÔ∏è \u003e ls -a -lh -t -G Write bash functions marco and polo that do the following. Whenever you execute marco the current working directory should be saved in some manner, then when you execute polo, no matter what directory you are in, polo should cd you back to the directory where you executed marco. For ease of debugging you can write the code in a file marco.sh and (re)load the definitions to your shell by executing source marco.sh. The marco.sh‚¨áÔ∏è I store the output of pwd in ~/pwd.txt file. #!/bin/bash marco() { touch ~/pwd.txt pwd \u003e\u003e ~/pwd.txt } The poli.sh‚¨áÔ∏è Just use cat ~/pwd.txt to get the origin working directory. #!/bin/bash poli() { destination=$(cat ~/pwd.txt) cd \"$destination\" || exit } Quick test‚¨áÔ∏è \u003e source marco.sh \u003e source poli.sh \u003e marco \u003e cd .. # you can cd wherever you want \u003e poli # now you will go back to origin working directory üìí I highly recommend the shellcheck tool. Use it to check your *.sh file after you have finished your code. Say you have a command that fails rarely. In order to debug it you need to capture its output but it can be time consuming to get a failure run. Write a bash script that runs the following script until it fails and captures its standard output and error streams to files and prints everything at the end. Bonus points if you can also report how many runs it took for the script to fail. #!/usr/bin/env bash n=$(( RANDOM % 100 )) if [[ n -eq 42 ]]; then echo \"Something went wrong\" \u003e\u00262 echo \"The error was using magic numbers\" exit 1 fi echo \"Everything went according to plan\" The meaning of this script is judge if a random number(n) equal 42 or not. The random number ranges from 0 to 99, so we may need to run many many time until we get a 42. In order to debug this *.sh file, we can measure how many times we run this *.sh. Apparently, we can use do-while loop, which corresponds to until-loop in bash. I found this Link helpful. The solution is(test.sh)‚¨áÔ∏è #!/bin/bash count=0 # run random.sh until it goes wrong until [[ \"$?\" -ne 0 ]];do # $? will return the exit status of the most recently executed command count=$((count + 1)) bash ./random.sh \u0026\u003e result.txt # \u0026 means we run the random.sh in the background. done echo \"Error dectected: $count runs\" cat result.txt Quick test‚¨áÔ∏è \u003e bash test.sh As we covered in the lecture find‚Äôs -exec can be very powerful for performing operations over the files we are searching for. However, what if we want to do something with all the files, like creating a zip file? As you have seen so far commands will take input from both arguments and STDIN. When piping commands, we are connecting STDOUT to STDIN, but some commands like tar take inputs from arguments. To bridge this disconnect there‚Äôs the xargs command which will execute a command using STDIN as arguments. For example ls | xargs rm will delete the files in the current directory. Your task is to write a command that recursively finds all HTML files in the folder and makes a zip with them. Note that your command should work even if the files have spaces (hint: check -d flag for xargs). If you‚Äôre on macOS, note that the default BSD find is different f","date":"2021-12-18","objectID":"/exercise01-02-missingsemester-2020/:2:0","tags":["Course","Bash"],"title":"the solutions for exercise 01\u002602 of MIT. Missing-semester(2020)","uri":"/exercise01-02-missingsemester-2020/"}]